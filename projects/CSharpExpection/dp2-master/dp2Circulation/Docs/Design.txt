

读者查询现阶段可以采用浅包装的方法。

一方面，把前端发来的检索请求XML，转换为rmsservice可以接受的xml，
进行检索。

另一方面，返回原始的结果集，即以为rmsservice意义上的全路径为
唯一标示的结果集。可以认为这个路径是不透明的，这样前端程序
可以适应将来的变化。

其实可以不用专门开发一个新的支持逻辑检索的xml格式，可以用简单的
检索功能，有前端组合后使用，达到类似效果。

~~~~~~~~~~~~~
http://www.codeproject.com/soap/MTOMWebServices.asp
Sending files in chunks with MTOM Web Services and .NET 2.0
By Tim_Mackey 

How to send large files across Web Services in small chunks using MTOM (WSE 3).  


~~~~~~~~~~~
借书权限问题

还书超期问题

赔书(丢失)处理

~~~~~~~~~~
读者检索窗应当在检索发起后，有关按钮呈灰色

~~~~~~~~~~
读者窗在第一次为空窗口装载时，不要警告未保存


~~~~~~~~~~
改错: 
        public ApplicationInfo applicationInfo = new ApplicationInfo("dp2circulation.xml");
将原来误用的dp2rms.xml改为dp2circulation.xml


~~~~~~~~~~
为了实现册登录, 为了自如地检索书目信息, 是否需要增加书目信息检索和浏览
的窗口?

dp2libraryws的API设计, 一则是需要增加检索和浏览任意库的机制, 另外
也要增加根据路径获取记录xml的机制.

~~~~~~~~~~
在circulation.xml中，根据<itemdbgroup>可以获知参与流通的书目库：

    <itemdbgroup>
        <database name="中文图书实体" />
    </itemdbgroup>
    
并且，可以从内核获得每个书目库的检索途径和style。

这样，需要增加一个api，对流通前端列出共有的（或者全部）style集合，
并且带出caption(可以取第一个遇上某style的实际caption),
供前端界面检索时选用。

检索书目库的api，就叫做SearchBiblio()，和原来的SearchItem()对应。

一个更简单的办法，是修改内核的检索模块，允许在原来使用from的地方
直接使用style值。这样，前端就可以直接向服务器发送包含style值
的检索请求了。

一个可能的问题是，如果一个库的检索途径并不包含指定的style值，检索
算结果集为空呢还是直接报错？

如果直接报错，就会影响到前端的行为模式。前端就必须搞清楚一个数据库
是否下属有特定的style值，如果没有，就不能乱发出检索请求，这样前端程序
实现起来要复杂一些，就必须预先获得每个数据库的可用style值列表。

~~~~~~~~~
实体查询等窗口，如何知道当前的serverurl 是什么？

可否选择？

为了界面简洁，可以设一个按钮用来查看和设置。配置按钮代码可以在多个窗口之间共享。

~~~~~~~
BookItem类中要增加一些新的栏目描述

另外对于没有描述之外的其他元素, 是否也直接用其元素名装入listview?

~~~~~~~~
明天做实体记录新增和删除的界面

然后是webservice中实现功能

~~~~~~~~
册信息对话框关闭的时候，需要注意检查册条码号是否为空？这是修改、新增的要求。

还要检查其他特殊类型的信息事项，例如时间是否格式正确。

~~~~~~~~~
前端没有指定一个新册的路径时（包含问号id的路径），由于不知道实体库名，
所以不好保存。

但是可以通过书目库路径中的书目库名，查到实体库名呀。这样就允许前端使用
空的路径了。

~~~~~~~~~
服务器端，出于成本考虑，尚无法检查覆盖的册是否确实本来属于一个种？

~~~~~~~~
服务器端在保存前，要进行查重。

还要适当加锁。因此要增加册锁。getiteminfo API，也要注意加锁了。

~~~~~~~~
从"借阅者"条码位置, 应当有一个按钮可以新开读者信息窗,或者出纳窗,以便于观察.

~~~~~~~~
册信息中和借阅有关的字段不能修改。具有这些信息的册不能删除。

~~~~~~~~
接上乐山的数据看看，还缺少对什么字段的显示和处理。

~~~~~~~~
一些字段的可选值数据字典。

~~~~~~~~
编辑界面中"修改册条码号".

1) 需要检查borrower字段是否为空。如果不是空，则不能修改。必须要读者还回图书后才能修改。

2) dp2libraryws服务器端，要适应这种修改的情形，把新旧记录的条码进行对比。
主要是不要忘记对新的条码进行查重。

而如果发现条码没有修改，就不必查重了。

~~~~~~~~~~
需要有一个窗口，可以根据实体记录的路径（而不是册条码号），来查看册和种信息

~~~~~~~~~~
册listview中的点栏目标题排序功能

~~~~~~~~~
目前既然已经有了 根据册记录路径 装入册和相关种的窗口，那么在
册登录流程中，如果遇到重的时候，可以根据重的册记录路径触发调出
相关窗口进行详细观察。

~~~~~~~~
条码册登录的日志该做了。

~~~~~~~
提交时, 只要有一项报错, 就应出现MessageBox提醒.

这个非常重要. 因为被选中的当前事项不变色; 而且listview可能需要卷滚才能看到
被隐藏的报错行.

~~~~~~~~
注意册条码号为空时，不要查重

~~~~~~~~
EntityForm当没有必要保存时，保存按钮应当为发灰状态

~~~~~~~~
entityform中应当有Clear()功能, 相当于刚打开窗口时候的样子?

或者New()功能, 允许新录入一条?

~~~~~~~
检索种命中后, 焦点切换到条码输入textbox时,应当全选其内容

~~~~~~~
馆藏位置应当有列表可供选择值; 册类型也应当有列表; 价格需要从010$a中复制过来(或者从邻近的行复制过来),
这一功能似乎用C#脚本来做比较合适.

为了列表, 可以配置一些具有名称的表, 然后用api可以调用.

~~~~~~
作一个批处理的窗口，每当扫入条码，就实时进行预定的修改

可以一次性修改：馆藏地点　状态　图书类型　...

将来可以把修改请求做成脚本，针对“条码号文件”进行调用。


~~~~~~~
册信息中批次号字段要加入. 要允许检索.

~~~~~~~~~
“装入并修改”按钮上作一个popupmenu，增加“只装入”等选项。

~~~~~~~~~
把新Control用在EntityEditForm上。

列表值API作了。

~~~~~~~~~
给窗口左上角图标配上合适的图像

比方说单册管理，可以使用书本的图像

~~~~~~~~~
作观察日志的API

~~~~~~~~~
借阅操作如果校验了密码，日志中是否携带此校验过的密码信息？

~~~~~~~~
输入的日志文件名可否允许通配符？

如果允许，那么一个窗口中就可能显示若干文件的内容，那么第一栏似乎要
用来显示文件名。

可以这样：如果是单个文件，则只显示序号。如果是来自多个文件，则需要
同时显示文件名和文件内记录序号。

为了通过通配符搜索到实际具有的文件名，还需要增加一个列日志文件名的
新API。这个API很有用。即便不是用来在一个窗口中显示多个日志文件的内容，
也可提供给输入日志文件名的textbox作为选择文件名的对话框或下拉列表使用。

应当可以获得文件总量，并且可以允许一批一批地获取文件名字符串。这样就不限制
日志文件的总数了。

还可以顺便获得文件尺寸参数。文件内记录数就不好获得了，太耗费资源，可以
由GetOperLog去获得（似乎要增加一个小功能，用特殊输入参数值来启动）。


~~~~~~~~~
装入一条一条日志记录的时候, 状态条要显示进度。要可以中断。因此需要用
大量的日志记录来测试。为了造成大量的日志记录，前端似乎必须有模拟批
操作的能力。

如果能得知记录偏移量,和文件尺寸, 则还可以用Progress显示进度。不过这似乎需要
将hint明确化，明确为偏移量。

~~~~~~~~~~
把各种类型的日志格式用文字描述清楚，作为开发的依据。避免从源代码中去揣测。

~~~~~~~~~~
MergOldNewReaderInfo()函数还有缺陷：
1) 没有对修改条码的情况，针对新条码进行查重。
2) 没有屏蔽对流通信息字段的修改。
需要仿照SetEntities() API进行大幅度改造。有关读者条码查重，可以参考SetEntities()
那里的经验，专门制作一个函数，便于编码。

~~~~~~~~
读者身份可以修改的读者信息元素, 可以用一个逗号分割的列表来表示, 便于编程和修改

部分字段被拒绝,这一返回状态,还没有实现

~~~~~~~~
读者类型字段应当有下拉列表了。

~~~~~~~
读者信息增加　state　字段

~~~~~~~~
新创建一条读者记录？空白窗口

~~~~~~~
删除读者记录要做了。注意测试有流通信息的不能删除。

~~~~~~~
在“初始化浏览器组件”阶段比较缓慢，可以放在MainForm初始化阶段进行，即
在Client上放一个浏览器，显示产品网站主页面什么的。

~~~~~~~
dp2libraryws中需要定义读者条码号和册条码号的校验规则，用RegularExpression字符串来定义。

前端获取到这两个字符串后，一个是在读者信息保存的时候预先校验一下，
一个册登录的时候预先校验，一个是出纳的时候校验一下。

如果两种条码可以区别，出纳窗还可以开发出更灵活的功能。

服务器端相关API也要对条码实施校验。

SetEntities() SetReaderInfo() Borrow() Return() ...

~~~~~~~~~~
如何知道当前用户是读者还是工作人员呢？

似乎可以从Channel中用API获取已登录的身份？

根据身份，可以出现不同的读者信息编辑画面。当读者利用这个界面时，
就可以预先看到有些字段不能编辑。可以避免编辑后提交后才发现不能修改的尴尬局面。

如果有服务器拒绝兑现的修改，需要明确提示。

~~~~~~~~~
EntityForm中增加的新册, 或者修改册信息, 除了要对条码进行查重,
另外也要对(非空)路径对窗口内所有册进行查重.

~~~~~~~~
SetEntities()和SetReaderInfo() API中的"changed"和"deleted"
都要修改为"change"和"delete"

~~~~~~~~
册管理中标记删除时，现在已经做到前端发现有流通信息就不会标记，这会妨碍测试
API的严密性过程，需要有一个Ctrl键或者什么的秘密功能，可以标记上，才能提交，
才能方便测试。

有流通信息时，册条码号不能修改，也是一个妨碍。需要有特殊的绕过去的方法。

~~~

读者信息窗中，也需要做有流通信息则读者证条码号不能修改的功能。不过因为流通信息
没有直接在Control中显示出来，有点费解。可以原始地显示流通信息在Control中，
也可以不显示，但是可以感知。

还有一个可以改进的地方，就是可以在流通信息字段格式稳定后，在读者Control中也用
listview显示出借还、罚款、预约请求信息。这样，右边的超文本必要性就不大了，
因为此时Control已经能够显示全部信息。

当这些功能都完成后，需要注意为测试留下口子，比方说有流通信息时间，也去修改
证条码号，测试API功能是否正确。

有流通信息时读者记录不能删除，相信服务器API已经实现了(需要测试)。现在需要在前端也实现
这个检查。

~~~~
"保存操作发生错误"说法,修改为"保存操作被拒绝"更好.

~~~~~~~~
日志观察界面，可以利用浏览器可以突出差异的功能，对
SetEntity和SetReaderInfo的新旧记录进行显示，揭示出修改过的部分。
这个界面应当很好用。

~~~~~~~~
“罚款”库中每个记录唯一的id要可以检索？ 或者根据册条码号检索出多条来，
再读出每条记录甄别？

考虑这个是为了Amerce()的Undo功能

~~~~~~~~
AmerceForm可以再增加一个窗格, 放在上面，里面显示该读者已经交过的罚款。


每当交罚款成功后，就刷新一下这个窗格，操作者就会看到，下面的信息跑到上面去了，
很形象，也很让人放心。如果要Undo，上面这个窗格也是一个好的操作界面，
可以把握。

~~~~~~~~
dp2libraryws中增加的Search() API,其检索了哪些数据库可以通过分析xml检索式看出,
也是可以限制和报错的。

可以和SearchOneDb()一起共用一个检查xml检索式的模块。

~~~~~~~~
如果有某些API为了容错的需要，比方在读者条码发生重复的情况下，选择了其中某一个
记录进行处理，这样创建的日志记录，将来在重新模拟的时候会遇到困难。

如果从多个中选择其一的标志很明显，是抽象的，而不是和具体记录路径有关的，这还
可以模拟，否则就不好模拟了。

而且，如果系统管理员通过dp2rms这样的管理工具去修改数据库记录，这样的修改是没有
纳入事件日志的。这样，后面的某些API操作就缺乏前因后果，模拟运行时的状态，
可能和原始运行的状态，完全不同。

API设计的原则，也主要是抽象，比方说能用条码定位的地方，绝不用记录路径。设计
上也假定记录路径是易变的、不确定的，而且也没有打算把记录路径改变的所有因素
纳入日志记载。所以条码重复这一特殊情况，对模拟是一个挑战。

解决的办法，就是第一尽量不让形成条码重的局面；第二，如果遇到这个局面，系统
管理员在修改记录的时候，尽量在dp2libraryws的API下修改，这样就可以纳入日志
范畴，在将来重放模拟时，会和原始执行时一样，得到解决。

~~~~~~~~~
Amerce() API中，尚未自动计算罚款金额。

这还需要设置一系列配置参数，定义算法公式。

~~~~~~~~~~
出纳操作中, 信息提示需要用专门的对话框, 用红色\黄色\绿色 3种颜色
表示操作的成功与否.

~~~~~~~~~~
EntityDupDlg需要被ItemDupDlg替代。

~~~~~~~~~~
除了Borrow()和Return()以外，其他 API 类似Reservation这样的，
也要检查对timestampmismatch的适应性。

像预约、网上续借这样的不是太要害的操作，只要能够正确Undo即可，
不Redo也可以。

另外，像Return()部分成功后，发生了预约册进入队列等附带操作，
如何Undo，也是一个问题需要解决。

如果Redo成功，已经发生的副作用也许正好合适。就怕Redo也不成功，
就留下了垃圾数据。

~~~~~~~~~~~
册记录和读者记录在(SetEntities()和SetReaderInfo())修改条码时, 
目前的处理是只对新条码加锁, 是否需要改进为对新旧两个条码都加锁？

现有的处理方法的思路，是旧条码无论冲突还是不冲突，都无关紧要了。
而新的处理方法，仅仅是避免了一些对旧条码的不必要冲突（因为锁定后，
会导致并发的、稍后来的、对旧条码的处理延迟，而等待结束时，先一步的
修改过程已经把旧条码去除了，这样后一步的处理就看不到旧条码存在了，
就避免了不必要的冲突）

~~~~~~~~~~
计算超期时间，还需要增加工作日历功能。

超期的计算，是观察超期临界日，如果这天（小时）是非工作日，那么就不算超期。
超期多少天，是把还书的日子，减去临界日后最后一个工作日的天数。

~~~~~~~~~
要在出纳窗 读者条码右边的按钮还是什么位置，增加一个快捷打开罚款窗的
菜单或者其他方式。

~~~~~~~~
罚款窗的界面上出现的时间字符串，最好翻译为本地时间。

后面还可以加上括号，显示（1小时前）等等字样，帮助工作人员判断。

~~~~~
为什么ArriveMonitor线程并没有等那么久就开始第一轮处理了？

在中间很长的间歇中，最好能给出一个进度信息，说下一轮处理将在延时
多久以后开始处理（或者显示为始的绝对时刻，因为前端时间起点在不停变）


~~~~
如果要webbrowser始终保持末行可见，可以得到它的handle，然后向它发出
适当的卷滚条调息。

~~~~~~
罚款金额的定义，可以采用“人民币100元”这样的书写方式，也就是说又有前缀，
又有后缀，程序要修改成适应这种方式。


~~~~~~~
dp2libraryws安装程序，需要对libraryman帐户定义对于cfgs目录的children_leaf
的list,read权限。

顺便发现一个问题：dp2manager在对内核一个账户修改了权限后，内存中缓存的
信息还在，用户仍表现为有旧的权限，只有当IIS重新启动后，新权限才生效。

~~~~~~~
如果circulation.xml中的rmsws url等参数不对，在写入error.txt的错误信息中，
没有具体的url地址，只有一个401错误信息，会让人困惑。希望报错信息加上
具体的URL。

另外，最好错误信息也同时写入操作系统的事件日志？


~~~~~~~~
读者信息编辑器中的未初始化的生日日期，应当为一个很遥远的日期才对，
而不应是2005年这样具体的日期。

~~~~~~~
激活窗中应增加XML view，便于看那些增补的（编辑器显示不出来的）字段。

~~~~~~~~
日志窗中输入的日志文件名，应允许没有.log扩展名


附件要显示出来。

~~~~~~~
管理员强制修改用户密码。

用户自己修改密码。

~~~~~~
listview中应当有一栏，当某行用户信息被修改后，此栏出现一个星号。或者
该行变颜色也可。这样，保存按钮可以一次保存多个用户信息。

保存用户信息的功能可以不涉及更换listviewitem的tag。由选择切换
的模块来负责。这样做的好处，是listview为空的时候，也可以创建和修改用户信息。

~~~~~~
发证日期 和 失效期 附近，做一个“使用期”下拉选择（辅助设施），可以
方便通过发证日期自动算出和填入失效期。

~~~~~~
charginginfodlg中ESC键要起作用

~~~~~
休眠一定时间后，出纳窗自动清除读者条码，以让后面有一个清爽的操作环境。

~~~~
册条码输入，借阅成功后，是否清除输入域中的条码号？可以作为一个选项。

~~~~
BarcodeHost修改为LibraryHost

~~~~
条码册登录要检查条码的形式正确性。

条码册登录的时候如何自动获得种信息中的价格，复制到相应的册字段中。
这可能要启用C#脚本。

~~~~
罚款窗的册行上，最好能方便触发观察册信息。


~~~~~
“还”功能，是否需要分为“验证还”和“不验证还”?

~~~~~~~~~
按钮加上icon

~~~~~~~~~
读者信息窗保存重条码时候出现的问题

~~~~~~~~~
有新消息到来的时候（第11个消息），dp2libraryws收件箱没有分页

~~~~~~~~
dp2circulation进入的时候要出现一个登录窗，可以设置缺省帐户

~~~~~~~~
借书、还书有重册条码号的时候，右边书目信息和实体信息要显示正确。

~~~~~~~~
当需要解决重册条码号修改数据问题的时候，正好用册条码进入册管理窗会报错。只好用题名等。

可修改为出现选择册路径的对话框，允许用册条码号进入。
~~~~~~~~
两次连续扫重复的册条码号，应当在一个很短的时间内完成，否则应不起作用。

~~~~~~~~~~
册管理窗需要一个清除按钮，恢复到刚打开窗口时的状态

~~~~~~~~~
双条码方式，如果遇到操作出错，则不要起切换作用

TimeSpan的Hours和TotalHours容易误用，需要检查所有代码。

~~~~~~~~~~
前端配置文件中记忆的密码还是明码。需要加密。

~~~~~~~
登录对话框中的工作台号，要记载到操作日志中。


~~~~~~~~~
批处理窗口中，如果从服务器端获取的没有更新的信息，就不要动IE控件的卷滚条。

另外，checkbox off “一直获取”，为什么要导致重新从头获取？

~~~~~
操作历史。

历史panel可以分一个tab出来，显示来自服务器端的统计信息。


~~~~
登录画面的URL要不让人改。

~~~~~~~
UrgentChargingForm最好具有短期记忆能力，重复的还和借要警告。


~~~~~~~~~
当应急出纳窗打开的时候，工具条仅仅允许在借还之间切换，其他按钮设置为disable状态。


~~~~~~~
出纳可以快速跳到违约金，不必扫读者条码。

~~~~~~~
册管理窗检索册，扫描一个条码装入册后，输入域的焦点丢失了。

~~~~~~~~~
return api lost风格进日志了么？

setreaderinfo changestate风格进日志了么？


~~~~~~~~~
出纳窗中，条码是否强制转换为大写，需要配置一个选项。

~~~~~~~~~
激活窗口中，右边作一个从左边拷贝内容的按钮，功能是只拷贝条码以外的内容过来。

~~~~~~~~~
ReaderInfoForm中，做一个另存按钮。因为现在的装入记录条码修改后保存会报警。

~~~~~~~~~
charginginfodlg出现前，应当恢复text Enabled状态？否则发灰的条码文字会看不清。


~~~~~~~
还书遇到障碍的几种情况：

1) 读者记录中有借阅的这个册条码号，而实体记录中没有借阅者信息。

处理：消除读者记录中的借阅信息，保持实体记录不变。借阅历史字段中注明这个特殊情况。

2) 读者记录中有借阅的这个册条码号，但实体记录根本不存在。

处理：消除读者记录中的借阅信息，并补做条码册登录。借阅历史字段中注明这个特殊情况。

3) 读者记录中没有借阅的这个册条码号，但实体记录中有借阅者信息，能对上号。

这时，特别要询问读者，搞清读者手中有的书的总数。

分为两个情况：

a) 读者记录中表明的若干已借阅册 和 当前疑问册无关。

处理：在实体记录中消除借阅者信息。

b) 读者记录中表明的已借阅册中，有一册就是疑问册。这必须满足如下条件：读者记录中的一个册
的册条码号格式错误，册条码号和疑问册的条码号很相似。如果读者记录中的这个册条码号能够找到实体记录，
并且那个实体记录指回了读者条码，那就和疑问册根本无关。

处理：在实体记录中消除借阅者信息，并在读者记录中消除相关册信息。

4) 读者记录中没有这个册的借阅信息，并且实体记录中也表明没有被人借阅。

注意：读者记录中的已借阅册情况要搞清，排除和当前疑问册的关联。

处理：直接拿回，不做任何处理。

~~~~
借书时遇到障碍的几种情况：

1) 实体信息表明已经被某人借阅。

如果实体和相关读者信息能自圆其说，则补做还回处理，然后借出。

如果只有实体记录中有借阅信息，而其指向的读者信息中没有这册的借阅信息，则参考上面的
还书时处理办法。

2) 实体信息不存在。

处理：补作条码册登录，然后借出。

~~~~~~~~~
itemsearchform中和readersearchform中，listview装入时闪动的问题。还有装入顺序最好
可以配置。

~~~~~~~~~
服务器在加入借阅历史时，不要忘记增量借阅次数属性值。

~~~~~~~~
激活窗口的复制按钮。读者信息窗的另存按钮。

~~~~~~~~
激活功能，应当也允许源记录为空的情况，这就是仅仅修改目标记录的状态而已。
也可以在这种情况下警告一下，并询问是否继续。

~~~~~~
典藏移交窗口，可以设计为类似Wizard或者PropertyPage的风格，把任务分为几个步骤：

1) 指定条码号文件
2) 选定馆藏地点筛选列表。用于警告不合适的馆藏地点
3) 扫描条码，进入listview
4) 统计打印

~~~~~~~~
如果向listview中装载的模块依赖于BookItem类，那最末增加一栏 
种记录路径，就比较困难了。

可以把BookItem中的相关模块抄过来，然后加以变化。

~~~~~~~~~
移交的listview中每行左边的checkbox不应当允许鼠标点击勾选。
而应当通过imagelist图标实现状态显示，把打勾当作状态之一。

文字行的底色：
红色 ERROR
白色 NORMAL
绿色 CHECKED

~~~~~~~~~~
第一次填充为ERROR type的事项，如果在verify时扫入相同条码，
该事项也能变为绿色底色，不过ERROR type就丢失了。
建议保留ERROR type。

如果不保留error type，也可在校验扫入条码时警告这种情况。

上下两个listview中的事项应当能够个别删除？为的是删除个别
错误扫入的条码。

~~~~~~~~~
刚刚verify的条码要滚入视野。重复verify是否要警告？

~~~~~~~~
样式表。

样式表如何在安装的时候拷入数据目录？手册中要提醒用户修改样式表后，备份保存。

~~~~~~~
打印的option配置，包括样式表，应当能够以xml文件格式导出和导入，
以便用户在多台单机之间统一打印参数。

~~~~~~~~
<table>元素的border属性如果不具备，表格是否就不能打印出表格线？

是否将这个特性的定义纳入option中？

~~~~~~~~~
ms-help://MS.VSCC.v80/MS.MSDN.v80/MS.VisualStudio.v80.en/dv_fxmclictl/html/12667861-5b5b-46bc-8fb5-675e25264c9f.htm
Windows Forms Programming  
WebBrowser Control (Windows Forms)  

~~~~~~~~~~
header 和 footer 不要<hr/> ，而采用在<div>矩形的上方或者下方使用border的宽度和颜色
来模拟。

~~~~~~~~
entityform中，新登入一个条码，还未保存的时候，立即删除。此时如果保存，
就会报Assert()

~~~~~~~~
entityform中，快速登入条码的时候，新增的行加入listview时，如果不在可见范围，
需要把它滚入可见范围中。

~~~~~~~~
获得摘要的过程可以优化：从listview中寻找同“种路径”的事项，然后直接采用
它的summary列。不过需要注意的是，所参考的行不应为error状态(error状态此列
包含的是错误信息)。

~~~~~~~~~
装入文件的过程中，许多按钮应当disabled

~~~~~~~~
Quick窗从文件装入的时候，需要Disable窗口界面元素，以防止
中途无意操作。

~~~~~~~~
EntityForm中缺省工作单的下拉列表不能用。


~~~~~~~~
册移交窗口中，list要增加右鼠标键菜单，能够删除行，能够另存到条码号文件。
能够决定装入实体窗口的方式（新开窗口还是占用已有顶层窗口），装入哪类窗口。


~~~~~~~~~
栏标题上要出现排序升降标志、排序优先编号

~~~~~~~~~
为了在sr.ReadLine时显示处理进度，是否需要先读入一遍计算出有多少行，然后
根据行号设置进度？

或者第一次读入一遍时，就直接装入listview第一列了，然后第二遍才是从服务器
获取行中的各列。不过这时需要注意，错误行的处理？

~~~~~~~~~
根据批次号检索窗中拉出combobox列表事项时，有时出现assert()，
说异步操作重入了。

~~~~~~~~~
条码册登录的时候，应当先进行查重？如果查到，应及时警告，就避免了工作人员
输入半天后按OK时才发现重了。

~~~~~~~~~
修改、新增册记录的时候，listview中的对应item都要被选定，并滚入视野。

~~~~~~~~~
慢速登记后，应当对册条码号输入域SelectAll()和Focus()

~~~~~~~~~
prev/next前需要自动把修改反映到listview中。（不等于提交到服务器）

~~~~~~~~~
册管理窗中栏目标题的排序功能

~~~~~~~~
册管理窗的option中可以再增加一个设置是否校验条码的checkbox，这样用户
就不用到整体的CfgDlg中去找了。但CfgDlg那里也保留。

~~~~~~~~~
EntityEditForm中，只要当前editcontrol.Changed == false，
确定按钮就应当为Disable。为了避免误会，此时可以把“取消”修改为“关闭”。

而prev/next已经起到确定的作用。

~~~~~~~~~
EntityEditForm中内容当前后移动观察时，可能修改出与本批或者外部重
的条码，需要进行查重，避免发生这种现象。

~~~~~~~~~~~~
            // TODO: 是否当这个checkbox为false的时候，至少也要检查本种之类的重复情形？
            // 如果这里不检查，可否在提交保存的时候，先查完本种之类的重复，才真正向服务器提交?

~~~~~~~~~~~~~
EntityForm中新装入的事项，应当在装入后立即按照当前已有排序策略排序一次。

当然，如果当前还没有排序策略，就忽略这个操作。

~~~~~~~~~~~
批修改册窗也应当能够校验所输入的条码，并且是否校验的选项还应当设置为true?
其他的几处是否也缺省为true?

~~~~~~~~~~~
批修改册窗的“保存当前记录”按钮，应当紧靠控件放置。

另外“动作参数”按钮，似应修改为“选项”按钮，然后将该对话框改造，
把原来功能并入一个叫做“动作参数”的propertypage，然后把其他选项
放在“配置参数”propertypage中。

~~~~~~~~~~~~
EntityForm:

在要登记进入的条码是重复时，MessageBox警告了，如果选择不打开编辑窗，
在返回本窗口的时候，要正确处理焦点位置。最好在条码输入域。

可能也有类似Quick窗口的焦点问题，即Webbrowser干扰的问题？在装入新种，
WebBrowser发生异步装入的时候。也许要证实和解决。

编辑窗中要实现Esc关闭窗口的功能。刚进入dp2circulation时登录对话框中
也要增加Esc功能。

~~~
批修改实体中的价格。

~~~
缴纳罚款前可以修改价格的能力。

Amerce() API中增加了modifyprice功能。前端和服务器都修改了，需要测试。

特别需要测试recover功能，快照和逻辑恢复都要测。

~~~~~~~
    乐山师院数据来源多，以前的种价格字段格式著录格式多样，有“CNY25.00元”、
“25.00”、“￥25.00元”、“￥25.00”、“CNY25.00”、“cny25.00”、“25.00
元”等等，现在他们确定以后全采用“CNY25.00”格式著录。
    CALIS中，许可重复010$d来表达价格实录和获赠或其它币种价格。所以，可能乐山
师院也有少量的此类重复价格子字段的数据。
    为省成本，批处理或册信息编辑窗中，建议只管一个价格字段，别的都不管（如果
没有价格字段，则转换为空而非零）。
    转换时，是否可以兼顾到用中文全角输入的数字如“２５.００”或小数点是中文
全解但标点选择的是英文标点如“．”？

~~~~
处理步骤：
1) 全部字符转换为半角
2) 抽出纯数字部分
3) 观察前缀或者后缀，如果有CNY cny ￥ 元等字样，可以确定为人民币。
前缀和后缀完全为空，也可确定为人民币。
否则，保留原来的前缀。

~~~~~~~
交违约金的修改价格窗口中，不允许出现任何全角的字符。

~~~~~~~~
BatchTaskForm中，如果遇到IE控件中出现的字符串包含类似<>字符时，
会被当作html格式显示，因而也就看不出来局部字符了。

显然需要转义(HtmlEncoding)后再放入IE控件。但是不清楚到底是该在服务器端
就预先处理好呢，还是到前端再处理，似乎在前端处理有一定难度。

这主要看设计的意图，服务器传过来的到底被认为是纯文本，还是html?

~~~~~~~~
日志统计窗，需要输入一个起始时间和一个结束时间。

先将起止时间规范化为日，这样就可以确定起止日志文件名。

然后在日志记录循环的时候，再跳过那些不在精确时刻范围内的记录。


一开始也可以只让指定单位为日，避免太复杂。

~~~~~~~~~
可以为statis执行设计两个进度条，一个是文件，一个是文件中的记录。

也可以只设计为一个总进度条。

这需要预先遍历每个文件，并探测到每个文件的最大尺寸，把这些尺寸
加起来形成一个总尺寸。这对后面干干净净进行循环也有好处（跳过了那些不存在的文件）。

~~~~~~~~~~
作一个选项，可以在选定的日期范围内为每日创建一个html页面。

日志文件格式优化，以便于进行统计。

~~~~~~~~
移交清单中summary和price需要可以打印“同上”，作为一个选项。

同上必须在“同种”范围内起作用。

如果选择了打印biblioPrice列，而当前biblioRecPath并不是第一排序列，则需要警告。
-- 因为这样打印出来的“种价格”没有意义。

~~~~~~~
要增加可打印索书号的能力。为了提高速度，一个方面是要cache同种的请求，
另外一个方面可以定义一个选项，是否在listview里面真正出现这个列。如果最后
打印结果不要这个列，listview中可以不显示。

也可以在listview中不显示，而直到打印阶段才现从服务器获取。

~~~~~~~
GetBiblio() API需要有能够获取xml 摘要 marc 和 局部的功能，
并且一次可以获取多种格式。必要把输出参数修改为数组。

获取局部，可以定义一种中间格式，类似DC的效果，一次获得多种信息，
例如价格、索书号。

~~~~~~~~~
移交窗在listview中，当第一排序为bibliorecpath的时候，似可以按照它
的变化来分组变化事项底色，每组一个颜色，淡色和深色交替使用，两个颜色就
够了。

用其他列来进行排序的时候，也可以作此处理。

~~~~~~~~~
移交窗打印“同上”的能力。应当在分页阶段后才能确定“同上”，也就是说
如果相同的行内容跨越页，处于下一页的第一行不应打印为“同上”，这样做
的目的是为了在页面散落时，也能清晰了解行内容而不需要依赖前面的页。

因此，“同上”不应显示在listview中。而且那样做也确实影响排序进行，
因为listview的职能是存储原始的数据。

~~~~~~~~~~
入馆登记的listview应当具备隐藏姓名不加以显示的能力？

还能隐藏条码？或者隐藏条码的某些位？

如果隐藏了，可以在ListViewItem的tag中放条码，否则连功能都会实现不了的。

~~~~~~~~~~
入馆登记窗焦点如果长时间不在textbox上，需要自动切过去？

或者发现在不合适的地方输入了字符，例如扫描了条码，自动切焦点过去。

~~~~~~~~~~~
EntityForm装载书目模板的时候，如果当前能看见的是html窗口，需要自动切换到
MarcEditor?

或者在html窗口的时候，load template的工具按钮发灰不让用？

~~~~~~~~~~
EntityForm装入模板记录后，需要把上次残余在窗口内的实体信息清除。

~~~~~~~~~~
entityform的Splitbar位置应当被记忆。当前活动的tabpage也应当被记忆。

~~~~~~~~~~
SetBiblioInfo() 现在已经创建日志。需要做对应的从日志恢复的模块。

~~~~~~~~~~
书目记录向前翻页、向后翻页

~~~~~~~~~~
entityform中实体保存后没有messagebox是很好的，但应在状态条提示。

书目记录保存也应改为这种风格。

保存的时候应当暂时禁止小工具条按钮。

~~~~
删除书目记录的时候警告提示，根据下方是否有实体记录，文字中也要包含提示删除下属多少个实体记录的内容。

删除书目记录成功后，似应提示用户，窗口中残留的记录，并不表明库中还有。
这可以考虑用一个对话框提示，对话框上也有“下次不再出现此对话框”的checkbox

~~~~~
已经删除的，残留的窗口中的实体记录，在重新保存的时候，也应当能够被保存回去。

当然，如果实在不能保存回去，按照利于用户识别的原则，删除的时候就要将窗口内的实体信息清除。

~~~~~~
前端在下载了marcdef配置文件后，要比对里面的marcsyntax定义，看看
和librarys.xml中的定义是否矛盾。

~~~~~~~
普通模式和删除后残余模式的切换

~~~~~~~
读者统计，中间停止后，应能够选择是否创建最终的报表。

~~~~~~~~
为读者检索窗增加输出到条码号文件，和输出到记录路径文件的功能。可作在右鼠标键popup菜单上。

~~~~~~~~~
dp2libraryws GetHire()脚本函数可参考GetReturnDay()函数，运算出一个时间加上一个长度。
用来从起始时间推算结束（失效）时间。

~~~~~~~~~
结算窗listview中，要显示违约金记录的路径，好和ctlno范围对比。

要显示结算操作者和结算操作时间。收费操作者和收费操作时间。

~~~~~~~~~
range中，应能够限制记录状态

分为2种amerced/settlemented

~~~~~~~~
listview增加排序能力

~~~~~~~~
前端一次发送的id不能太多？比方说限制在100以内？

~~~~~~~~
ItemHandoverForm和SettlementForm，如果listview已经在排序状态，
那么新进入的事项，是否尊重了这个顺序？如果不是，则需要想办法
取消列标题上的排序标志，让操作者意识到这个问题。

~~~~~~~~
SettlementForm中，打印的第一页汇总情况，是否需要根据要求打印
收费者小计？

~~~~~~~~~
编目窗口能按照书目记录的id顺序翻页就好了。

~~~~~~~~~~
种次号窗有两个功能：
1) 一个是在相关库中检索出所有同类记录，然后列出种次号，便于推算当前最大号
2) 另外一个是在种子库中获得、增量号码

~~~~~~~~~~
结算窗中应当增加一个提示行，显示checkbox勾选事项的总计金额

~~~~~~~~~~~
现在C#脚本中的推动种次号的策略是考虑了同类书目统计结果的，这当然是最全面的做法。

但是也应提供“只用尾号”的策略范例脚本，供需要的图书馆选用。

~~~~~~~~~~~~
gcatclient的GetNumber()应当提供中断的能力。Stop应当可以中断那个Channel

~~~~~~~~~~~~
c#脚本中原有的加入种次号的函数
	void AddZhongcihao()
	{
		string strError = "";
		ZhongcihaoForm dlg = new ZhongcihaoForm();

		try 
		{
			string strClass = "";
			string strNumber = "";
			int nRet = 0;

			strClass = this.DetailForm.MarcEditor.Record.Fields.GetFirstSubfield("905", "d");

			if (strClass == "")
			{
				MessageBox.Show( this.DetailForm, "记录中不存在905$d子字段,因此无法加种次号");
				return;
			}
		
			string strExistNumber = this.DetailForm.MarcEditor.Record.Fields.GetFirstSubfield("905", "e");

			// dlg.MdiParent = this.DetailForm.MainForm;
			dlg.MainForm = this.DetailForm.MainForm;
			dlg.TopMost = true;
			dlg.MyselfBiblioRecPath = this.DetailForm.BiblioRecPath;

			dlg.ClassNumber = strClass;
			dlg.BiblioDbName = this.DetailForm.BiblioDbName;


			dlg.Show();


			// MessageBox.Show(this.DetailForm, "maxnumber="+dlg.MaxNumber);
			// MessageBox.Show(this.DetailForm, "tailnumber="+dlg.TailNumber);

			if (dlg.TailNumber == "" || dlg.TailNumber == null)	// 本类尚未创建种次号条目
			{
				string strMaxNumber = dlg.MaxNumber;


				// MessageBox.Show("maxnumber: '" + strMaxNumber + "'");
				if (strMaxNumber == "")
				{
					// 此类从来没有过记录，当前是第一条
					strNumber = InputDlg.GetInput(
						dlg,
						null,
						"请输入类 '" +strClass+ "' 的当前种次号最大号:",
						strExistNumber == "" ? "1" : strExistNumber);
					if (strNumber == null)
						return;	// 放弃整个操作

				}
				else 
				{
					strNumber = StringUtil.IncreaseNumber(strMaxNumber, 1);
				}

				dlg.TailNumber = strNumber;	// 这是统计出来的最大号。如果当前MARC记录不保存，这个号是不增量的

				// MessageBox.Show(this.DetailForm, "首次尾号写库" + strNumber);

			}
			else 
			{
				nRet = dlg.IncreaseTailNumber("1",
					out strNumber,
					out strError);
				if (nRet == -1)
					goto ERROR1;

				// MessageBox.Show(this.DetailForm, "得到尾号" + strNumber);
			}
		

			this.DetailForm.MarcEditor.Record.Fields.SetFirstSubfield("905", "e", strNumber);
			return;

		}
		catch (Exception ex)
		{
			strError = ex.Message;
			goto ERROR1;
		}
		finally
		{
			dlg.Close();
		}

		ERROR1:
			MessageBox.Show(this.DetailForm, strError);



	}
	
~~~~~~~~~
查重窗口



~~~~~~~~~
查重配置
<?xml version="1.0" encoding="utf-8"?>
<root>
    <project name="采购查重" comment="示例方案">
        <database name="测试书目库" threshold="60">
            <accessPoint name="著者" weight="50" searchStyle="" />
            <accessPoint name="题名" weight="70" searchStyle="" />
            <accessPoint name="索书类号" weight="10" searchStyle="" />
        </database>
        <database name="编目库" threshold="60">
            <accessPoint name="著者" weight="50" searchStyle="" />
            <accessPoint name="题名" weight="70" searchStyle="" />
            <accessPoint name="索书类号" weight="10" searchStyle="" />
        </database>
    </project>
    <project name="编目查重" comment="这是编目查重示例方案">
        <database name="中文图书" threshold="100">
            <accessPoint name="责任者" weight="50" searchStyle="" />
            <accessPoint name="ISBN" weight="80" searchStyle="" />
            <accessPoint name="题名" weight="20" searchStyle="" />
        </database>
        <database name="图书测试" threshold="100">
            <accessPoint name="责任者" weight="50" searchStyle="" />
            <accessPoint name="ISBN" weight="80" searchStyle="" />
            <accessPoint name="题名" weight="20" searchStyle="" />
        </database>
    </project>
    <default origin="中文图书" project="编目查重" />
    <default origin="图书测试" project="编目查重" />
</root>

查重可以一个库一个库的进行API?

~~~~~~~~~
查重功能还需要一个配套功能，列出projectname，可以通过参数指定
和一个库有关的方案名。

~~~~~~~
DupResultSet的Merge函数，当output middle为空的时候，会死循环。

DpResultSet的同名函数也应有同样问题。

~~~~~~~~~~
查重窗应当有一个按钮，可以看到发起查重的记录XML或者MARC

~~~~~~~~~~
服务器的查重API还是应当把发起记录包含在命中结果集中？
这样可以明白这条记录到底被打分多少。
而前端有足够的信息，可以把这条记录不显示出来。

~~~~~~~~~~~
服务器最后一环，对结果集中的元素按照权值进行排序。应当理解为
“和阈值的差额”，这样才公平，才能把超过阈值的排到前面。

排序也可以在前端进行？如果这样，可以为检索API增加一个特性参数，
表示最后是否需要排序。刚才上面说的结果集中是否包含发起记录，也可以作为
一个特性。

~~~~~~
查重窗口底部要提示，这次是否发生了重。

~~~~~~~
entityform的工具条在长操作时应disable

~~~~~~
查重窗事项的图标要重新绘制。可以用打勾和不打勾来表示。

~~~~~~
应该可以使用C#脚本来操纵查重窗口。为了循环获得后面的记录，可能需要
GetBiblioInfo() API提供next和prev的能力。这个能力对将来编写批处理转出
程序也很重要。


~~~~~~~~~~~~~~~~
期 库

keys:

<?xml version="1.0" encoding="utf-8"?>
<root>
    <key>
        <xpath>//parent</xpath>
        <from>parent</from>
        <table ref="parent" />
    </key>
    <table name="parent" id="1">
        <caption lang="zh-cn">父记录</caption>
        <caption lang="en">parent</caption>
    </table>
    <key>
        <xpath>//publishTime</xpath>
        <from>publishTime</from>
        <table ref="publishTime" />
    </key>
    <table name="publishTime" id="2">
        <caption lang="zh-cn">出版时间</caption>
        <caption lang="en">Publish time</caption>
    </table>
    <key>
        <xpath>//batchNo</xpath>
        <from>batchno</from>
        <table ref="batchno" />
    </key>
    <table name="batchno" id="3">
        <caption lang="zh-cn">批次号</caption>
        <caption lang="en">Batch No</caption>
    </table>
    <key>
        <xpath>//volume</xpath>
        <from>volume</from>
        <table ref="volume" />
    </key>
    <table name="volume" id="4">
        <caption lang="zh-cn">卷号</caption>
        <caption lang="en">Volume No</caption>
    </table>
    <!-- ******************配置非用字**************************************** -->
    <stopword>
        <stopwordTable name="title">
            <separator>
                <t>,</t>
                <t>_</t>
                <t>.</t>
                <t>:</t>
                <t>;</t>
                <t>!</t>
                <t>"</t>
                <t>'</t>
                <t>-</t>
                <t>，</t>
                <t>。</t>
                <t>‘</t>
                <t>’</t>
                <t>“</t>
                <t>”</t>
                <t>—</t>
            </separator>
            <word>
                <t>the</t>
                <t>a</t>
            </word>
        </stopwordTable>
    </stopword>
</root>

browse:

<?xml version="1.0" encoding="utf-8"?>
<root>
    <col title="出版日期">
        <xpath>//issue</xpath>
    </col>
    <col title="卷号">
        <xpath>//volume</xpath>
    </col>
</root>


~~~~~~~~~~~~~
1.0.0.86版

1) 新增册统计窗和书目统计窗

---

1.0.0.88版

2007/10/18

1) 书目检索窗可以使用__id途径进行记录索引号范围检索了。输入类似“1-10”这样的检索词。注意不支持逗号间隔的分段。这个功能需要最新版的dp2libraryws支持。

2) 书目检索窗新增导出“记录路径文件”功能。

3) 种册窗有一个错误：当利用“删除书目记录”按钮操作后，MARC编辑器和实体列表都会变为disabled状态，但当随后立即用“保存书目记录”按钮保存记录回数据库后，disabled状态不会变回enabled状态。这个错误已经改正。

4) 实体查询窗新增导出“记录路径文件”和“册条码号文件”功能。

5) 菜单“帮助/参数设置”所打开的“参数配置”对话框，增加了一个propertypage“检索”。里面有3个配置事项：书目检索窗最大命中条数、读者查询窗最大命中条数、实体查询窗最大命中条数，分别可以控制3种窗口的检索最大命中条数。

这些参数如果设置为-1，表示不限制。提供这些配置参数以前，原来3种窗口的缺省配置参数为1000,-1,-1。

~~~~~~~~~~~
IssueEditControl中“状态”，在library.xml中需要如下配置：
    <valueTables>
		<table name="issueState">部分到,全部到,预测</table>
    </valueTables>
    
    
~~~~~
采购信息有4个存储方案：

1) 设立一个专门的订购库，里面每条记录表示一个渠道的订购信息。

也就是说多条记录对应于一条书目记录。

这个方法的缺点，是服务器端的API复杂，和册、期一样，又要编写一套API。
前端也复杂。

每条订购记录，并不存在册记录条码唯一性这样的限制。

2) 设立一个“综合库”，不但存放采购信息，而且将来可以存放一些在MARC或者
DC里面不方便放的综合信息。综合库的一条记录对应于一条书目记录。

这个方法的优点，是一次创建，以后多次利用。

综合库也面临多个API操作同一条记录，需要拼装的问题。

3) 直接存放在书目记录中。和MARC、DC编目数据，用不同的根元素隔开。

这个方法的缺点，是不论书目信息单独更新还是采购信息更新，都会影响到唯一
的时间戳，有多余的冲突现象。

而且书目数据备份的时候要小心，不能用MARC格式了，只能用XML格式。否则会
丢失采购信息。

内核的书目库检索点需要改进：MARC的根不确定了，所以xpath要用//。

其他信息如果需要创建检索点，则要在key配置文件中体现。不过至少现在的采购信息是
不需要定义检索点的。

4) 和dt1000一样，把采购信息存储在MARC字段中。

这个方法也有两个子方法可以选择：一个是，在MARC字段中放XML代码；另外一个是，
利用MARC的子字段组结构。后者有字段结构翻译上的麻烦。

这个方法的缺点，是将来DC目录记录和现有MARC记录的处理办法不一致的问题。

~~~~~~~~~~
怎么能看到本机IE的版本？IE5的时候要警告。

~~~~~~~~~~
BinaryResControl是用来增删改、下载记录附带资源文件的一个控件。

1) 能首次装入各个<file>元素的相关信息
2) 能删除各行。删除一行代表删除一个<file>元素
3) 能增加新的行。不过新行一直要等到提交，才真正上载资源到服务器端。
提交动作需要和控件宿主的“保存/提交”按钮绑定。
4) 能下载某行代表的资源文件。如果是刚刚插入的尚未提交的行，则提示就在本地，不用下载。
5) 能修改已在服务器端的某行的资源文件。在提交动作的时候，上载覆盖服务器端的已有资源文件。

控件需要得知从XML记录中select得到的XmlNodeList，进行初始化。

控件能够提供Lines属性，供宿主插入XML记录中形成若干<file>元素。


~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		if (e.Operation != "borrow")
			return;

		string strResult = "";

		strResult += " 最高人民法院图书馆--借书单\r\n";

		strResult += "读者条码: " + e.ReaderBarcode + "\r\n";
		strResult += "姓名:     " + e.ReaderSummary + "\r\n";

		strResult += "打印时间: " + DateTime.Now.ToString() + "\r\n";

		strResult += "------------------------------\r\n";

	        // 将字符串规格化为固定行数的字符串
	        // parameters:
	        //      nLineMaxBytes   每行最大的西文字符数。这里假定每个中文字符的显示宽度为西文字符的2倍
	        string strFixSummary = FixLines(e.BiblioSummary,
			30,
			2);


		strResult += "书名:     " + strFixSummary + "\r\n";
		strResult += "书条码:   " + e.ItemBarcode + "\r\n";
		strResult += "应还日期: " + e.ReturnDate.ToString("yyyy-MM-dd") + "\r\n";
		strResult += "------------------------------\r\n";
		strResult += "------***请您当面核对***------\r\n";
		strResult += "------请读者按时归还图书------\r\n";
		strResult += "--普通书刊逾期费每本0.2元/天--\r\n";
		strResult += "---在应还期内，仅可续借一次---\r\n";

		MessageBox.Show(this.MainForm, strResult);
		
~~~~~~

%year%      当前年，4字符
%month%     当前月，1或2字符
%m2%        当前月，2字符
%day%       当前日，1或2字符
%d2%        当前日，2字符
%hour%      当前小时，1或2字符
%h2%        当前小时，2字符
%minute%    当前分，1或2字符
%min2%      当前分，2字符
%second%    当前秒，1或2字符
%sec2%      当前秒，2字符
%hsec%      当前百分秒
%msec%      当前毫秒



~~~~~~~~~~~~~~~~~~
下拉列表名

EntityEditControl

                if (combobox == this.comboBox_location)
                    e1.TableName = "location";
                else if (combobox == this.comboBox_state)
                    e1.TableName = "state";
                else if (combobox == this.comboBox_bookType)
                    e1.TableName = "bookType";
                else if (combobox == this.comboBox_seller)
                    e1.TableName = "bookSeller";
                else
                {
                    Debug.Assert(false, "不支持的sender");
                    return;
                }

OrderEditControl



                if (combobox == this.comboBox_state)
                    e1.TableName = "orderState";
                else if (combobox == this.comboBox_seller)
                    e1.TableName = "orderSeller";
                else
                {
                    Debug.Assert(false, "不支持的sender");
                }

IssueEditControl

                if (combobox == this.comboBox_state)
                    e1.TableName = "issueState";
                else
                {
                    Debug.Assert(false, "不支持的sender");
                    return;
                }


~~~~~~~~~~~~~~~~
日志装入命令

全文件装入:

20080103.log
20080104.log

也相当于:
20080103.log:*
20080104.log:*


~~~
装入特定的记录

20080103.log:100
20080103.log:101
20080104.log:200

将来可以支持
20080103:1-200这样的格式


因此listview需要增加文件名一列
还要增加点击标题条排序功能


~~~~~~~~~~~~~~~~~~~~~~~
对于完全新增的事项，可以在OK按钮后增补所缺的字段。

这个时候增补，可以兑现一些动态参数，比较有利。

但如果要在design界面预先看到这些字段，那就不能再在OK后动态。
例如，index编号，一定是根据插入行的先后来取值的，而不是后期的
先后顺序取值。若字段内容是宏，要根据行号来决定，就非常不利。

当然，规划前已经在listview中存在的事项，其字段值是保留已有值。

~~~~~~~~~~~~~~~~~~~~~
订购时间在OrderEditControl中(和listview item中)应该显示为本地时间。

否则不好人工修改。

另外最好提供辅助输入的
对话框。



~~~~~~~~~~
2010/11/4
MainForm的toolStripStatusLabel_main AutoSize = true Spring= true
这是正确德做法
如果AutoSize = false，则会出现Progress出不来的问题，要缩放几次窗口后，Progress才出来。


~~~~
        int GetCheckedOverdueInfos(ListView listview,
            out List<OverdueItemInfo> overdue_infos,
            out string strError)
        {
            strError = "";
            overdue_infos = new List<OverdueItemInfo>();
            int nCheckedCount = 0;

            // 目前两个listview的id列都还是8
            for (int i = 0; i < listview.Items.Count; i++)
            {
                ListViewItem item = listview.Items[i];
                if (item.Checked == false)
                    continue;

                /*
                string strID = listview.Items[i].SubItems[8].Text;
                string strPriceComment = listview.Items[i].SubItems[2].Text;
                 * */
                string strID = "";
                string strPriceComment = "";
                if (listview == this.listView_amerced)
                {
                    // strID = listview.Items[i].SubItems[8].Text;
                    // strPriceComment = listview.Items[i].SubItems[2].Text;
                    strID = ListViewUtil.GetItemText(item, COLUMN_AMERCED_ID);
                    strPriceComment = ListViewUtil.GetItemText(item, COLUMN_AMERCED_PRICE);
                }
                else
                {
                    Debug.Assert(listview == this.listView_overdues, "");
                    strID = ListViewUtil.GetItemText(item, COLUMN_AMERCING_ID);
                    strPriceComment = ListViewUtil.GetItemText(item, COLUMN_AMERCING_PRICE);
                }

                string strPrice = "";
                string strNewComment = "";
                ParsePriceCommentString(strPriceComment,
                    false,
                    out strPrice,
                    out strNewComment);

                // string strComment = listview.Items[i].SubItems[3].Text;

                if (String.IsNullOrEmpty(strID) == true)
                {
                    strError = "出现了id为空的行。";
                    return -1;
                }

                // 有星号的是变更金额
                if (strPrice.Length > 0 && strPrice[0] == '*')
                {
                    /*
                    strError = "出现了变更金额";
                    return -1;
                     * */
                    strPrice = strPrice.Substring(1);
                }

                OverdueItemInfo info = new OverdueItemInfo();
                info.Price = strPrice;
                info.ItemBarcode = ListViewUtil.GetItemText(item, 
                    COLUMN_AMERCING_ITEMBARCODE);
                info.RecPath = ""; // recPath
                info.Reason = ListViewUtil.GetItemText(item, 
                    COLUMN_AMERCING_REASON);
                /*
                info.Price = ListViewUtil.GetItemText(item, 
                    COLUMN_AMERCING_PRICE);
                 * */
                info.BorrowDate = ListViewUtil.GetItemText(item, 
                    COLUMN_AMERCING_BORROWDATE);
                info.BorrowPeriod = ListViewUtil.GetItemText(item, 
                    COLUMN_AMERCING_BORROWPERIOD);
                info.ReturnDate = ListViewUtil.GetItemText(item, 
                    COLUMN_AMERCING_RETURNDATE);
                info.BorrowOperator = ListViewUtil.GetItemText(item,
                    COLUMN_AMERCING_BORROWOPERATOR);  // borrowOperator
                info.ReturnOperator = ListViewUtil.GetItemText(item,
                    COLUMN_AMERCING_RETURNOPERATOR);    // operator
                info.ID = ListViewUtil.GetItemText(item,
                    COLUMN_AMERCING_ID);

                // 2008/11/15 new add
                info.Comment = ListViewUtil.GetItemText(item,
                    COLUMN_AMERCING_COMMENT);

                overdue_infos.Add(info);

                nCheckedCount++;
            }

            return nCheckedCount;
        }


				// 处理一条记录对应于一个<record>定义
		// container参数完全可能为null，这表示<record>为根元素
		// return:
		//		-1	出错
		//		0	正常返回
		int DoSingleItem(
			object objParam,
			XmlNode node,
			int nIndex,
			FilterItem container,
			string strData,
			string strNextName,
			out BreakType breakType,
			out string strError)
		{
			strError = "";
			breakType = BreakType.None;

			/*
			Debug.Assert(node != null, "node参数不能为null");

			HashFilterItem itemNode = (HashFilterItem)NodeTable[node];

			if (itemNode == null) 
			{
				Debug.Assert(false, "NodeTable中缺乏事项");
				return -1;
			}

			Debug.Assert(node == itemNode.xmlNode, "item成员xmlNode不正确");

			Type entryClassType = itemNode.FunctionType;

			if (entryClassType == null) 
			{
				Debug.Assert(false, itemNode.FunctionName + "没有预先填充Type");
				return -1;
			}

			// 把fltx.cs代码中的Batch层对象new，并保持
			// new一个Batch派生对象
			FilterItem itemHost = (FilterItem)entryClassType.InvokeMember(null, 
				BindingFlags.DeclaredOnly | 
				BindingFlags.Public | BindingFlags.NonPublic | 
				BindingFlags.Instance | BindingFlags.CreateInstance, null, null,
				null);
			*/
			// 创建一个新FilterItem对象
			FilterItem itemHost = NewFilterItem(
				objParam,
				node,
				out strError);
			if (itemHost == null)
				return -1;

			itemHost.Data = strData;
			itemHost.Index = nIndex;
			itemHost.Container = container;
			// itemHost.FilterRoot = container != null ? container : itemHost;
			itemHost.FilterRoot = GetRootFilterItem(itemHost);

			Debug.Assert(itemHost.FilterRoot != null, "itemHost.FilterRoot不应当==null");

			if (node.Name == "record") 
			{
				itemHost.Data = strData;
				itemHost.Name = "";
				itemHost.Content = strData;
			}
			else if (node.Name == "field")
			{
				itemHost.Data = strData;
				if (strData.Length < 3) 
				{
					strError = "字段全部数据长度不足3字符";
					goto ERROR1;
				}
				itemHost.Name = strData.Substring(0, 3);	// 这里要求调用本函数的，准备头标区这个特殊“字段”时，要加上'hdr'2字符在内容前面
				// control field  001-009没有子字段
				if (FilterItem.IsControlFieldName(itemHost.Name) == true)
				{
					itemHost.Indicator = "";
					itemHost.Content = strData.Substring(3);
				}
				else 
				{
                    if (strData.Length >= 5)
                    {
                        itemHost.Indicator = strData.Substring(3, 2);
                        itemHost.Content = strData.Substring(5);
                    }
                    else
                    {
                        // 2006/11/24
                        itemHost.Indicator = "";
                        itemHost.Content = "";
                    }

				}
			}
			else if (node.Name == "group") 
			{
				itemHost.Data = strData;
				itemHost.Name = "";
				itemHost.Content = strData;
			}
			else if (node.Name == "subfield")
			{
				itemHost.Data = strData;
				if (strData.Length < 1) 
				{
					strError = "子字段全部数据长度不足1字符";
					goto ERROR1;
				}
				itemHost.Name = strData.Substring(0, 1);
				itemHost.Content = strData.Substring(1);
			}

			itemHost.SetDupCount();
			itemHost.NextName = strNextName;
			if (itemHost.Container != null) 
			{
				itemHost.PrevName = itemHost.Container.LastChildName;	// 利用上次遗留的

				// 这一句有点多余。因为本函数返回后, 后面立即会做修改LastChildName的事情
				itemHost.Container.LastChildName = itemHost.Name;	// 保存这次的
			}

			itemHost.OnBegin();

			// 检查无意义的break设置情况
			if (CheckBreakException == true
				&& node.Name == "subfield"
				&& (itemHost.Break == BreakType.SkipCaseEnd
				|| itemHost.Break == BreakType.SkipCase) )
			{
				throw(new Exception("<subfield>元素内script代码中用Break = ???改变结构匹配流程无任何意义..."));
			}


			if (itemHost.Break == BreakType.SkipCaseEnd)
				goto SKIP1;	// 不做OnEnd()
			if (itemHost.Break == BreakType.SkipCase)
				goto SKIP;	// 不做OnBegin的兄弟case，但是要做OnEnd()


			int i;
			int nRet;
			XmlNode child = null;
			BreakType thisBreak = BreakType.None;

			// <record>希望下级是<field>
			if (node.Name == "record") 
			{
				// 切割记录为若干字段，匹配case
				for(int r=0;;r++) 
				{
					string strField;
					string strNextFieldName;

					// 从记录中得到一个字段
					// parameters:
					//		strMARC		MARC记录
					//		strFieldName	字段名。如果==null，表示任意字段
					//		nIndex		同名字段中的第几个。从0开始计算(0表示头标区)
					//		strField	[out]输出字段。包括字段名、必要的字段指示符、字段内容。不包含字段结束符。
					//					注意头标区当作一个字段返回，strField中不包含字段名，一上来就是头标区内容
					// return:
					//		-1	error
					//		0	not found
					//		1	found
					nRet = MarcDocument.GetField(strData,
						null,
						r,
						out strField,
						out strNextFieldName);
					if (nRet == -1)
					{
                        // 2009/11/1 new add
                        if (String.IsNullOrEmpty(strData) == true)
                            break;

                        strError = "DoSingleItem() GetField() error";
						return -1;
					}
					if (nRet == 0)
						break;

					if (strField.Length < 3)
						goto SKIP;


					string strFieldName = "";
					if (r != 0)
						strFieldName = strField.Substring(0,3);
					else 
					{
						strFieldName = "hdr";
						strField = strFieldName + strField;
					}
                    // ***
                    itemHost.IncChildDupCount(strFieldName);

					for(i=0;i<node.ChildNodes.Count;i++) 
					{
						child = node.ChildNodes[i];

						if (child.NodeType != XmlNodeType.Element)
							continue;

						if (child.Name != "field")
							continue;

						// 匹配字段名
						nRet = MatchName( strFieldName, DomUtil.GetAttr(child, "name"));
						if (nRet == 1) 
						{
							nRet = DoSingleItem(
								objParam,
								child,
								r,
								itemHost,
								strField,
								strNextFieldName,
								out thisBreak,
								out strError);
							if (nRet == -1)
								return -1;

							if (itemHost.Break != BreakType.None)
								break;
						}


					} // end of for

					itemHost.LastChildName = strFieldName;	// 保存这次的
					if (itemHost.Break != BreakType.None)
						goto SKIP;

				}

			}
			else if (node.Name == "field")
			{

				// 若下级为subfield
				string strFirstChildName = GetFirstChildElementType(node);
				// field下的subfield
				if (strFirstChildName == "subfield") 
				{
					// 切割记录为若干子字段，匹配case
					for(int s=0;;s++) 
					{
						string strSubfield;
						string strNextSubfieldName;

						// 从字段或组中得到一个子字段
						// parameters:
						//		strText		字段内容，或者子字段组内容。
						//		textType	表示strText中包含的是字段内容还是组内容。
						//		strSubfieldName	子字段名。如果==null，表示任意子字段
						//					形式为'a'这样的。
						//		nIndex			同名子字段中的第几个。从0开始计算。
						//		strSubfield		输出子字段。子字段名(1字符)、子字段内容。
						//		strNextSubfieldName	下一个子字段的名字，一个字符
						// return:
						//		-1	error
						//		0	not found
						//		1	found
						nRet = MarcDocument.GetSubfield(strData,
							ItemType.Field,
							null,
							s,
							out strSubfield,
							out strNextSubfieldName);
						if (nRet == -1)
						{
							strError = "GetSubfield() error";
							return -1;
						}
						if (nRet == 0)
							break;

						if (strSubfield.Length < 1)
							goto SKIP;

						string strSubfieldName = strSubfield.Substring(0,1);

                        // ***
                        itemHost.IncChildDupCount(strSubfieldName);

						for(i=0;i<node.ChildNodes.Count;i++) 
						{
							child = node.ChildNodes[i];

							if (child.NodeType != XmlNodeType.Element)
								continue;

							if (child.Name != "subfield")
								continue;

							// 匹配子字段名
							nRet = MatchName( strSubfieldName,  DomUtil.GetAttr(child, "name"));
							if (nRet == 1) 
							{
								nRet = DoSingleItem(
									objParam,
									child, 
									s,
									itemHost,
									strSubfield,
									strNextSubfieldName,
									out thisBreak,
									out strError);
								if (nRet == -1)
									return -1;
								if (itemHost.Break != BreakType.None)
									break;

							}

						} // end of for

						itemHost.LastChildName = strSubfieldName;	// 保存这次的
						if (itemHost.Break != BreakType.None)
							goto SKIP;

					}
				}
				// field下嵌套的field
				if (strFirstChildName == "field") 
				{
					// 切割字符串为若干字段，匹配case
					for(int r=0;;r++) 
					{
						string strField;
						string strNextFieldName;

						// 从记录中得到一个字段
						// parameters:
						//		strMARC		MARC记录
						//		strFieldName	字段名。如果==null，表示任意字段
						//		nIndex		同名字段中的第几个。从0开始计算(0表示头标区)
						//		strField	[out]输出字段。包括字段名、必要的字段指示符、字段内容。不包含字段结束符。
						//					注意头标区当作一个字段返回，strField中不包含字段名，一上来就是头标区内容
						// return:
						//		-1	error
						//		0	not found
						//		1	found
						nRet = MarcDocument.GetNestedField(strData,
							null,
							r,
							out strField,
							out strNextFieldName);
						if (nRet == -1)
						{
							strError = "GetNestedField() error";
							return -1;
						}
						if (nRet == 0)
							break;

						if (strField.Length < 3)
							goto SKIP;


						string strFieldName = "";
						strFieldName = strField.Substring(0,3);

                        // ***
                        itemHost.IncChildDupCount(strFieldName);

						// 嵌套字段不存在头标区'hdr'字段问题?

						for(i=0;i<node.ChildNodes.Count;i++) 
						{
							child = node.ChildNodes[i];

							if (child.NodeType != XmlNodeType.Element)
								continue;

							if (child.Name != "field")
								continue;

							// 匹配字段名
							nRet = MatchName( strFieldName, DomUtil.GetAttr(child, "name"));
							if (nRet == 1) 
							{
								nRet = DoSingleItem(
									objParam,
									child,
									r,
									itemHost,
									strField,
									strNextFieldName,
									out thisBreak,
									out strError);
								if (nRet == -1)
									return -1;
								if (itemHost.Break != BreakType.None)
									break;
							}


						} // end of for

						itemHost.LastChildName = strFieldName;	// 保存这次的
						if (itemHost.Break != BreakType.None)
							goto SKIP;

					}

				}

					// field 下的group
				else if (strFirstChildName == "group") 
				{
					// 切割记录为若干子字段，匹配case
					for(int g=0;;g++) 
					{
						string strGroup;

						// 从字段中得到子字段组
						// parameters:
						//		strGroup	[out]结果。
						// return:
						//		-1	error
						//		0	not found
						//		1	found
						nRet = MarcDocument.GetGroup(strData,
							g,
							out strGroup);
						if (nRet == -1)
						{
							strError = "GetGroup() error";
							return -1;
						}
						if (nRet == 0)
							break;

						string strGroupName = Convert.ToString(g);

                        // ***
                        itemHost.IncChildDupCount(strGroupName);

						for(i=0;i<node.ChildNodes.Count;i++) 
						{
							child = node.ChildNodes[i];

							if (child.NodeType != XmlNodeType.Element)
								continue;

							if (child.Name != "group")
								continue;

							// 匹配组名
							nRet = MatchName( strGroupName,  DomUtil.GetAttr(child, "name"));
							if (true/*nRet == 1*/) 
							{
								nRet = DoSingleItem(
									objParam,
									child,
									g,
									itemHost,
									strGroup, 
									"",
									out thisBreak,
									out strError);
								if (nRet == -1)
									return -1;
								if (itemHost.Break != BreakType.None)
									break;

							}

						} // end of for

						itemHost.LastChildName = "";	// 保存这次的
						if (itemHost.Break != BreakType.None)
							goto SKIP;

					}
				}

			}
			else if (node.Name == "group")
			{
				// 若下级为subfield
				string strFirstChildName = GetFirstChildElementType(node);
				if (strFirstChildName != "subfield") 
				{
					strError = ".fltx中<group>下级必须为<subfield>元素";
					return -1;
				}


				// 切割记录为若干子字段，匹配case
				for(int s=0;;s++) 
				{
					string strSubfield;
					string strNextSubfieldName;

					// 从字段或组中得到一个子字段
					// parameters:
					//		strText		字段内容，或者子字段组内容。
					//		textType	表示strText中包含的是字段内容还是组内容。
					//		strSubfieldName	子字段名。如果==null，表示任意子字段
					//					形式为'a'这样的。
					//		nIndex			同名子字段中的第几个。从0开始计算。
					//		strSubfield		输出子字段。子字段名(1字符)、子字段内容。
					//		strNextSubfieldName	下一个子字段的名字，一个字符
					// return:
					//		-1	error
					//		0	not found
					//		1	found
					nRet = MarcDocument.GetSubfield(strData,
						ItemType.Group,
						null,
						s,
						out strSubfield,
						out strNextSubfieldName);
					if (nRet == -1)
					{
						strError = "GetSubfield() error";
						return -1;
					}
					if (nRet == 0)
						break;

					if (strSubfield.Length < 1)
						goto SKIP;

					string strSubfieldName = strSubfield.Substring(0,1);
                    // ***
                    itemHost.IncChildDupCount(strSubfieldName);

					for(i=0;i<node.ChildNodes.Count;i++) 
					{
						child = node.ChildNodes[i];

						if (child.NodeType != XmlNodeType.Element)
							continue;

						if (child.Name != "subfield")
							continue;

						// 匹配子字段名
						nRet = MatchName( strSubfieldName,  DomUtil.GetAttr(child, "name"));
						if (nRet == 1) 
						{
							nRet = DoSingleItem(
								objParam,
								child,
								s,
								itemHost,
								strSubfield,
								strNextSubfieldName,
								out thisBreak,
								out strError);
							if (nRet == -1)
								return -1;
							if (itemHost.Break != BreakType.None)
								break;

						}

					} // end of for

					itemHost.LastChildName = strSubfieldName;	// 保存这次的
					if (itemHost.Break != BreakType.None)
						goto SKIP;


				}

			}			
			else if (node.Name == "subfield")
			{
				// 暂时没有什么处理

			}

			SKIP:

				if (itemHost.Break != BreakType.SkipCaseEnd) 
				{
					itemHost.OnEnd();
				}

           
			SKIP1:

				/*
				if (itemHost.Break != BreakType.None)
					return 1;
				*/

				breakType = itemHost.Break;

			return 0;

			ERROR1:
				return -1;
		}

		        public List<ItemInfo> ItemInfos
        {
            get
            {
                // 优化速度
                if (this.m_itemInfos != null)
                    return this.m_itemInfos;

                // 如果当前书目库下没有包含实体库，调用会抛出异常。特殊处理
                // TODO: 是否需要用hashtable优化速度?
                string strBiblioDBName = Global.GetDbName(this.CurrentRecPath);
                string strItemDbName = this.BiblioStatisForm.MainForm.GetItemDbName(strBiblioDBName);
                if (String.IsNullOrEmpty(strItemDbName) == true)
                    return new List<ItemInfo>();    // 返回一个空的数组

                this.m_itemInfos = new List<ItemInfo>();

                long lPerCount = 100; // 每批获得多少个
                long lStart = 0;
                long lResultCount = 0;
                long lCount = -1;
                for (; ; )
                {

                    string strStyle = "";
                    if (this.HowToGetItemRecord == "delay")
                        strStyle = "onlygetpath";
                    else if (this.HowToGetItemRecord == "first")
                        strStyle = "onlygetpath,getfirstxml";

                    EntityInfo[] infos = null;
                    string strError = "";
                    long lRet = this.BiblioStatisForm.Channel.GetEntities(
                        null,
                        this.CurrentRecPath,
                        lStart,
                        lCount,
                        strStyle,
                        "zh",
                        out infos,
                        out strError);
                    if (lRet == -1)
                        throw new Exception(strError);

                    lResultCount = lRet;    // 2009/11/23 new add

                    if (infos == null)
                        return this.m_itemInfos;

                    for (int i = 0; i < infos.Length; i++)
                    {
                        EntityInfo info = infos[i];
                        string strXml = info.OldRecord;

                        /*
                        if (String.IsNullOrEmpty(strXml) == true)
                            continue;
                         * */

                        ItemInfo item_info = new ItemInfo("item");
                        item_info.Container = this;
                        item_info.RecPath = info.OldRecPath;
                        item_info.Timestamp = info.OldTimestamp;
                        item_info.OldRecord = strXml;

                        this.m_itemInfos.Add(item_info);
                    }

                    lStart += infos.Length;
                    if (lStart >= lResultCount)
                        break;

                    if (lCount == -1)
                        lCount = lPerCount;

                    if (lStart + lCount > lResultCount)
                        lCount = lResultCount - lStart;

                } // end of for

                return this.m_itemInfos;
            }
        }


		/////////////
		            for (int i = 0; i < nodes.Count; i++)
            {
                /*
                XmlNode node = nodes[i];

                OrderBindingItem order = new OrderBindingItem();
                nRet = order.Initial(node.OuterXml, out strError);
                if (nRet == -1)
                    return -1;

                this.OrderItems.Add(order);
                 * */



        // 初始化。一次性初始化，不再需要其他函数
        // parameters:
        //      strLayoutMode   "auto" "accepting" "binding"。auto为自动模式，accepting为全部行为记到，binding为全部行为装订
        // return:
        //      -1  出错
        //      0   成功
        //      1   成功，但有警告。警告信息在strError中
        public int NewInitial(
            string strLayoutMode,
            List<string> ItemXmls,
            List<string> IssueXmls,
            out string strError)
        {
            strError = "";
            string strWarning = "";
            int nRet = 0;

            if (strLayoutMode == "auto"
                || strLayoutMode == "acception"
                || strLayoutMode == "binding")
            {
                this.WholeLayout = strLayoutMode;
            }
            else
            {
                strError = "未知的布局模式 '"+strLayoutMode+"'";
                return -1;
            }

            // 首次设置状态。一般情况为隐藏编辑控件
            if (this.CellFocusChanged != null)
            {
                FocusChangedEventArgs e = new FocusChangedEventArgs();
                this.CellFocusChanged(this, e);
            }

            Hashtable placed_table = new Hashtable();   // 已经被作为合订本下属安放过位置的册对象

            // 把所有期对象的Cells数组清空
            this.FreeIssue = null;
            for (int i = 0; i < this.Issues.Count; i++)
            {
                IssueBindingItem issue = this.Issues[i];
                issue.Cells.Clear();

                if (String.IsNullOrEmpty(issue.PublishTime) == true)
                    this.FreeIssue = issue;
            }

            // 如果没有，则创建自由期
            if (this.FreeIssue == null)
            {
                this.FreeIssue = new IssueBindingItem();
                this.FreeIssue.Container = this;
                this.Issues.Add(this.FreeIssue);
            }

            // 创建this.InitalItems
            nRet = CreateInitialItems(ItemXmls,
                out strError);
            if (nRet == -1)
                return -1;


            // 创建this.Issues
            nRet = CreateIssues(IssueXmls,
                out strError);
            if (nRet == -1)
                return -1;

            // 创建this.ParentItems
            nRet = CreateParentItems(out strError);
            if (nRet == -1)
                return -1;

            // 剩下的就是无归属的单册了

            // 处理没有期归属的单册对象，将它们归属到适当的Issue对象的Items成员中
            // 由于virtual issues这时已经创建了，后面才创建合订册，因此初始化合订纵向范围不会(?)出现断裂
            // 注：这里显然没有考虑bindingxml中可能会出现的virtual出版日期。那时有可能会出现断裂
            for (int i = 0; i < this.InitialItems.Count; i++)
            {
                ItemBindingItem item = this.InitialItems[i];
                Debug.Assert(item != null, "");
                Debug.Assert(item.Container == null, "");


                IssueBindingItem issue = this.FindIssue(item.PublishTime);
                if (issue != null)
                {
                    // 注：这里如果publishtime为空的，正好加入到自由期
                    issue.Items.Add(item);
                    item.Container = issue;
                }
                else
                {
                    Debug.Assert(String.IsNullOrEmpty(item.PublishTime) == false, "");

                    issue = this.NewIssue(item.PublishTime,
                        item.Volume);
                    Debug.Assert(issue != null, "");
                    issue.Virtual = true;
                    issue.Items.Add(item);
                    item.Container = issue;
                }
            }
            this.InitialItems.Clear();

            List<PublishTimeAndVolume> publishtimes = new List<PublishTimeAndVolume>();
            // 统计(bindingxml中)全部合订成员册所使用过的publishtime字符串
            nRet = GetAllBindingXmlPublishTimes(
            out publishtimes,
            out strError);
            if (nRet == -1)
                return -1;
            for (int i = 0; i < publishtimes.Count; i++)
            {
                PublishTimeAndVolume item = publishtimes[i];
                string strPublishTime = item.PublishTime;
                Debug.Assert(String.IsNullOrEmpty(strPublishTime) == false);

                IssueBindingItem issue = this.FindIssue(strPublishTime);
                if (issue == null)
                {
                    issue = this.NewIssue(strPublishTime,
                        item.Volume);
                    Debug.Assert(issue != null, "");
                    issue.Virtual = true;
                }
            }

            /*
            // 调试
            while (this.ParentItems.Count > 3)
                this.ParentItems.RemoveAt(3);
             * */

            // 遍历合订册对象数组
            for (int i = 0; i < this.ParentItems.Count; i++)
            {
                ItemBindingItem parent_item = this.ParentItems[i];
                List<ItemBindingItem> member_items = new List<ItemBindingItem>();

                string strBindingXml = parent_item.Binding;
                if (String.IsNullOrEmpty(strBindingXml) == true)
                {
                    string strVolume = parent_item.Volume;

                    if (String.IsNullOrEmpty(strVolume) == true)
                    {
                        // 如果没有BindingXml，并且没有卷期范围，则被移动到自由区域
                        this.ParentItems.Remove(parent_item);
                        Cell temp = new Cell();
                        temp.item = parent_item;
                        AddToFreeIssue(temp);
                        i--;
                        continue;
                    }

                    List<VolumeInfo> infos = null;
                    nRet = VolumeInfo.BuildVolumeInfos(strVolume,
                        out infos,
                        out strError);
                    if (nRet == -1)
                    {
                        parent_item.Comment += "\r\n解析卷期字符串的时候发生错误: " + strError;
                        this.ParentItems.Remove(parent_item);
                        Cell temp = new Cell();
                        temp.item = parent_item;
                        AddToFreeIssue(temp);
                        i--;
                        continue;
                    }

                    bool bFailed = false;
                    string strFailMessage = "";
                    for (int j = 0; j < infos.Count;j++ )
                    {
                        VolumeInfo info = infos[j];

                        ItemBindingItem sub_item = null;

                        // TODO: 可以征用refid为*的订购信息内的对象

                        // 通过卷期信息寻找合适的可以依附的期对象
                        List<IssueBindingItem> issues = null;
                        // 用卷期信息搜寻期对象
                        nRet = SearchIssue(
                            info,
                            out issues,
                            out strError);
                        if (nRet == -1)
                            return -1;

                        if (issues == null || issues.Count == 0)
                        {
                            // 搜寻失败，
                            // TODO: 也许可以指出出错原因?
                            strFailMessage = "期号(年:"+info.Year+") '"+info.IssueNo+"' 没有找到期对象";
                            bFailed = true;
                            break;
                        }

                        string strPublishTime = issues[0].PublishTime;
                        Debug.Assert(String.IsNullOrEmpty(strPublishTime) == false, "");

                        if (sub_item == null)
                        {
                            // 如果没有现成的item对象，则通过<item>元素的相关属性来创建
                            sub_item = new ItemBindingItem();
                            nRet = sub_item.Initial("<root />", out strError);
                            Debug.Assert(nRet != -1, "");

                            sub_item.Volume = info.GetString();
                            sub_item.PublishTime = strPublishTime;
                            sub_item.RefID = "*";   // 象征性的，或可吸纳升级上来的订购绑定数据
                        }

                        sub_item.ParentItem = parent_item;
                            sub_item.Deleted = true;
                            sub_item.State = "已删除";
                        member_items.Add(sub_item);
                    }

                    if (bFailed == true)
                    {
                        parent_item.Comment += "\r\n卷期字符串中的部分期不存在，无法复原合订状态: " + strFailMessage;
                        this.ParentItems.Remove(parent_item);
                        Cell temp = new Cell();
                        temp.item = parent_item;
                        AddToFreeIssue(temp);
                        i--;
                        continue;
                    }

                    goto PLACEMEMT;
                }

                // 根据refid, 找到它下属的那些ItemBindingItem对象
                XmlDocument dom = new XmlDocument();
                dom.LoadXml("<root />");
                try
                {
                    dom.DocumentElement.InnerXml = strBindingXml;
                }
                catch (Exception ex)
                {
                    strError = "参考ID为 '" + parent_item.RefID + "' 的册信息中，<binding>元素内嵌XML装入DOM时出错: " + ex.Message;
                    return -1;
                }

                /*
                 * bindingxml中，<item>元素未必有refID属性。
                 * 没有refID属性，表明这是一个被删除了册记录的单纯信息单元，或者是缺期情况。
                 * 缺期可能发生在装订范围的第一册或者最后一册，要引起注意
                 * */

                parent_item.MemberCells.Clear();
                XmlNodeList nodes = dom.DocumentElement.SelectNodes("item");
                if (nodes.Count == 0)
                {
                    // 虽然有BindingXml，但没有任何下级<item>元素，则被移动到自由区域
                    this.ParentItems.Remove(parent_item);
                    Cell temp = new Cell();
                    temp.item = parent_item;
                    AddToFreeIssue(temp);
                    i--;
                    continue;
                }

                for (int j = 0; j < nodes.Count; j++)
                {
                    XmlNode node = nodes[j];
                    string strRefID = DomUtil.GetAttr(node, "refID");

                    bool bItemRecordDeleted = false;    // 册记录是否被删除?

                    if (String.IsNullOrEmpty(strRefID) == true)
                    {
                        bItemRecordDeleted = true;
                    }

                    ItemBindingItem sub_item = null;

                    if (bItemRecordDeleted == false)
                    {
                        sub_item = InitialFindItemByRefID(strRefID);
                        if (sub_item == null)
                        {
                            if (String.IsNullOrEmpty(strWarning) == false)
                                strWarning += "; ";
                            // strWarning += "参考ID为 '" + parent_item.RefID + "' 的册信息中，<binding>元素内包含的参考ID '" + strRefID + "' 没有找到对应的册信息";
                            bItemRecordDeleted = true;
                        }
                    }

                    if (sub_item == null)
                    {
                        // 如果没有现成的item对象，则通过<item>元素的相关属性来创建
                        sub_item = new ItemBindingItem();
                        nRet = sub_item.Initial("<root />", out strError);
                        Debug.Assert(nRet != -1, "");

                        // TODO: 可以把node中所有的属性都翻译为item中的同名元素，这样就允许保存的地方随意扩充字段了
                        sub_item.Volume = DomUtil.GetAttr(node, "volume");
                        sub_item.PublishTime = DomUtil.GetAttr(node, "publishTime");
                        sub_item.RefID = DomUtil.GetAttr(node, "refID");
                        sub_item.Barcode = DomUtil.GetAttr(node, "barcode");
                        sub_item.RegisterNo = DomUtil.GetAttr(node, "registerNo");

                        // 2011/9/8
                        sub_item.Price = DomUtil.GetAttr(node, "price");

                        bool bMissing = false;
                        // 获得布尔型的属性参数值
                        // return:
                        //      -1  出错。但是nValue中已经有了nDefaultValue值，可以不加警告而直接使用
                        //      0   正常获得明确定义的参数值
                        //      1   参数没有定义，因此代替以缺省参数值返回
                        DomUtil.GetBooleanParam(node,
                            "missing",
                            false,
                            out bMissing,
                            out strError);
                        sub_item.Missing = bMissing;

                        if (String.IsNullOrEmpty(sub_item.PublishTime) == true)
                        {
                            // 没有publishtime，也无法安放
                        }
                    }

                    // sub_item.Binded = true; // 注：place阶段会设置的
                    sub_item.ParentItem = parent_item;
                    if (sub_item.Missing == false
                        && bItemRecordDeleted == true)
                    {
                        sub_item.Deleted = bItemRecordDeleted;
                        sub_item.State = "已删除";
                    }

                    member_items.Add(sub_item);

                    // 使用后自然会被丢弃
                }

            PLACEMEMT:

                // 布局
                if (member_items.Count > 0)
                {
                    // 把合订册的ItemBindingItem对象安放在其下属的第一个册对象所在的期行内
                    ItemBindingItem first_sub = member_items[0];
                    IssueBindingItem first_issue = first_sub.Container;

                    if (first_issue == null)
                    {
                        // Debug.Assert(first_sub.Missing == true, "");

                        if (String.IsNullOrEmpty(first_sub.PublishTime) == true)
                        {
                            // 成员册没有publishtime无法安放
                            // 这就导致parent被移动到自由区
                            this.ParentItems.Remove(parent_item);
                            Cell temp = new Cell();
                            temp.item = parent_item;
                            temp.item.Comment += "\r\n合订册的第一个成员册没有出版时间信息，因此合订册也无法正常安放，只好放在自由期中";
                            AddToFreeIssue(temp);
                            i--;
                            continue;
                        }

                        Debug.Assert(String.IsNullOrEmpty(first_sub.PublishTime) == false, "");

                        first_issue = this.FindIssue(first_sub.PublishTime);
                        if (first_issue == null)
                        {
                            first_issue = this.NewIssue(first_sub.PublishTime,
                                first_sub.Volume);
                        }
                    }

                    Debug.Assert(first_issue != null, "");

                    // 安放在两个一组的靠左位置。偶数
                    int col = -1;
                    col = first_issue.GetFirstAvailableBoundColumn();

                    // 安放合订本对象
                    Cell parent_cell = new Cell();
                    parent_cell.item = parent_item;
                    parent_item.Container = first_issue; // 假装属于这个期
                    first_issue.SetCell(col, parent_cell);

                    // 安放下属的单独册
                    try
                    {
                        PlaceMemberItems(parent_cell,
                            member_items,
                            col + 1);
                    }
                    catch (Exception ex)
                    {
                        strError = ex.Message;
                        return -1;
                    }

                    /* // this.Changed最后会被改变，就没有了修改记号，不好。还是用菜单命令实现，操作人员需要去调用
                    if (String.IsNullOrEmpty(parent_item.PublishTime) == true)
                    {
                        if (parent_item.RefreshPublishTime() == true)
                            parent_item.Changed = true;
                    }
                     * */

                    // 记忆
                    foreach (ItemBindingItem temp in member_items)
                    {
                        placed_table[temp] = temp;
                    }

                    /*
                    // 稍后才安放合订本对象
                    Cell cell = new Cell();
                    cell.item = parent_item;
                    parent_item.Container = first_issue; // 假装属于这个期
                    first_issue.SetCell(col, cell);
                     * */

#if DEBUG
                    {
                        string strError1 = "";
                        int nRet1 = parent_item.VerifyMemberCells(out strError1);
                        if (nRet1 == -1)
                        {
                            Debug.Assert(false, strError1);
                        }
                    }
#endif
                }
            }

            // 安放其余册对象。即非合订成员册
            for (int i = 0; i < this.Issues.Count; i++)
            {
                // 先存储再排序
                List<ItemBindingItem> items = new List<ItemBindingItem>();

                IssueBindingItem issue = this.Issues[i];
                for (int j = 0; j < issue.Items.Count; j++)
                {
                    ItemBindingItem item = issue.Items[j];

                    if (placed_table[item] != null)
                        continue;

                    items.Add(item);
                }
                issue.Items.Clear();    // 初始化使命完成以后立即清除

                if (items.Count > 0)
                {
                    if (String.IsNullOrEmpty(issue.PublishTime) == false)
                    {
                        // 按照Intact排序
                        items.Sort(new ItemIntactComparer());
                    }

                    for (int j = 0; j < items.Count; j++)
                    {
                        ItemBindingItem item = items[j];
                        // 安放在两个一组的右边位置
                        PlaceSingleToTail(item);
                    }
                }

                if (String.IsNullOrEmpty(issue.PublishTime) == false)
                {
                    // 首次设置每个格子的OutputIssue值
                    issue.RefreshAllOutofIssueValue();
                }
            }

            // 把Cell中Missing状态的Item全部设置为null
            for (int i = 0; i < this.Issues.Count; i++)
            {
                IssueBindingItem issue = this.Issues[i];
                for (int j = 0; j < issue.Cells.Count; j++)
                {
                    Cell cell = issue.Cells[j];
                    if (cell != null && cell.item != null)
                    {
                        if (cell.item.Missing == true)
                            cell.item = null;
                    }
                }
            }

            // 把超过管辖范围的合订册单元去掉
            if (this.HideLockedBindingCell == true
                && Global.IsGlobalUser(this.LibraryCodeList) == false)
            {
                for (int i = 0; i < this.ParentItems.Count; i++)
                {
                    ItemBindingItem parent_item = this.ParentItems[i];

                    // 检查一个合订册的所有成员,看看是不是(至少一个)和当前可见订购组有从属关系?
                    // return:
                    //      -1  出错
                    //      0   没有交叉
                    //      1   有交叉
                    nRet = IsMemberCrossOrderGroup(parent_item,
                        out strError);
                    if (nRet == -1)
                        return -1;

                    string strLibraryCode = Global.GetLibraryCode(parent_item.LocationString);
                    // 合订本本身馆代码在外，而且其成员也不和可见订购组交叉的，删除合订本对象
                    if (StringUtil.IsInList(strLibraryCode, this.LibraryCodeList) == false
                        && nRet == 0)
                    {
                        this.RemoveItem(parent_item, true);
                        this.ParentItems.RemoveAt(i);
                        i--;
                    }
                }

                // 把自由期中的超过范围的单元去掉
                if (this.FreeIssue != null)
                {
                    foreach (Cell cell in this.FreeIssue.Cells)
                    {
                        if (cell == null || cell.item == null)
                            continue;
                        string strLibraryCode = Global.GetLibraryCode(cell.item.LocationString);
                        if (StringUtil.IsInList(strLibraryCode, this.LibraryCodeList) == false)
                        {
                            this.FreeIssue.Cells.Remove(cell);
                        }
                    }
                }
            // TODO: 需要重新placement
            }


            // 设置记到布局模式

            if (strLayoutMode == "auto")
            {
                for (int i = 0; i < this.Issues.Count; i++)
                {
                    IssueBindingItem issue = this.Issues[i];
                    // 跳过自由期
                    if (String.IsNullOrEmpty(issue.PublishTime) == true)
                        continue;
                    if (issue.HasMemberOrParentCell() == true)
                    {
                        issue.IssueLayoutState = IssueLayoutState.Binding;
                        nRet = issue.InitialLayoutBinding(out strError);
                        if (nRet == -1)
                            return -1;
                    }
                    else
                    {
                        issue.IssueLayoutState = IssueLayoutState.Accepting;
                        nRet = issue.LayoutAccepting(out strError);
                        if (nRet == -1)
                            return -1;
                    }
                }
            }
            else if (strLayoutMode == "accepting")
            {
                for (int i = 0; i < this.Issues.Count; i++)
                {
                    IssueBindingItem issue = this.Issues[i];
                    // 跳过自由期
                    if (String.IsNullOrEmpty(issue.PublishTime) == true)
                        continue;
                    {
                        issue.IssueLayoutState = IssueLayoutState.Accepting;
                        nRet = issue.LayoutAccepting(out strError);
                        if (nRet == -1)
                            return -1;
                    }
                }
            }
            else
            {
                Debug.Assert(strLayoutMode == "binding", "");
                // 本来就是全部行已经为装订模式
                for (int i = 0; i < this.Issues.Count; i++)
                {
                    IssueBindingItem issue = this.Issues[i];
                    // 跳过自由期
                    if (String.IsNullOrEmpty(issue.PublishTime) == true)
                        continue;
                    {
                        issue.IssueLayoutState = IssueLayoutState.Binding;
                        nRet = issue.InitialLayoutBinding(out strError);
                        if (nRet == -1)
                            return -1;
                    }
                }
            }

#if DEBUG
            this.VerifyAll();
#endif


            AfterWidthChanged(true);
            // Debug.WriteLine("NewInitial() AfterWidthChanged() done");

            if (String.IsNullOrEmpty(strWarning) == false)
            {
                strError = strWarning;
                return 1;
            }

            return 0;
        }

		///////
		        // 检查一个合订册的所有成员,看看是不是(至少一个)和当前可见订购组有从属关系?
        // return:
        //      -1  出错
        //      0   没有交叉
        //      1   有交叉
        int IsMemberCrossOrderGroup(ItemBindingItem parent_item,
            out string strError)
        {
            strError = "";

            foreach (Cell cell in parent_item.MemberCells)
            {
                if (cell == null || cell.item == null)
                    continue;

                IssueBindingItem issue = cell.Container;
                if (issue == null)
                    continue;

                int nRet = issue.InitialOrderItems(out strError);
                if (nRet == -1)
                    return -1;



                List<string> refids = null;
                // 获得可见的订购组中的refid
                nRet = issue.GetVisibleRefIDs(
                    this.LibraryCodeList,
                    out refids,
                    out strError);
                if (nRet == -1)
                    return -1;

                if (refids.IndexOf(cell.item.RefID) != -1)
                    return 1;
            }

            return 0;
        }


		/////////////


		        // 装载日志记录
        private void button_loadLogRecords_Click(object sender, EventArgs e)
        {
            string strError = "";
            int nRet = 0;

            this.tabControl_main.SelectedTab = this.tabPage_logRecords;

            EnableControls(false);

            stop.OnStop += new StopEventHandler(this.DoStop);
            stop.Initial("正在初始化浏览器组件 ...");
            stop.BeginLoop();


            this.Update();
            this.MainForm.Update();

#if NO
            this.listView_records.Items.Clear();
            // 2008/11/22 new add
            this.SortColumns.Clear();
            SortColumns.ClearColumnSortDisplay(this.listView_records.Columns);


            this.ClearAllTempFiles();

            Global.ClearHtmlPage(this.webBrowser_xml,
                this.MainForm.DataDir);
            Global.ClearHtmlPage(this.webBrowser_html,
                this.MainForm.DataDir);
#endif
            this.Clear();

            try
            {
                long lTotalSize = 0;
                List<string> lines = new List<string>();
                for (int i = 0; i < this.textBox_filenames.Lines.Length; i++)
                {
                    Application.DoEvents();

                    if (stop != null)
                    {
                        if (stop.State != 0)
                            return;
                    }

                    string strLine = this.textBox_filenames.Lines[i];
                    if (String.IsNullOrEmpty(strLine) == true)
                        continue;
                    // 去掉注释
                    nRet = strLine.IndexOf("#");
                    if (nRet != -1)
                        strLine = strLine.Substring(0, nRet).Trim();

                    if (String.IsNullOrEmpty(strLine) == true)
                        continue;

                    string strLogFilename = "";
                    string strRange = "";

                    nRet = strLine.IndexOf(":");
                    if (nRet != -1)
                    {
                        strLogFilename = strLine.Substring(0, nRet).Trim();
                        strRange = strLine.Substring(nRet + 1).Trim();
                    }
                    else
                    {
                        strLogFilename = strLine.Trim();
                        strRange = "";
                    }

                    long lTemp = 0;
                    // 获得一个日志文件的尺寸
                    // return:
                    //      -1  error
                    //      0   file not found
                    //      1   found
                    nRet = GetFileSize(strLogFilename,
            out lTemp,
            out strError);
                    if (nRet == -1)
                        goto ERROR1;
                    if (nRet == 0)
                        continue;

                    Debug.Assert(lTemp >= 0, "");

                    lTotalSize += lTemp;

                    lines.Add(strLine);
                }

                if (stop != null)
                    stop.SetProgressRange(0, lTotalSize);

                this.estimate.SetRange(0, lTotalSize);
                this.estimate.Start();

                long lDoneSize = 0;
                for (int i = 0; i < lines.Count; i++)
                {
                    Application.DoEvents();

                    if (stop != null)
                    {
                        if (stop.State != 0)
                            return;
                    }

                    string strLine = lines[i];
#if NO
                    if (String.IsNullOrEmpty(strLine) == true)
                        continue;
                    // 去掉注释
                    nRet = strLine.IndexOf("#");
                    if (nRet != -1)
                        strLine = strLine.Substring(0, nRet).Trim();

                    if (String.IsNullOrEmpty(strLine) == true)
                        continue;
#endif

                    string strLogFilename = "";
                    string strRange = "";

                    nRet = strLine.IndexOf(":");
                    if (nRet != -1)
                    {
                        strLogFilename = strLine.Substring(0, nRet).Trim();
                        strRange = strLine.Substring(nRet + 1).Trim();
                    }
                    else
                    {
                        strLogFilename = strLine.Trim();
                        strRange = "";
                    }

                    //      -1  error
                    //      0   file not found
                    //      1   found
                    nRet = LoadSomeRecords(strLogFilename,
                        strRange,
                        ref lDoneSize,
                        ref lTotalSize,
                        out strError);
                    if (nRet == -1)
                    {
                        if (stop != null)
                        {
                            if (stop.State != 0)
                                return;
                        }
                        // MessageBox.Show(this, strError);
                        DialogResult result = MessageBox.Show(this,
strError + "\r\n\r\n是否继续处理?",
"OperLogForm",
MessageBoxButtons.YesNo,
MessageBoxIcon.Question,
MessageBoxDefaultButton.Button1);
                        if (result == DialogResult.No)
                            return;
                    }
                }
            }
            finally
            {
                stop.EndLoop();
                stop.OnStop -= new StopEventHandler(this.DoStop);
                stop.Initial("");
                stop.HideProgress();

                EnableControls(true);
            }

            this.MainForm.StatusBarMessage = "总共耗费时间: " + this.estimate.GetTotalTime().ToString();
            return;
        ERROR1:
            MessageBox.Show(this, strError);
            return;
        }

        // 获得一个日志文件的尺寸
        // return:
        //      -1  error
        //      0   file not found
        //      1   found
        int GetFileSize(string strLogFileName,
            out long lTotalSize,
            out string strError)
        {
            strError = "";
            lTotalSize = 0;

            stop.SetMessage("正获得日志文件 " + strLogFileName + " 的尺寸...");

            string strXml = "";
            long lAttachmentTotalLength = 0;
            byte[] attachment_data = null;

            // 获得日志文件尺寸
            // return:
            //      -1  error
            //      0   file not found
            //      1   succeed
            //      2   超过范围
            long lRet = Channel.GetOperLog(
                stop,
                strLogFileName,
                -1,    // lIndex,
                -1, // lHint,
                out strXml,
                out lTotalSize,
                0,  // lAttachmentFragmentStart,
                0,  // nAttachmentFramengLength,
                out attachment_data,
                out lAttachmentTotalLength,
                out strError);
            if (lRet == 0)
            {
                lTotalSize = 0;
                Debug.Assert(lTotalSize == 0, "");
                return 0;
            }
            if (lRet != 1)
                return -1;
            Debug.Assert(lTotalSize >= 0, "");

            return 1;
        }

        // 装入一个日志文件中的若干记录
        // return:
        //      -1  error
        //      0   file not found
        //      1   found
        int LoadSomeRecords(string strLogFileName,
            string strRange,
            ref long lProgressValue,
            ref long lSize,
            out string strError)
        {
            strError = "";

            stop.SetMessage("正在装入日志文件 " + strLogFileName + " 中的记录。"
                + "剩余时间 " + ProgressEstimate.Format(this.estimate.Estimate(lProgressValue)) + " 已经过时间 " + ProgressEstimate.Format(this.estimate.delta_passed));

            string strXml = "";
            long lAttachmentTotalLength = 0;
            byte[] attachment_data = null;

            long lFileSize = 0;

            // 获得日志文件尺寸
            long lRet = Channel.GetOperLog(
                stop,
                strLogFileName,
                -1,    // lIndex,
                -1, // lHint,
                out strXml,
                out lFileSize,
                0,  // lAttachmentFragmentStart,
                0,  // nAttachmentFramengLength,
                out attachment_data,
                out lAttachmentTotalLength,
                out strError);
            // 2010/12/13
            if (lRet == 0)
                return 0;

            // stop.SetProgressRange(0, lTotalSize);

            if (String.IsNullOrEmpty(strRange) == true)
                strRange = "0-9999999999";

            RangeList rl = new RangeList(strRange);

#if DELAY_UPDATE
            this.listView_records.BeginUpdate();
#endif
            try
            {
                for (int i = 0; i < rl.Count; i++)
                {
                    RangeItem ri = (RangeItem)rl[i];

                    long lHint = -1;
                    long lHintNext = -1;
                    for (long lIndex = ri.lStart; lIndex < ri.lStart + ri.lLength; lIndex++)
                    {
                        Application.DoEvents();

                        if (stop != null)
                        {
                            if (stop.State != 0)
                            {
                                strError = "用户中断1";
                                goto ERROR1;
                            }
                        }

                        lHint = lHintNext;

                        // 获得日志
                        // result.Value
                        //      -1  error
                        //      0   file not found
                        //      1   succeed
                        //      2   超过范围
                        lRet = Channel.GetOperLog(
                            stop,
                            strLogFileName,
                            lIndex,
                            lHint,
                            out strXml,
                            out lHintNext,
                            0,  // lAttachmentFragmentStart,
                            0,  // nAttachmentFramengLength,
                            out attachment_data,
                            out lAttachmentTotalLength,
                            out strError);
                        if (lRet == -1)
                            goto ERROR1;
                        if (lRet == 0)
                            return 0;

                        if (lRet == 2)
                            break;

#if NO
                            // 2011/12/30
                            // 日志记录可能动态地增加了，超过了原先为ProgressBar设置的范围
                            if (lFizeTotalSize < (int)lHintNext)
                            {
                                lFizeTotalSize = lHintNext;

                                stop.SetProgressRange(0, lFizeTotalSize);
                            }
#endif
                        // 校正
                        if (lProgressValue + lHintNext > lSize)
                        {
                            lSize = lProgressValue + lHintNext;

                            stop.SetProgressRange(0, lSize);
                            this.estimate.SetRange(0, lSize);
                        }

                            stop.SetProgressValue(lProgressValue + lHintNext);

                        if (lIndex % 100 == 0)
                        {
                            stop.SetMessage("正在装入日志文件 " + strLogFileName + " 中的记录 "+lIndex.ToString()+" 。"
    + "剩余时间 " + ProgressEstimate.Format(this.estimate.Estimate(lProgressValue + lHintNext)) + " 已经过时间 " + ProgressEstimate.Format(this.estimate.delta_passed));
                        }

                        if (string.IsNullOrEmpty(strXml) == false)
                        {
                            OperLogItemInfo info = new OperLogItemInfo();

                            if (this.StoreInTempFile == true)
                            {
                                // 创建临时文件
                                string strTempFileName = Path.GetTempFileName();
                                Stream stream = File.Create(strTempFileName);

                                // 写入xml内容
                                byte[] buffer = Encoding.UTF8.GetBytes(strXml);
                                stream.Write(buffer, 0, buffer.Length);

                                stream.Close();

                                m_tempFileNames.Add(strTempFileName);
                                info.IndexOfTempFilename = m_tempFileNames.Count - 1;
                            }
                            else
                            {
                                info.Hint = lHint;
                            }
                            ListViewItem item = new ListViewItem(strLogFileName, 0);
                            item.SubItems.Add(lIndex.ToString());  // 序号从0开始计数
                            this.listView_records.Items.Add(item);
                            item.Tag = info;

                            int nRet = FillListViewItem(item,
                                strXml,
                                lAttachmentTotalLength,
                                out strError);
                            if (nRet == -1)
                                goto ERROR1;
                        }
                    }
                }

                lProgressValue += lFileSize;
            }
            finally
            {
#if DELAY_UPDATE
                this.listView_records.EndUpdate();
#endif
            }

            return 1;
        ERROR1:
            return -1;
        }


		
        // 根据日志文件名文件，装载日志记录
        public int LoadFromFilenamesFile(
            string strFilename,
            out string strError)
        {
            strError = "";
            int nRet = 0;

            StreamReader sr = null;
            try
            {
                sr = new StreamReader(strFilename, Encoding.UTF8);
            }
            catch (Exception ex)
            {
                strError = "打开文件 " + strFilename + " 失败: " + ex.Message;
                return -1;
            }

            this.textBox_filenames.Text = sr.ReadToEnd();
            sr.Close();

            this.tabControl_main.SelectedTab = this.tabPage_logRecords;

            EnableControls(false);

            stop.OnStop += new StopEventHandler(this.DoStop);
            stop.Initial("正在初始化浏览器组件 ...");
            stop.BeginLoop();


            this.Update();
            this.MainForm.Update();

#if NO
            this.listView_records.Items.Clear();
            // 2008/11/22 new add
            this.SortColumns.Clear();
            SortColumns.ClearColumnSortDisplay(this.listView_records.Columns);


            this.ClearAllTempFiles();

            Global.ClearHtmlPage(this.webBrowser_xml,
                this.MainForm.DataDir);
            Global.ClearHtmlPage(this.webBrowser_html,
                this.MainForm.DataDir);
#endif
            this.Clear();

            try
            {
                long lTotalSize = 0;
                List<string> lines = new List<string>();
                for (int i = 0; i < this.textBox_filenames.Lines.Length; i++)
                {
                    Application.DoEvents();

                    if (stop != null)
                    {
                        if (stop.State != 0)
                            return 0;
                    }

                    string strLine = this.textBox_filenames.Lines[i];
                    if (String.IsNullOrEmpty(strLine) == true)
                        continue;

                    // 去掉注释
                    nRet = strLine.IndexOf("#");
                    if (nRet != -1)
                        strLine = strLine.Substring(0, nRet).Trim();

                    if (String.IsNullOrEmpty(strLine) == true)
                        continue;

                    string strLogFilename = "";
                    string strRange = "";

                    nRet = strLine.IndexOf(":");
                    if (nRet != -1)
                    {
                        strLogFilename = strLine.Substring(0, nRet).Trim();
                        strRange = strLine.Substring(nRet + 1).Trim();
                    }
                    else
                    {
                        strLogFilename = strLine.Trim();
                        strRange = "";
                    }

                    long lTemp = 0;
                            // 获得一个日志文件的尺寸
        // return:
        //      -1  error
        //      0   file not found
        //      1   found
                    nRet = GetFileSize(strLogFilename,
            out lTemp,
            out strError);
                    if (nRet == -1)
                        return -1;
                    if (nRet == 0)
                        continue;

                    Debug.Assert(lTemp >= 0, "");
                    lTotalSize += lTemp;

                    lines.Add(strLine);
                }

                if (stop != null)
                    stop.SetProgressRange(0, lTotalSize);

                this.estimate.SetRange(0, lTotalSize);
                this.estimate.Start();

                long lDoneSize = 0;
                for (int i = 0; i < lines.Count; i++)
                {
                    Application.DoEvents();

                    if (stop != null)
                    {
                        if (stop.State != 0)
                            return 0;
                    }

                    string strLine = lines[i];
#if NO
                    if (String.IsNullOrEmpty(strLine) == true)
                        continue;

                    // 去掉注释
                    int nRet = strLine.IndexOf("#");
                    if (nRet != -1)
                        strLine = strLine.Substring(0, nRet).Trim();

                    if (String.IsNullOrEmpty(strLine) == true)
                        continue;
#endif

                    string strLogFilename = "";
                    string strRange = "";

                    nRet = strLine.IndexOf(":");
                    if (nRet != -1)
                    {
                        strLogFilename = strLine.Substring(0, nRet).Trim();
                        strRange = strLine.Substring(nRet + 1).Trim();
                    }
                    else
                    {
                        strLogFilename = strLine.Trim();
                        strRange = "";
                    }

                    //      -1  error
                    //      0   file not found
                    //      1   found
                    nRet = LoadSomeRecords(strLogFilename,
                        strRange,
                        ref lDoneSize,
                        ref lTotalSize,
                        out strError);
                    if (nRet == -1)
                    {
                        if (stop != null)
                        {
                            if (stop.State != 0)
                                return 0;
                        }
                        // MessageBox.Show(this, strError);
                        DialogResult result = MessageBox.Show(this,
strError + "\r\n\r\n是否继续处理?",
"OperLogForm",
MessageBoxButtons.YesNo,
MessageBoxIcon.Question,
MessageBoxDefaultButton.Button1);
                        if (result == DialogResult.No)
                            return 0;
                    }
                }
            }
            finally
            {
                /*
                if (sr != null)
                    sr.Close();
                 * */

                stop.EndLoop();
                stop.OnStop -= new StopEventHandler(this.DoStop);
                stop.Initial("");
                stop.HideProgress();

                EnableControls(true);
            }

            return 0;
            /*
        ERROR1:
            return -1;
             * */
        }


		        // 装入一个日志文件中的全部记录
        public int LoadRecordsFromSingleLogFile(string strLogFileName)
        {
            string strError = "";

            this.tabControl_main.SelectedTab = this.tabPage_logRecords;

            EnableControls(false);

            stop.OnStop += new StopEventHandler(this.DoStop);
            stop.Initial("正在初始化浏览器组件 ...");
            stop.BeginLoop();


            this.Update();
            this.MainForm.Update();

#if NO
            this.listView_records.Items.Clear();
            // 2008/11/22 new add
            this.SortColumns.Clear();
            SortColumns.ClearColumnSortDisplay(this.listView_records.Columns);

            this.ClearAllTempFiles();

            Global.ClearHtmlPage(this.webBrowser_xml,
                this.MainForm.DataDir);
            Global.ClearHtmlPage(this.webBrowser_html,
                this.MainForm.DataDir);
#endif
            this.Clear();

            stop.SetMessage("正在装入日志文件 " + strLogFileName + " 中的记录...");

            try
            {

                string strXml = "";
                long lAttachmentTotalLength = 0;
                byte[] attachment_data = null;

                long lTotalSize = 0;

                // 获得日志文件尺寸
                long lRet = Channel.GetOperLog(
                    stop,
                    strLogFileName,
                    -1,    // lIndex,
                    -1, // lHint,
                    out strXml,
                    out lTotalSize,
                    0,  // lAttachmentFragmentStart,
                    0,  // nAttachmentFramengLength,
                    out attachment_data,
                    out lAttachmentTotalLength,
                    out strError);

                stop.SetProgressRange(0, lTotalSize);

                long lHint = -1;
                long lHintNext = -1;

#if DELAY_UPDATE
                this.listView_records.BeginUpdate();
#endif
                try
                {
                    for (long lIndex = 0; ; lIndex++)
                    {
                        Application.DoEvents();

                        if (stop != null)
                        {
                            if (stop.State != 0)
                            {
                                strError = "用户中断1";
                                return -1;
                            }
                        }

                        lHint = lHintNext;

                        // 获得日志
                        // result.Value
                        //      -1  error
                        //      0   file not found
                        //      1   succeed
                        //      2   超过范围
                        lRet = Channel.GetOperLog(
                            stop,
                            strLogFileName,
                            lIndex,
                            lHint,
                            out strXml,
                            out lHintNext,
                            0,  // lAttachmentFragmentStart,
                            0,  // nAttachmentFramengLength,
                            out attachment_data,
                            out lAttachmentTotalLength,
                            out strError);
                        if (lRet == -1 || lRet == 0)
                            goto ERROR1;

                        if (lRet == 2)
                            break;

                        // 2011/12/30
                        // 日志记录可能动态地增加了，超过了原先为ProgressBar设置的范围
                        if (lTotalSize < (int)lHintNext)
                        {
                            lTotalSize = lHintNext;
                            stop.SetProgressRange(0, lTotalSize);
                        }

                        stop.SetProgressValue(lHintNext);

                        if (string.IsNullOrEmpty(strXml) == false)
                        {
                            OperLogItemInfo info = new OperLogItemInfo();

                            if (this.StoreInTempFile == true)
                            {
                                // 创建临时文件
                                // TODO: 需要在dp2circulation数据目录下创建一个临时目录，目录名为~XXXX形态(可以用窗口的hashcode，或者GUID)，然后在下面用序号作为文件名
                                // TODO: 可否不要存储临时文件，在需要的时候从服务器端取?
                                string strTempFileName = Path.GetTempFileName();
                                Stream stream = File.Create(strTempFileName);

                                // 写入xml内容
                                byte[] buffer = Encoding.UTF8.GetBytes(strXml);
                                stream.Write(buffer, 0, buffer.Length);

                                stream.Close();

                                m_tempFileNames.Add(strTempFileName);
                                info.IndexOfTempFilename = m_tempFileNames.Count - 1;
                            }
                            else
                            {
                                info.Hint = lHint;
                            }

                            ListViewItem item = new ListViewItem(strLogFileName, 0);
                            item.SubItems.Add(lIndex.ToString());  // 序号从0开始计数
                            this.listView_records.Items.Add(item);

                            item.Tag = info;

                            int nRet = FillListViewItem(item,
                                strXml,
                                lAttachmentTotalLength,
                                out strError);
                            if (nRet == -1)
                                goto ERROR1;
                        }
                    }
                }
                finally
                {
#if DELAY_UPDATE
                    this.listView_records.EndUpdate();
#endif
                }
            }
            finally
            {
                stop.EndLoop();
                stop.OnStop -= new StopEventHandler(this.DoStop);
                stop.Initial("");
                stop.HideProgress();

                EnableControls(true);
            }

            return 1;
        ERROR1:
            MessageBox.Show(this, strError);
            return -1;
        }



		/// operlogstatisform.cs

		        // 对每个日志文件，每个日志记录进行循环
        // return:
        //      0   普通返回
        //      1   要全部中断
        int DoLoop(out string strError)
        {
            strError = "";
            int nRet = 0;
            long lRet = 0;

            List<string> LogFileNames = null;

            // TODO: 是否需要检查起止日期是否为空值？空值是警告还是就当作今天？

            string strStartDate = DateTimeUtil.DateTimeToString8(this.dateControl_start.Value);
            string strEndDate = DateTimeUtil.DateTimeToString8(this.dateControl_end.Value);

            string strWarning = "";
                    // 根据日期范围，发生日志文件名
        // parameters:
        //      strStartDate    起始日期。8字符
        //      strEndDate  结束日期。8字符
        // return:
        //      -1  错误
        //      0   成功
            nRet = MakeLogFileNames(strStartDate,
                strEndDate,
                false,
                out LogFileNames,
                out strWarning,
                out strError);
            if (nRet == -1)
                return -1;

            if (String.IsNullOrEmpty(strWarning) == false)
                MessageBox.Show(this, strWarning);

            this.progressBar_files.Minimum = 0;
            this.progressBar_files.Maximum = LogFileNames.Count;
            this.progressBar_files.Value = 0;

            // 日志文件循环
            for (int i = 0; i < LogFileNames.Count; i++)
            {

                long lHint = -1;
                long lHintNext = -1;

                string strLogFileName = LogFileNames[i] + ".log";

                DateTime currentDate = DateTimeUtil.Long8ToDateTime(LogFileNames[i]);

                stop.SetMessage("正在处理日志文件 " + strLogFileName);

                // 探测日志文件的尺寸

                string strTempXml = "";
                long lTempAttachmentTotalLength = 0;
                byte[] temp_attachment_data = null;

                // result.Value
                //      -1  error
                //      0   file not found
                //      1   succeed
                //      2   超过范围
                lRet = Channel.GetOperLog(
                    stop,
                    strLogFileName,
                    -1, // lIndex,
                    -1, // lHint,
                    out strTempXml,
                    out lHintNext,
                    0,  // lAttachmentFragmentStart,
                    1,  // nAttachmentFramengLength,
                    out temp_attachment_data,
                    out lTempAttachmentTotalLength,
                    out strError);
                if (lRet == -1)
                    return -1;

                if (lRet == 0)
                    continue;    // 文件不存在

                Debug.Assert(lRet == 1, "");
                this.progressBar_records.Minimum = 0;
                this.progressBar_records.Maximum = (int)lHintNext;
                this.progressBar_records.Value = 0;


                // 每个日志记录的循环
                for (long lIndex = 0; ; lIndex++)
                {

                    Application.DoEvents();	// 出让界面控制权

                    if (stop.State != 0)
                    {
                        DialogResult result = MessageBox.Show(this,
                            "确实要中断当前统计运算操作?",
                            "dp2Circulation",
                            MessageBoxButtons.YesNo,
                            MessageBoxIcon.Question,
                            MessageBoxDefaultButton.Button2);
                        if (result == DialogResult.Yes)
                        {
                            strError = "用户中断";
                            return -1;
                        }
                        else
                        {
                            stop.Continue();
                        }
                    }

                    string strXml = "";
                    long lAttachmentTotalLength = 0;
                    byte[] attachment_data = null;

                    lHint = lHintNext;

                    stop.SetMessage("正在处理日志文件 " + strLogFileName + " 的记录 " + lIndex.ToString());


                    // 获得日志
                    // result.Value
                    //      -1  error
                    //      0   file not found
                    //      1   succeed
                    //      2   超过范围
                    lRet = Channel.GetOperLog(
                        stop,
                        strLogFileName,
                        lIndex,
                        lHint,
                        out strXml,
                        out lHintNext,
                        0,  // lAttachmentFragmentStart,
                        1,  // nAttachmentFramengLength,
                        out attachment_data,
                        out lAttachmentTotalLength,
                        out strError);
                    if (lRet == -1)
                    {
                        if (Channel.ErrorCode == DigitalPlatform.CirculationClient.localhost.ErrorCode.AccessDenied)
                            continue;
                        return -1;
                    }

                    if (lRet == 0)
                        break;


                    if (lRet == 2)
                    {
                        // bEnd = true;
                        break;
                    }

                    if (string.IsNullOrEmpty(strXml) == true)
                        continue;

                    // 日志记录可能动态地增加了，超过了原先为ProgressBar设置的范围
                    if (this.progressBar_records.Maximum < (int)lHintNext)
                        this.progressBar_records.Maximum = (int)lHintNext;

                    this.progressBar_records.Value = (int)lHintNext;

                    // strXml中为日志记录

                    // 触发Script中OnRecord()代码
                    if (objStatis != null)
                    {
                        objStatis.Xml = strXml;
                        objStatis.CurrentDate = currentDate;
                        objStatis.CurrentLogFileName = strLogFileName;
                        objStatis.CurrentRecordIndex = lIndex;

                        StatisEventArgs args = new StatisEventArgs();
                        objStatis.OnRecord(this, args);
                        if (args.Continue == ContinueType.SkipAll)
                            return 1;
                    }
                } // end of for

                this.progressBar_files.Value = i+1;


                /*
                if (bEnd == true)
                    break;
                 * */

            }

            this.progressBar_files.Value = LogFileNames.Count;


            return 0;
        }



~~~~~~~~~
2012/11/16

为MARC记录增补必备字段的流程

1) 获得哪些字段定义了 mandatory="yes"

2) 处理一个字段。

看看这个字段的<Property>元素中是否定义了<DefaultValue>元素
      <DefaultValue>%IncSeed:@中文种次号,001,8%</DefaultValue>
如果定义了，直接采用它

(有些不需要外界介入的宏，MarcEditor代码中有解析宏的函数可以使用)

4) 如果一个字段没有定义缺省值，则需要观察下一级构成中，例如<subfield>或<char>中，是否有mandatory="yes"定义

如果有，则需要创建这个结构在字段中。

观察这个结构体是否有缺省值定义，如果有则直接采用，否则又要找它的下级结构体来组建

如果一个结构体实在没有办法获得缺省值，则只好创建一个具有字段名没有字段内容的形态


        // 从复杂的字符串中，析出纯粹价格数字部分（包括小数点）。
        // 2006/11/15 能处理数字前的正负号
        public static string GetPurePrice(string strPrice)
        {
            if (String.IsNullOrEmpty(strPrice) == true)
                return strPrice;

            string strResult = "";
            int nSegment = 0;   // 0 非数字段 1数字段 2 非数字段
            int nPointCount = 0;

            bool bNegative = false; // 是否为负数

            for (int i = 0; i < strPrice.Length; i++)
            {
                char ch = strPrice[i];

                if ((ch <= '9' && ch >= '0')
                    || ch == '.')
                {

                    if (ch == '.')
                    {
                        if (nPointCount == 1)
                            break;  // 已经出现过一个小数点了

                        nPointCount++;
                    }

                    if (nSegment == 0)
                    {
                        nSegment = 1;
                    }
                }
                else
                {
                    if (nSegment == 0)
                    {
                        if (ch == '-')
                            bNegative = true;
                    }

                    if (nSegment == 1)
                    {
                        nSegment = 2;
                        break;
                    }
                }

                if (nSegment == 1)
                    strResult += ch;
            }

            // 如果第一个就是小数点
            if (strResult.Length > 0
                && strResult[0] == '.')
            {
                strResult = "0" + strResult;
            }

            // 2008/11/15 new add
            if (bNegative == true)
                return "-" + strResult;

            return strResult;
        }

		///
		        // 装入一个日志文件中的若干记录
        // parameters:
        //      strCacheDir 存储本地缓存文件的目录
        //      lServerFileSize 服务器端日志文件的尺寸。如果为-1，表示函数内会自动获取
        //      lSize   进度条所采用的最大尺寸。如果必要，可能会被本函数推动
        // return:
        //      -1  error
        //      0   正常结束
        //      1   用户中断
        static int ProcessFile(
            IWin32Window owner,
            Stop stop,
            ProgressEstimate estimate,
            LibraryChannel channel,
            string strLogFileName,
            long lServerFileSize,
            string strRange,
            string strStyle,
            string strCacheDir,
            object param,
            Delegate_doRecord procDoRecord,
            ref long lProgressValue,
            ref long lSize,
            out string strError)
        {
            strError = "";
            int nRet = 0;
            long lRet = 0;

            stop.SetMessage("正在装入日志文件 " + strLogFileName + " 中的记录。"
                + "剩余时间 " + ProgressEstimate.Format(estimate.Estimate(lProgressValue)) + " 已经过时间 " + ProgressEstimate.Format(estimate.delta_passed));

            string strXml = "";
            long lAttachmentTotalLength = 0;
            byte[] attachment_data = null;

            long lFileSize = 0;
            if (lServerFileSize == -1)
            {
                lServerFileSize = 0;

                // 获得服务器端日志文件尺寸
                lRet = channel.GetOperLog(
                    stop,
                    strLogFileName,
                    -1,    // lIndex,
                    -1, // lHint,
                    out strXml,
                    out lServerFileSize,
                    0,  // lAttachmentFragmentStart,
                    0,  // nAttachmentFramengLength,
                    out attachment_data,
                    out lAttachmentTotalLength,
                    out strError);
                // 2010/12/13
                if (lRet == 0)
                    return 0;
            }

            Stream stream = null;
            bool bCacheFileExist = false;
            bool bRemoveCacheFile = false;  // 是否要自动删除未全部完成的本地缓存文件

            bool bAutoCache = StringUtil.IsInList("autocache", strStyle);

            if (bAutoCache == true)
            {
                nRet = PrepareCacheFile(
                    strCacheDir,
                    strLogFileName,
                    lServerFileSize,
                    out bCacheFileExist,
                    out stream,
                    out strError);
                if (nRet == -1)
                    return -1;

                if (bCacheFileExist == false && stream != null)
                    bRemoveCacheFile = true;
            }

            try
            {
                if (bCacheFileExist == true)
                    lFileSize = stream.Length;
                else
                    lFileSize = lServerFileSize;

                // stop.SetProgressRange(0, lTotalSize);

                if (String.IsNullOrEmpty(strRange) == true)
                    strRange = "0-9999999999";

                RangeList rl = new RangeList(strRange);

                for (int i = 0; i < rl.Count; i++)
                {
                    RangeItem ri = (RangeItem)rl[i];

                    long lHint = -1;
                    long lHintNext = -1;
                    for (long lIndex = ri.lStart; lIndex < ri.lStart + ri.lLength; lIndex++)
                    {
                        Application.DoEvents();

                        if (stop != null)
                        {
                            if (stop.State != 0)
                            {
                                strError = "用户中断1";
                                goto ERROR1;
                            }
                        }

                        if (lIndex == ri.lStart)
                            lHint = -1;
                        else
                            lHint = lHintNext;

                        if (bCacheFileExist == true)
                        {
                            if (lHint == -1)
                            {
                                // return:
                                //      -1  error
                                //      0   成功
                                //      1   到达文件末尾或者超出
                                nRet = LocationRecord(stream,
                    lIndex,
                    out strError);
                                if (nRet == -1)
                                    return -1;
                            }
                            else
                            {
                                // 根据暗示找到
                                if (lHint == stream.Length)
                                    break;

                                if (lHint > stream.Length)
                                {
                                    strError = "lHint参数值不正确";
                                    return -1;
                                }
                                if (stream.Position != lHint)
                                    stream.Seek(lHint, SeekOrigin.Begin);
                            }

                            nRet = ReadCachedEnventLog(
                                stream,
                                out strXml,
                                out lAttachmentTotalLength,
                                out strError);
                            if (nRet == -1)
                                return -1;
                            lHintNext = stream.Position;

                        }
                        else
                        {

                            // 获得日志
                            // result.Value
                            //      -1  error
                            //      0   file not found
                            //      1   succeed
                            //      2   超过范围
                            lRet = channel.GetOperLog(
                                stop,
                                strLogFileName,
                                lIndex,
                                lHint,
                                out strXml,
                                out lHintNext,
                                0,  // lAttachmentFragmentStart,
                                0,  // nAttachmentFramengLength,
                                out attachment_data,
                                out lAttachmentTotalLength,
                                out strError);
                            if (lRet == -1)
                            {
                                DialogResult result = MessageBox.Show(owner,
strError + "\r\n\r\n是否继续处理?",
"OperLogForm",
MessageBoxButtons.YesNo,
MessageBoxIcon.Question,
MessageBoxDefaultButton.Button1);
                                if (result == DialogResult.No)
                                    goto ERROR1;
                                else
                                {
                                    // TODO: 是否要在listview中装入一条表示出错的行?
                                    lHintNext = -1;
                                    continue;
                                }
                            }
                            if (lRet == 0)
                                return 0;

                            if (lRet == 2)
                                break;

                            // 写入本地缓存的日志文件
                            if (stream != null)
                            {
                                try
                                {
                                    WriteCachedEnventLog(
                                        stream,
                                        strXml,
                                        lAttachmentTotalLength);
                                }
                                catch (Exception ex)
                                {
                                    strError = "写入本地缓存文件的时候出错: " + ex.Message;
                                    return -1;
                                }
                            }
                        }

#if NO
                            // 2011/12/30
                            // 日志记录可能动态地增加了，超过了原先为ProgressBar设置的范围
                            if (lFizeTotalSize < (int)lHintNext)
                            {
                                lFizeTotalSize = lHintNext;

                                stop.SetProgressRange(0, lFizeTotalSize);
                            }
#endif
                        if (lHintNext >= 0)
                        {
                            // 校正
                            if (lProgressValue + lHintNext > lSize)
                            {
                                lSize = lProgressValue + lHintNext;

                                stop.SetProgressRange(0, lSize);
                                estimate.SetRange(0, lSize);
                            }

                            stop.SetProgressValue(lProgressValue + lHintNext);
                        }

                        if (lIndex % 100 == 0)
                        {
                            stop.SetMessage("正在装入日志文件 " + strLogFileName + " 中的记录 " + lIndex.ToString() + " 。"
    + "剩余时间 " + ProgressEstimate.Format(estimate.Estimate(lProgressValue + lHintNext)) + " 已经过时间 " + ProgressEstimate.Format(estimate.delta_passed));
                        }

                        //
                        if (procDoRecord != null)
                        {
                            nRet = procDoRecord(strLogFileName,
        strXml,
        bCacheFileExist,
        lHint,
        lIndex,
        lAttachmentTotalLength,
        param,
        out strError);
                            if (nRet == -1)
                            {
                                DialogResult result = MessageBox.Show(owner,
                                    strLogFileName + " : " + lIndex.ToString() + "\r\n" +  strError + "\r\n\r\n是否继续处理?",
"OperLogForm",
MessageBoxButtons.YesNo,
MessageBoxIcon.Question,
MessageBoxDefaultButton.Button1);
                                if (result == DialogResult.No)
                                    return -1;
                            }
                            if (nRet == 1)
                                return 1;
                        }

                    }
                }

                // 创建本地缓存的日志文件的metadata文件
                if (bCacheFileExist == false && stream != null)
                {
                    nRet = CreateCacheMetadataFile(
                        strCacheDir,
                        strLogFileName,
                        lServerFileSize,
                        out strError);
                    if (nRet == -1)
                        goto ERROR1;
                }

                bRemoveCacheFile = false;   // 不删除
            }
            finally
            {
                if (stream != null)
                    stream.Close();

                if (bRemoveCacheFile == true)
                {
                    string strError1 = "";
                    nRet = DeleteCacheFile(
                        strCacheDir,
                        strLogFileName,
                        out strError1);
                    if (nRet == -1)
                        MessageBox.Show(owner, strError1);
                }
            }

            lProgressValue += lFileSize;
            return 0;
        ERROR1:
            return -1;
        }


		//
		册统计窗 优化

		*** 根据册记录路径文件进行统计
		原来的一个动作获取册记录和书目记录的操作，可以包装为一个函数
		这个函数预先知道所有即将要获取的册记录路径。这些全部路径存在于内存，或者可以顺次从文件获取

		第一个获取册记录的时候，一次性获取100条记录，然后记忆于一个存储结构
		当后面继续获取下一条册记录的时候，直接从这个存储结构中获得即可，如果存储结构中的记录用完了，则出发一次获得新的最多100条的操作

		当需要同时获取书目记录的时候，活了了以后，放入一个缓存结构
		当后面还需要获取书目记录的时候，先从这个缓存结构中寻找。如果没有，才从服务器获取
		缓存结构每达到100条的时候清理一次

		书目记录也可以这样获取：
		先把足够多的册记录获取到缓存后，根据这些册记录的XML字符串提取出parentid，进而计算出书目记录路径。
		把书目记录路径去重后，凑成一批，一次性从服务器获取，然后放到缓存结构中。
		当后面使用缓存的侧记录的时候，就能确保能找到已经获取到的书目记录了

		书目记录缓存使用完以后，还可以进入一个更大尺寸的缓存，后面要获取书目记录的时候先从这里找，如果没有才真正请求服务器提供

		如果是脚本触发延迟获取书目记录，则不能享受前面的一批地获取书目记录的好处了，但可以享受大尺寸的缓存的好处。因为册记录之间很多是属于同一条书目记录的


		~~~

		后面可以作dp2library中批获得书目记录或者书目记录摘要的功能


		        /// <returns>
        /// <para></para>
        /// <para></para>
        /// <para></para>
        /// </returns>




		~~~~~~~~~~~~~~~~
有关调用实时(JIT)调试而不是此对话框的详细信息，
请参见此消息的结尾。

************** 异常文本 **************
System.Runtime.InteropServices.COMException (0x800700AA): 请求的资源在使用中。 (异常来自 HRESULT:0x800700AA)
   在 System.Windows.Forms.UnsafeNativeMethods.IWebBrowser2.Navigate2(Object& URL, Object& flags, Object& targetFrameName, Object& postData, Object& headers)
   在 System.Windows.Forms.WebBrowser.PerformNavigate2(Object& URL, Object& flags, Object& targetFrameName, Object& postData, Object& headers)
   在 System.Windows.Forms.WebBrowser.Navigate(String urlString)
   在 dp2Circulation.QuickChargingForm._setReaderRenderString(String strText) 位置 F:\cs4.0\dp2Circulation\Charging\QuickChargingForm.cs:行号 394


************** 已加载的程序集 **************
mscorlib
    程序集版本: 4.0.0.0
    Win32 版本: 4.0.30319.1008 (RTMGDR.030319-1000)
    基本代码: file:///D:/Windows/Microsoft.NET/Framework/v4.0.30319/mscorlib.dll
----------------------------------------
dp2Circulation
    程序集版本: 2.2.5097.22932
    Win32 版本: 2.2.0.0
    基本代码: file:///F:/cs4.0/dp2Circulation/bin/Debug/dp2Circulation.exe
----------------------------------------
System.Windows.Forms
    程序集版本: 4.0.0.0
    Win32 版本: 4.0.30319.1002 built by: RTMGDR
    基本代码: file:///D:/Windows/Microsoft.Net/assembly/GAC_MSIL/System.Windows.Forms/v4.0_4.0.0.0__b77a5c561934e089/System.Windows.Forms.dll
----------------------------------------
System.Drawing
    程序集版本: 4.0.0.0
    Win32 版本: 4.0.30319.1001 built by: RTMGDR
    基本代码: file:///D:/Windows/Microsoft.Net/assembly/GAC_MSIL/System.Drawing/v4.0_4.0.0.0__b03f5f7f11d50a3a/System.Drawing.dll
----------------------------------------
System
    程序集版本: 4.0.0.0
    Win32 版本: 4.0.30319.1001 built by: RTMGDR
    基本代码: file:///D:/Windows/Microsoft.Net/assembly/GAC_MSIL/System/v4.0_4.0.0.0__b77a5c561934e089/System.dll
----------------------------------------
System.Speech
    程序集版本: 4.0.0.0
    Win32 版本: 4.0.30319.1 built by: RTMRel
    基本代码: file:///D:/Windows/Microsoft.Net/assembly/GAC_MSIL/System.Speech/v4.0_4.0.0.0__31bf3856ad364e35/System.Speech.dll
----------------------------------------
DigitalPlatform.Script
    程序集版本: 2.0.5096.33352
    Win32 版本: 2.0.5096.33352
    基本代码: file:///F:/cs4.0/dp2Circulation/bin/Debug/DigitalPlatform.Script.DLL
----------------------------------------
System.Xml
    程序集版本: 4.0.0.0
    Win32 版本: 4.0.30319.1015 built by: RTMGDR
    基本代码: file:///D:/Windows/Microsoft.Net/assembly/GAC_MSIL/System.Xml/v4.0_4.0.0.0__b77a5c561934e089/System.Xml.dll
----------------------------------------
DigitalPlatform.CirculationClient
    程序集版本: 2.0.5095.27961
    Win32 版本: 2.0.0.0
    基本代码: file:///F:/cs4.0/dp2Circulation/bin/Debug/DigitalPlatform.CirculationClient.DLL
----------------------------------------
DigitalPlatform.Xml
    程序集版本: 2.0.5095.27956
    Win32 版本: 2.0.5095.27956
    基本代码: file:///F:/cs4.0/dp2Circulation/bin/Debug/DigitalPlatform.Xml.DLL
----------------------------------------
DigitalPlatform
    程序集版本: 2.0.5095.27955
    Win32 版本: 2.0.5095.27955
    基本代码: file:///F:/cs4.0/dp2Circulation/bin/Debug/DigitalPlatform.DLL
----------------------------------------
System.Runtime.Serialization
    程序集版本: 4.0.0.0
    Win32 版本: 4.0.30319.1016 (RTMGDR.030319-1000)
    基本代码: file:///D:/Windows/Microsoft.Net/assembly/GAC_MSIL/System.Runtime.Serialization/v4.0_4.0.0.0__b77a5c561934e089/System.Runtime.Serialization.dll
----------------------------------------
System.Core
    程序集版本: 4.0.0.0
    Win32 版本: 4.0.30319.233 built by: RTMGDR
    基本代码: file:///D:/Windows/Microsoft.Net/assembly/GAC_MSIL/System.Core/v4.0_4.0.0.0__b77a5c561934e089/System.Core.dll
----------------------------------------
DigitalPlatform.GcatClient
    程序集版本: 2.0.5095.27958
    Win32 版本: 2.0.5095.27958
    基本代码: file:///F:/cs4.0/dp2Circulation/bin/Debug/DigitalPlatform.GcatClient.DLL
----------------------------------------
System.ServiceModel
    程序集版本: 4.0.0.0
    Win32 版本: 4.0.30319.1001 built by: RTMGDR
    基本代码: file:///D:/Windows/Microsoft.Net/assembly/GAC_MSIL/System.ServiceModel/v4.0_4.0.0.0__b77a5c561934e089/System.ServiceModel.dll
----------------------------------------
DigitalPlatform.Drawing
    程序集版本: 2.0.5095.27956
    Win32 版本: 2.0.5095.27956
    基本代码: file:///F:/cs4.0/dp2Circulation/bin/Debug/DigitalPlatform.Drawing.DLL
----------------------------------------
System.Deployment
    程序集版本: 4.0.0.0
    Win32 版本: 4.0.30319.1 (RTMRel.030319-0100)
    基本代码: file:///D:/Windows/Microsoft.Net/assembly/GAC_MSIL/System.Deployment/v4.0_4.0.0.0__b03f5f7f11d50a3a/System.Deployment.dll
----------------------------------------
System.Deployment.resources
    程序集版本: 4.0.0.0
    Win32 版本: 4.0.30319.1 (RTMRel.030319-0100)
    基本代码: file:///D:/Windows/Microsoft.Net/assembly/GAC_MSIL/System.Deployment.resources/v4.0_4.0.0.0_zh-Hans_b03f5f7f11d50a3a/System.Deployment.resources.dll
----------------------------------------
System.Configuration
    程序集版本: 4.0.0.0
    Win32 版本: 4.0.30319.1015 (RTMGDR.030319-1000)
    基本代码: file:///D:/Windows/Microsoft.Net/assembly/GAC_MSIL/System.Configuration/v4.0_4.0.0.0__b03f5f7f11d50a3a/System.Configuration.dll
----------------------------------------
mscorlib.resources
    程序集版本: 4.0.0.0
    Win32 版本: 4.0.30319.235 (RTMGDR.030319-2300)
    基本代码: file:///D:/Windows/Microsoft.Net/assembly/GAC_MSIL/mscorlib.resources/v4.0_4.0.0.0_zh-Hans_b77a5c561934e089/mscorlib.resources.dll
----------------------------------------
AForge.Video.DirectShow
    程序集版本: 2.2.4.1
    Win32 版本: 2.2.4.1
    基本代码: file:///F:/cs4.0/dp2Circulation/bin/Debug/AForge.Video.DirectShow.DLL
----------------------------------------
zxing
    程序集版本: 0.10.0.0
    Win32 版本: 0.10.0.0
    基本代码: file:///F:/cs4.0/dp2Circulation/bin/Debug/zxing.DLL
----------------------------------------
DigitalPlatform.IO
    程序集版本: 2.0.5095.27956
    Win32 版本: 2.0.5095.27956
    基本代码: file:///F:/cs4.0/dp2Circulation/bin/Debug/DigitalPlatform.IO.DLL
----------------------------------------
Microsoft.mshtml
    程序集版本: 7.0.3300.0
    Win32 版本: 7.0.3300.0
    基本代码: file:///D:/Windows/assembly/GAC/Microsoft.mshtml/7.0.3300.0__b03f5f7f11d50a3a/Microsoft.mshtml.dll
----------------------------------------
AForge.Video
    程序集版本: 2.2.4.0
    Win32 版本: 2.2.4.0
    基本代码: file:///F:/cs4.0/dp2Circulation/bin/Debug/AForge.Video.DLL
----------------------------------------
DigitalPlatform.Text
    程序集版本: 2.0.5095.27956
    Win32 版本: 2.0.5095.27956
    基本代码: file:///F:/cs4.0/dp2Circulation/bin/Debug/DigitalPlatform.Text.DLL
----------------------------------------
System.Web
    程序集版本: 4.0.0.0
    Win32 版本: 4.0.30319.1016 built by: RTMGDR
    基本代码: file:///D:/Windows/Microsoft.Net/assembly/GAC_32/System.Web/v4.0_4.0.0.0__b03f5f7f11d50a3a/System.Web.dll
----------------------------------------
System.IdentityModel
    程序集版本: 4.0.0.0
    Win32 版本: 4.0.30319.1001 (RTMGDR.030319-1000)
    基本代码: file:///D:/Windows/Microsoft.Net/assembly/GAC_MSIL/System.IdentityModel/v4.0_4.0.0.0__b77a5c561934e089/System.IdentityModel.dll
----------------------------------------
SMDiagnostics
    程序集版本: 4.0.0.0
    Win32 版本: 4.0.30319.1 (RTMRel.030319-0100)
    基本代码: file:///D:/Windows/Microsoft.Net/assembly/GAC_MSIL/SMDiagnostics/v4.0_4.0.0.0__b77a5c561934e089/SMDiagnostics.dll
----------------------------------------
System.Runtime.DurableInstancing
    程序集版本: 4.0.0.0
    Win32 版本: 4.0.30319.1 built by: RTMRel
    基本代码: file:///D:/Windows/Microsoft.Net/assembly/GAC_MSIL/System.Runtime.DurableInstancing/v4.0_4.0.0.0__31bf3856ad364e35/System.Runtime.DurableInstancing.dll
----------------------------------------
System.WorkflowServices
    程序集版本: 4.0.0.0
    Win32 版本: 4.0.30319.1 (RTMRel.030319-0100)
    基本代码: file:///D:/Windows/Microsoft.Net/assembly/GAC_MSIL/System.WorkflowServices/v4.0_4.0.0.0__31bf3856ad364e35/System.WorkflowServices.dll
----------------------------------------
System.ServiceModel.Web
    程序集版本: 4.0.0.0
    Win32 版本: 4.0.30319.233 (RTMGDR.030319-2300)
    基本代码: file:///D:/Windows/Microsoft.Net/assembly/GAC_MSIL/System.ServiceModel.Web/v4.0_4.0.0.0__31bf3856ad364e35/System.ServiceModel.Web.dll
----------------------------------------
System.ServiceModel.Discovery
    程序集版本: 4.0.0.0
    Win32 版本: 4.0.30319.1 built by: RTMRel
    基本代码: file:///D:/Windows/Microsoft.Net/assembly/GAC_MSIL/System.ServiceModel.Discovery/v4.0_4.0.0.0__31bf3856ad364e35/System.ServiceModel.Discovery.dll
----------------------------------------
System.ServiceModel.Activities
    程序集版本: 4.0.0.0
    Win32 版本: 4.0.30319.1 built by: RTMRel
    基本代码: file:///D:/Windows/Microsoft.Net/assembly/GAC_MSIL/System.ServiceModel.Activities/v4.0_4.0.0.0__31bf3856ad364e35/System.ServiceModel.Activities.dll
----------------------------------------
System.ServiceModel.Routing
    程序集版本: 4.0.0.0
    Win32 版本: 4.0.30319.1 built by: RTMRel
    基本代码: file:///D:/Windows/Microsoft.Net/assembly/GAC_MSIL/System.ServiceModel.Routing/v4.0_4.0.0.0__31bf3856ad364e35/System.ServiceModel.Routing.dll
----------------------------------------
Microsoft.VisualStudio.Diagnostics.ServiceModelSink
    程序集版本: 4.0.0.0
    Win32 版本: 10.0.30319.1
    基本代码: file:///D:/Windows/Microsoft.Net/assembly/GAC_MSIL/Microsoft.VisualStudio.Diagnostics.ServiceModelSink/v4.0_4.0.0.0__b03f5f7f11d50a3a/Microsoft.VisualStudio.Diagnostics.ServiceModelSink.dll
----------------------------------------
System.ServiceModel.Channels
    程序集版本: 4.0.0.0
    Win32 版本: 4.0.30319.1 built by: RTMRel
    基本代码: file:///D:/Windows/Microsoft.Net/assembly/GAC_MSIL/System.ServiceModel.Channels/v4.0_4.0.0.0__31bf3856ad364e35/System.ServiceModel.Channels.dll
----------------------------------------
System.IdentityModel.Selectors
    程序集版本: 4.0.0.0
    Win32 版本: 4.0.30319.1 (RTMRel.030319-0100)
    基本代码: file:///D:/Windows/Microsoft.Net/assembly/GAC_MSIL/System.IdentityModel.Selectors/v4.0_4.0.0.0__b77a5c561934e089/System.IdentityModel.Selectors.dll
----------------------------------------
System.Xaml
    程序集版本: 4.0.0.0
    Win32 版本: 4.0.30319.298 built by: RTMGDR
    基本代码: file:///D:/Windows/Microsoft.Net/assembly/GAC_MSIL/System.Xaml/v4.0_4.0.0.0__b77a5c561934e089/System.Xaml.dll
----------------------------------------
System.ServiceModel.resources
    程序集版本: 4.0.0.0
    Win32 版本: 4.0.30319.1 built by: RTMRel
    基本代码: file:///D:/Windows/Microsoft.Net/assembly/GAC_MSIL/System.ServiceModel.resources/v4.0_4.0.0.0_zh-Hans_b77a5c561934e089/System.ServiceModel.resources.dll
----------------------------------------
System.Security
    程序集版本: 4.0.0.0
    Win32 版本: 4.0.30319.1016 (RTMGDR.030319-1000)
    基本代码: file:///D:/Windows/Microsoft.Net/assembly/GAC_MSIL/System.Security/v4.0_4.0.0.0__b03f5f7f11d50a3a/System.Security.dll
----------------------------------------
System.DirectoryServices
    程序集版本: 4.0.0.0
    Win32 版本: 4.0.30319.1001 (RTMGDR.030319-1000)
    基本代码: file:///D:/Windows/Microsoft.Net/assembly/GAC_MSIL/System.DirectoryServices/v4.0_4.0.0.0__b03f5f7f11d50a3a/System.DirectoryServices.dll
----------------------------------------
System.DirectoryServices.resources
    程序集版本: 4.0.0.0
    Win32 版本: 4.0.30319.1 (RTMRel.030319-0100)
    基本代码: file:///D:/Windows/Microsoft.Net/assembly/GAC_MSIL/System.DirectoryServices.resources/v4.0_4.0.0.0_zh-Hans_b03f5f7f11d50a3a/System.DirectoryServices.resources.dll
----------------------------------------
System.RunTime.Serialization.resources
    程序集版本: 4.0.0.0
    Win32 版本: 4.0.30319.1 (RTMRel.030319-0100)
    基本代码: file:///D:/Windows/Microsoft.Net/assembly/GAC_MSIL/System.Runtime.Serialization.resources/v4.0_4.0.0.0_zh-Hans_b77a5c561934e089/System.Runtime.Serialization.resources.dll
----------------------------------------
System.Drawing.resources
    程序集版本: 4.0.0.0
    Win32 版本: 4.0.30319.1 built by: RTMRel
    基本代码: file:///D:/Windows/Microsoft.Net/assembly/GAC_MSIL/System.Drawing.resources/v4.0_4.0.0.0_zh-Hans_b03f5f7f11d50a3a/System.Drawing.resources.dll
----------------------------------------
dtpc4j5s
    程序集版本: 0.0.0.0
    Win32 版本: 4.0.30319.1001 built by: RTMGDR
    基本代码: file:///D:/Windows/Microsoft.Net/assembly/GAC_MSIL/System/v4.0_4.0.0.0__b77a5c561934e089/System.dll
----------------------------------------
DigitalPlatform.CommonControl
    程序集版本: 2.0.5096.33352
    Win32 版本: 2.0.0.0
    基本代码: file:///F:/cs4.0/dp2Circulation/bin/Debug/DigitalPlatform.CommonControl.DLL
----------------------------------------
System.Runtime.Remoting
    程序集版本: 4.0.0.0
    Win32 版本: 4.0.30319.1 (RTMRel.030319-0100)
    基本代码: file:///D:/Windows/Microsoft.Net/assembly/GAC_MSIL/System.Runtime.Remoting/v4.0_4.0.0.0__b77a5c561934e089/System.Runtime.Remoting.dll
----------------------------------------
DigitalPlatform.Interfaces
    程序集版本: 1.0.0.0
    Win32 版本: 1.0.0.0
    基本代码: file:///F:/cs4.0/dp2Circulation/bin/Debug/DigitalPlatform.Interfaces.DLL
----------------------------------------
DigitalPlatform.ResultSet
    程序集版本: 2.0.5095.27961
    Win32 版本: 2.0.5095.27961
    基本代码: file:///F:/cs4.0/dp2Circulation/bin/Debug/DigitalPlatform.ResultSet.DLL
----------------------------------------
System.Runtime.Remoting.resources
    程序集版本: 4.0.0.0
    Win32 版本: 4.0.30319.1 (RTMRel.030319-0100)
    基本代码: file:///D:/Windows/Microsoft.Net/assembly/GAC_MSIL/System.Runtime.Remoting.resources/v4.0_4.0.0.0_zh-Hans_b77a5c561934e089/System.Runtime.Remoting.resources.dll
----------------------------------------
Microsoft.CSharp
    程序集版本: 4.0.0.0
    Win32 版本: 4.0.30319.1
    基本代码: file:///D:/Windows/Microsoft.Net/assembly/GAC_MSIL/Microsoft.CSharp/v4.0_4.0.0.0__b03f5f7f11d50a3a/Microsoft.CSharp.dll
----------------------------------------
System.Dynamic
    程序集版本: 4.0.0.0
    Win32 版本: 4.0.30319.1
    基本代码: file:///D:/Windows/Microsoft.Net/assembly/GAC_MSIL/System.Dynamic/v4.0_4.0.0.0__b03f5f7f11d50a3a/System.Dynamic.dll
----------------------------------------
Accessibility
    程序集版本: 4.0.0.0
    Win32 版本: 4.0.30319.1 built by: RTMRel
    基本代码: file:///D:/Windows/Microsoft.Net/assembly/GAC_MSIL/Accessibility/v4.0_4.0.0.0__b03f5f7f11d50a3a/Accessibility.dll
----------------------------------------
Anonymously Hosted DynamicMethods Assembly
    程序集版本: 0.0.0.0
    Win32 版本: 4.0.30319.1008 (RTMGDR.030319-1000)
    基本代码: file:///D:/Windows/Microsoft.Net/assembly/GAC_32/mscorlib/v4.0_4.0.0.0__b77a5c561934e089/mscorlib.dll
----------------------------------------
System.Speech.resources
    程序集版本: 4.0.0.0
    Win32 版本: 4.0.30319.1 built by: RTMRel
    基本代码: file:///D:/Windows/Microsoft.Net/assembly/GAC_MSIL/System.Speech.resources/v4.0_4.0.0.0_zh-Hans_31bf3856ad364e35/System.Speech.resources.dll
----------------------------------------
System.Windows.Forms.resources
    程序集版本: 4.0.0.0
    Win32 版本: 4.0.30319.235 built by: RTMGDR
    基本代码: file:///D:/Windows/Microsoft.Net/assembly/GAC_MSIL/System.Windows.Forms.resources/v4.0_4.0.0.0_zh-Hans_b77a5c561934e089/System.Windows.Forms.resources.dll
----------------------------------------

************** JIT 调试 **************
要启用实时(JIT)调试，
该应用程序或计算机的 .config 文件(machine.config)的 system.windows.forms 节中必须设置
jitDebugging 值。
编译应用程序时还必须启用
调试。

例如: 

<configuration>
    <system.windows.forms jitDebugging="true" />
</configuration>

启用 JIT 调试后，任何未经处理的异常
都将被发送到在此计算机上注册的 JIT 调试器，
而不是由此对话框处理。


~~~~~~~~~~~
select oper1.readerbarcode, oper1.itembarcode, oper1.opertime as 'borrowtime', oper2.opertime as 'returntime' from operlog as oper1
left join operlog as oper2 on oper1.itembarcode = oper2.itembarcode and oper1.readerbarcode = oper2.readerbarcode and oper2.operation = 'return'
and oper1.opertime < oper2.opertime 
where oper1.operation = 'borrow' group by oper1.readerbarcode, oper1.itembarcode, oper1.opertime order by oper1.readerbarcode, oper1.opertime

~~~~
带有摘要
select oper1.readerbarcode, oper1.itembarcode, biblio.summary, oper1.opertime as 'borrowtime', oper2.opertime as 'returntime' from operlog as oper1
left join operlog as oper2 on oper1.itembarcode = oper2.itembarcode and oper1.readerbarcode = oper2.readerbarcode and oper2.operation = 'return' and oper1.opertime < oper2.opertime 

left JOIN item ON oper1.itembarcode = item.itembarcode 
left JOIN biblio ON biblio.bibliorecpath = item.bibliorecpath 

where oper1.operation = 'borrow' group by oper1.readerbarcode, oper1.itembarcode, oper1.opertime order by oper1.readerbarcode, oper1.opertime

~~~~
创建索引
CREATE INDEX IF NOT EXISTS operlog_itembarcode_index 
ON operlog (itembarcode);
CREATE INDEX IF NOT EXISTS operlog_readerbarcode_index 
ON operlog (readerbarcode);

// 删除索引
DROP INDEX IF EXISTS operlog_itembarcode_index; 
DROP INDEX IF EXISTS operlog_readerbarcode_index ;


~~~~
按照分馆筛选
select oper1.readerbarcode, oper1.itembarcode, biblio.summary, oper1.opertime as 'borrowtime', oper2.opertime as 'returntime' from operlog as oper1
left join operlog as oper2 on oper1.itembarcode = oper2.itembarcode and oper1.readerbarcode = oper2.readerbarcode and oper2.operation = 'return' and oper1.opertime < oper2.opertime 

left JOIN item ON oper1.itembarcode = item.itembarcode 
left JOIN biblio ON biblio.bibliorecpath = item.bibliorecpath 

JOIN reader ON oper1.readerbarcode = reader.readerbarcode

where oper1.operation = 'borrow' 

AND reader.librarycode = '合肥望湖小学'

group by oper1.readerbarcode, oper1.itembarcode, oper1.opertime order by oper1.readerbarcode, oper1.opertime

~~~
创建读者表的索引
CREATE INDEX IF NOT EXISTS reader_librarycode_index 
ON reader (librarycode);


select oper1.readerbarcode, oper1.itembarcode, oper1.opertime as 'borrowtime', oper2.opertime as 'returntime' from operlog as oper1
left join operlog as oper2 on oper1.itembarcode = oper2.itembarcode and oper1.readerbarcode = oper2.readerbarcode and oper2.operation = 'return'
and oper1.opertime < oper2.opertime 
where oper1.operation = 'borrow' group by borrowtime order by oper1.readerbarcode, oper1.opertime

每次更新 References.cs 后

#pragma warning disable 1591

#pragma warning restore 1591

~~~~
SQLite warning (284): automatic index on operlog(operation)
SQLite warning (284): automatic index on operlog(operation)
SQLite warning (284): automatic index on operlog(operation)
SQLite warning (284): automatic index on operlog(operation)

~~~~

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" 

"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>图书种册, 按分类，馆藏地 合肥望湖小学/学生图书馆 hnb</title>
    <style media="screen" type="text/css">
BODY {
	FONT-FAMILY: Microsoft YaHei, Verdana, 宋体;
	FONT-SIZE: 10pt;
}

DIV.pageheader
{
	text-align: right;
	border-bottom-width: 1pt;
	border-bottom-color: #000000;
	border-bottom-style: solid;
	margin-bottom: 16pt;
}

DIV.tabletitle
{
	font-size: 14pt;
	font-weight: bold;
	text-align: center;
	margin: 16pt;

	color: #444444;
}

DIV.titlecomment
{
	text-align: center;
	color: #777777;
}

DIV.createtime
{
	text-align: center;
	color: #777777;

	padding: 4pt;
}

TABLE.table
{
    	font-size: 10pt;
    	/*width: 100%;*/
	margin: auto;
	border-color: #efefef;
	border-width: 16px; 
	border-style: solid;
	border-collapse:collapse;
	background-color: #eeeeee;
}

TABLE.table TR
{

	border-color: #999999;
	border-width: 0px; 
	border-bottom-width: 1px;
	border-style: solid;
} 

TABLE.table THEAD TH 
{
	font-weight: bold;
	white-space:nowrap;
}

TABLE.table TD, TABLE.table TH 
{
	padding: 4pt;
	padding-left: 10pt;
	padding-right: 10pt;
	text-align: left;

}

TABLE.table .classname
{

}

TABLE.table .bibliocount
{
	text-align: right;
}

TABLE.table .itemcount
{
	text-align: right;
}

DIV.createtime
{
	text-align: center;
	font-size: 0.8em;
}

DIV.pagefooter
{
	text-align: right;

	border-top-width: 1pt;
	border-top-color: #000000;
	border-top-style: solid;
	margin-top: 16pt;
}
</style>
  </head>
  <body>
    <div class="tabletitle">图书种册, 按分类，馆藏地<br />合肥望湖小学/学生图书馆<br 

/>hnb</div>
    <div class="titlecomment">内容共 16 行<br /></div><table class="table">
        <thead>
            <tr>
                <th class="classname">类号</th>
                <th class="bibliocount">种数</th>
                <th class="itemcount">册数</th>
            </tr>
        </thead>
        <tbody>
            <tr class="content">
                <th class="classname" />
                <td class="bibliocount">897</td>
                <td class="itemcount">1083</td>
            </tr>
            <tr class="content">
                <th class="classname">A</th>
                <td class="bibliocount">2860</td>
                <td class="itemcount">5257</td>
            </tr>
            <tr class="content">
                <th class="classname">B</th>
                <td class="bibliocount">82</td>
                <td class="itemcount">138</td>
            </tr>
            <tr class="content">
                <th class="classname">C</th>
                <td class="bibliocount">234</td>
                <td class="itemcount">303</td>
            </tr>
            <tr class="content">
                <th class="classname">D</th>
                <td class="bibliocount">917</td>
                <td class="itemcount">1652</td>
            </tr>
            <tr class="content">
                <th class="classname">E</th>
                <td class="bibliocount">27</td>
                <td class="itemcount">54</td>
            </tr>
            <tr class="content">
                <th class="classname">F</th>
                <td class="bibliocount">797</td>
                <td class="itemcount">1528</td>
            </tr>
            <tr class="content">
                <th class="classname">G</th>
                <td class="bibliocount">815</td>
                <td class="itemcount">1567</td>
            </tr>
            <tr class="content">
                <th class="classname">H</th>
                <td class="bibliocount">76</td>
                <td class="itemcount">145</td>
            </tr>
            <tr class="content">
                <th class="classname">I</th>
                <td class="bibliocount">4261</td>
                <td class="itemcount">7851</td>
            </tr>
            <tr class="content">
                <th class="classname">J</th>
                <td class="bibliocount">212</td>
                <td class="itemcount">287</td>
            </tr>
            <tr class="content">
                <th class="classname">K</th>
                <td class="bibliocount">197</td>
                <td class="itemcount">294</td>
            </tr>
            <tr class="content">
                <th class="classname">N</th>
                <td class="bibliocount">285</td>
                <td class="itemcount">307</td>
            </tr>
            <tr class="content">
                <th class="classname">O</th>
                <td class="bibliocount">364</td>
                <td class="itemcount">740</td>
            </tr>
            <tr class="content">
                <th class="classname">Q</th>
                <td class="bibliocount">1</td>
                <td class="itemcount">2</td>
            </tr>
            <tr class="content">
                <th class="classname">Z</th>
                <td class="bibliocount">47</td>
                <td class="itemcount">49</td>
            </tr>
        </tbody>
        <tfoot>
            <tr class="sum">
                <th class="classname">合计</th>
                <td class="bibliocount">12072</td>
                <td class="itemcount" />
            </tr>
        </tfoot>
    </table><div class="createtime">创建时间: 2014/4/7 16:26:20</div></body>
</html>

~~~~

统计各种操作工作量


select operlogcircu.operator,  
 count(case operlogcircu.action when 'borrow' then operlogcircu.action end) as borrow, 
 count(case operlogcircu.action when 'return' then operlogcircu.action end) as return, 
 count(case operlogcircu.action when 'lost' then operlogcircu.action end) as lost, 
 count(*) as total
from operlogcircu
 left outer JOIN reader ON operlogcircu.readerbarcode = reader.readerbarcode 
 WHERE      operlogcircu.date >= '20140101' AND operlogcircu.date <= '20140131'   
   AND reader.librarycode = '合肥望湖小学' 
   GROUP BY operlogcircu.operator;


   ~~~~~~~~~~~
   select substr(class_clc.class,1,1) as class1, 

(count(case when item.borrower <> '' then item.borrower end) * 100.0) / count(item.itemrecpath) as per
 FROM item 
 JOIN class_clc ON class_clc.bibliorecpath = item.bibliorecpath 
     WHERE item.location like '合肥望湖小学/%'
group by class1 


~~~~~~~~~
biblio.select("field[@name='200']/subfield[@name='a']").FirstContent

syntax == "unimarc" ? "u" : "s"

syntax == "unimarc" ? syntax = "test" : syntax = "tttttt"

syntax == "unimarc" ? biblio.select("field[@name='200']/subfield[@name='a']").FirstContent : biblio.select("field[@name='245']/subfield[@name='a']").FirstContent


R0000001  借 @refID:
===
册条码号为 '@refID:' 的册记录有 "100" 条，无法进行借阅操作。请在附加册记录路径后重新提交借阅操作。

~~~
7-5074-1125-7

7-02-003343-1


~~~
        static string[] froms = new string[] {
            "题名\ttitle",
            "著者\tauthor",
            "出版者\tpublisher",
            "出版日期\tpubdate",
            "主题词\tsubject",
            "关键词\tkeywords",
            "语言\tlanguage",
            "装订\tbinding",
            "ISBN\tISBN",
            "EISBN\tEISBN",
            "ASIN\tASIN"};


            string strFrom = this.GetFromRight();
            if (strFrom == "title")
            {
                matchs = new string[] {
            "默认\t[default]",
            "前方一致\t-begins",
            "单词前方一致\t-words-begin"};
            }
            else if (strFrom == "author")
            {
                matchs = new string[] {
            "默认\t[default]",
            "前方一致\t-begins",
            "精确一致\t-exact"};
            }
            else if (strFrom == "keywords")
            {
                matchs = new string[] {
            "默认\t[default]",
            "前方一致\t-begin"};
            }
            else if (strFrom == "subject")
            {
                matchs = new string[] {
            "默认\t[default]",
            "前方一致\t-begins",
            "单词前方一致\t-words-begin"};
            }
            else if (strFrom == "pubdate")
            {
                matchs = new string[] {
            "默认\t[default]",
            "以后\t:after",
            "正当\t:during"};
            }

            if (matchs == null)
            {
                matchs = new string[] {
            "默认\t[default]"};
            }


			~~~
			- <Item xmlns="http://webservices.amazon.com/AWSECommerceService/2011-08-01">
  <ASIN>B00116M5XM</ASIN> 
  <DetailPageURL>http://www.amazon.cn/%E5%93%88%E5%88%A9%E2%80%A2%E6%B3%A2%E7%89%B9%E4%B8%8E%E9%AD%94%E6%B3%95%E7%9F%B3-J-K-%E7%BD%97%E7%90%B3/dp/B00116M5XM?SubscriptionId=AKIAIFC2XER5NLNJ64CA&tag=digiplatcorp-20&linkCode=xm2&camp=2025&creative=165953&creativeASIN=B00116M5XM</DetailPageURL> 
  <SalesRank>1188</SalesRank> 
- <SmallImage>
  <URL>http://ec4.images-amazon.com/images/I/51Y3VohvJ8L._SL75_.jpg</URL> 
  <Height Units="pixels">75</Height> 
  <Width Units="pixels">53</Width> 
  </SmallImage>
- <MediumImage>
  <URL>http://ec4.images-amazon.com/images/I/51Y3VohvJ8L._SL160_.jpg</URL> 
  <Height Units="pixels">160</Height> 
  <Width Units="pixels">112</Width> 
  </MediumImage>
- <LargeImage>
  <URL>http://ec4.images-amazon.com/images/I/51Y3VohvJ8L.jpg</URL> 
  <Height Units="pixels">500</Height> 
  <Width Units="pixels">350</Width> 
  </LargeImage>
- <ImageSets>
- <ImageSet Category="primary">
- <SwatchImage>
  <URL>http://ec4.images-amazon.com/images/I/51Y3VohvJ8L._SL30_.jpg</URL> 
  <Height Units="pixels">30</Height> 
  <Width Units="pixels">21</Width> 
  </SwatchImage>
- <SmallImage>
  <URL>http://ec4.images-amazon.com/images/I/51Y3VohvJ8L._SL75_.jpg</URL> 
  <Height Units="pixels">75</Height> 
  <Width Units="pixels">53</Width> 
  </SmallImage>
- <ThumbnailImage>
  <URL>http://ec4.images-amazon.com/images/I/51Y3VohvJ8L._SL75_.jpg</URL> 
  <Height Units="pixels">75</Height> 
  <Width Units="pixels">53</Width> 
  </ThumbnailImage>
- <TinyImage>
  <URL>http://ec4.images-amazon.com/images/I/51Y3VohvJ8L._SL110_.jpg</URL> 
  <Height Units="pixels">110</Height> 
  <Width Units="pixels">77</Width> 
  </TinyImage>
- <MediumImage>
  <URL>http://ec4.images-amazon.com/images/I/51Y3VohvJ8L._SL160_.jpg</URL> 
  <Height Units="pixels">160</Height> 
  <Width Units="pixels">112</Width> 
  </MediumImage>
- <LargeImage>
  <URL>http://ec4.images-amazon.com/images/I/51Y3VohvJ8L.jpg</URL> 
  <Height Units="pixels">500</Height> 
  <Width Units="pixels">350</Width> 
  </LargeImage>
  </ImageSet>
  </ImageSets>
- <ItemAttributes>
  <Author>J.K.罗琳 (J.K.Rowling)</Author> 
  <Binding>平装</Binding> 
  <Brand>人民文学</Brand> 
  <Creator Role="作者">J.K.罗琳 (J.K.Rowling)</Creator> 
  <Creator Role="译者">苏农</Creator> 
  <EAN>9787020033430</EAN> 
  <Edition>第1版</Edition> 
  <ISBN>7020033431</ISBN> 
  <Label>人民文学出版社</Label> 
- <Languages>
- <Language>
  <Name>chinese</Name> 
  <Type>published</Type> 
  </Language>
  </Languages>
- <ListPrice>
  <Amount>1950</Amount> 
  <CurrencyCode>CNY</CurrencyCode> 
  <FormattedPrice>￥ 19.50</FormattedPrice> 
  </ListPrice>
  <Manufacturer>人民文学出版社</Manufacturer> 
  <NumberOfItems>1</NumberOfItems> 
  <NumberOfPages>191</NumberOfPages> 
- <PackageDimensions>
  <Height Units="inches">0.47</Height> 
  <Length Units="inches">9.13</Length> 
  <Weight Units="pounds">0.62</Weight> 
  <Width Units="inches">6.54</Width> 
  </PackageDimensions>
  <ProductGroup>Book</ProductGroup> 
  <ProductTypeName>ABIS_BOOK</ProductTypeName> 
  <PublicationDate>2000-09-01</PublicationDate> 
  <Publisher>人民文学出版社</Publisher> 
  <Studio>人民文学出版社</Studio> 
  <Title>哈利•波特与魔法石</Title> 
  </ItemAttributes>
- <OfferSummary>
- <LowestNewPrice>
  <Amount>1073</Amount> 
  <CurrencyCode>CNY</CurrencyCode> 
  <FormattedPrice>￥ 10.73</FormattedPrice> 
  </LowestNewPrice>
  <TotalNew>12</TotalNew> 
  <TotalUsed>0</TotalUsed> 
  <TotalCollectible>0</TotalCollectible> 
  <TotalRefurbished>0</TotalRefurbished> 
  </OfferSummary>
- <Offers>
  <TotalOffers>1</TotalOffers> 
  <TotalOfferPages>1</TotalOfferPages> 
  <MoreOffersUrl>http://www.amazon.cn/gp/offer-listing/B00116M5XM?SubscriptionId=AKIAIFC2XER5NLNJ64CA&tag=digiplatcorp-20&linkCode=xm2&camp=2025&creative=165953&creativeASIN=B00116M5XM</MoreOffersUrl> 
- <Offer>
- <OfferAttributes>
  <Condition>New</Condition> 
  </OfferAttributes>
- <OfferListing>
  <OfferListingId>ZVALazrnnZanN1hQH04G1%2F%2BegfBdWzYnQj9b74xuk46Pl9TCjSxqrjJy7%2BPnRml4YHROFqscub6VlxzklcPWneXTVnwQBOTqy0UCW2hiN6XQgTkYxiAAjOJhQXHt9XzW</OfferListingId> 
- <Price>
  <Amount>1073</Amount> 
  <CurrencyCode>CNY</CurrencyCode> 
  <FormattedPrice>￥ 10.73</FormattedPrice> 
  </Price>
- <AmountSaved>
  <Amount>877</Amount> 
  <CurrencyCode>CNY</CurrencyCode> 
  <FormattedPrice>￥ 8.77</FormattedPrice> 
  </AmountSaved>
  <PercentageSaved>45</PercentageSaved> 
  <Availability>通常在 3 到 4 个工作日内发货</Availability> 
- <AvailabilityAttributes>
  <AvailabilityType>now</AvailabilityType> 
  <MinimumHours>72</MinimumHours> 
  <MaximumHours>96</MaximumHours> 
  </AvailabilityAttributes>
  <IsEligibleForSuperSaverShipping>0</IsEligibleForSuperSaverShipping> 
  </OfferListing>
  </Offer>
  </Offers>
- <CustomerReviews>
  <IFrameURL>http://www.amazon.cn/reviews/iframe?akid=AKIAIFC2XER5NLNJ64CA&alinkCode=xm2&asin=B00116M5XM&atag=digiplatcorp-20&exp=2014-10-08T08%3A44%3A13Z&v=2&sig=H7jV3LCWLxJK5GTXFS1Bb1FVJpiYvAza6IgGlGvwsWA%3D</IFrameURL> 
  <HasReviews>true</HasReviews> 
  </CustomerReviews>
- <EditorialReviews>
- <EditorialReview>
  <Source>内容简介</Source> 
  <Content>《哈利•波特与魔法石》内容简介：一岁的哈利•波特失去父母后，神秘地出现在姨夫姨母家的门前。从此，哈利在姨母家饱受欺凌，度过了十年极其痛苦的日子。 在姨母家，姨夫和姨母好似凶神恶煞，他们那混世魔王儿子达力：一个肥胖、娇惯、欺负人的大石头，更是经常对哈利拳脚相加。哈利的“房间”是位于楼梯口的一个又暗又小的碗橱。十年来，从来没有人为他过过生日。<br>但是，在哈利十一岁生日那一天，一切都发生了变化，信使猫头鹰带来了一封神秘的信：邀请哈利去一个他——以及所有读到哈利故事的人——会觉得永远难忘的、不可思议的地方——霍格袄茨魔法学校。<br>在魔法学校，哈利不仅找着了朋友，学会了空中飞行，骑着一把型号为光轮2000色飞天扫帚打魁地气球，还得到了一件隐形衣。他发现那里的一切——从上课到吃饭到睡觉都充满了魔力，但是一块魔石出现了，它与哈利的命运息息相关。</Content> 
  <IsLinkSuppressed>0</IsLinkSuppressed> 
  </EditorialReview>
  </EditorialReviews>
- <BrowseNodes>
- <BrowseNode>
  <BrowseNodeId>1341404071</BrowseNodeId> 
  <Name>65折封顶</Name> 
- <Ancestors>
- <BrowseNode>
  <BrowseNodeId>286874071</BrowseNodeId> 
  <Name>商品</Name> 
  <IsCategoryRoot>1</IsCategoryRoot> 
- <Ancestors>
- <BrowseNode>
  <BrowseNodeId>286873071</BrowseNodeId> 
  </BrowseNode>
  </Ancestors>
  </BrowseNode>
  </Ancestors>
  </BrowseNode>
- <BrowseNode>
  <BrowseNodeId>660493051</BrowseNodeId> 
  <Name>小说</Name> 
- <Ancestors>
- <BrowseNode>
  <BrowseNodeId>658735051</BrowseNodeId> 
  <Name>儿童文学</Name> 
- <Ancestors>
- <BrowseNode>
  <BrowseNodeId>658409051</BrowseNodeId> 
  <Name>少儿</Name> 
- <Ancestors>
- <BrowseNode>
  <BrowseNodeId>658391051</BrowseNodeId> 
  <Name>类别</Name> 
  <IsCategoryRoot>1</IsCategoryRoot> 
- <Ancestors>
- <BrowseNode>
  <BrowseNodeId>658390051</BrowseNodeId> 
  <Name>图书</Name> 
  </BrowseNode>
  </Ancestors>
  </BrowseNode>
  </Ancestors>
  </BrowseNode>
  </Ancestors>
  </BrowseNode>
  </Ancestors>
  </BrowseNode>
  </BrowseNodes>
  </Item>



~~~

7-5360-2703-6


90000001
90000010

~~~

00082163

00002591


KGDaVQdpyWjoLjNATeCUUVaWup8=

~~~
7-50741-1125-
这个不能命中


7-5360-2703-6
这个应当命中亚马逊

7-02-003343-1
可命中亚马逊

哈利· 波特与死亡圣器

7-5387-1628-9
可检索含有本地资源对象的封面

~~~

                    string strTempFilePath = this.MainForm.DataDir + "/~temp_obj";

                    byte[] baOutputTimeStamp = null;

                    // EnableControlsInLoading(true);

                    string strMetaData = "";
                    string strTempOutputPath = "";

                    lRet = this.Channel.GetRes(
                        stop,
                        strResPath,
                        strTempFilePath,
                        out strMetaData,
                        out baOutputTimeStamp,
                        out strTempOutputPath,
                        out strError);
                    if (lRet == -1)
                    {
                        strError = "下载资源文件失败，原因: " + strError;
                        throw new Exception(strError);
                        // return strError;
                    }

                    return strTempFilePath;



					~~~

					978-7-5462-0179-5

978-7-5324-7694-7


978-7-5391-8184-4

~~~
select distinct bibliorecpath from operlogitem where action = 'new' and bibliorecpath not in (select bibliorecpath from class_clc)

select distinct bibliorecpath from item where bibliorecpath not in (select bibliorecpath from class_hnb)


~~~
https://www.isbn-international.org/range_file_generation