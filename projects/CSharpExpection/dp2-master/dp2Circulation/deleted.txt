        // 提交所有保存请求
        // parameters:
        //      strStyle    风格。displaysuccess 显示最后的成功消息在框架窗口的状态条 verifydata 发送校验记录的消息(注意是否校验还要取决于配置状态)
        //                  searchdup 虽然对本函数没有作用，但是可以传递到下级函数SaveBiblioToDatabase()
        // return:
        //      -1  有错。此时不排除有些信息保存成功。
        //      0   成功。
        /// <summary>
        /// 全部保存
        /// </summary>
        /// <param name="strStyle">保存方式。由 displaysuccess / verifydata / searchdup 之一或者逗号间隔组合而成。displaysuccess 显示最后的成功消息在框架窗口的状态条; verifydata 保存成功后发送校验记录的消息(注意是否校验还要取决于配置状态); searchdup 保存成功后发送查重消息</param>
        /// <returns>-1: 有错。此时不排除有些信息保存成功。0: 成功。</returns>
        public int DoSaveAll(string strStyle = "displaysuccess,verifydata,searchdup")
        {
            bool bBiblioSaved = false;
            int nRet = 0;
            string strText = "";
            int nErrorCount = 0;

            bool bDisplaySuccess = StringUtil.IsInList("displaysuccess", strStyle);
            bool bVerifyData = StringUtil.IsInList("verifydata", strStyle);
            // bool bForceVerifyData = StringUtil.IsInList("forceverifydata", strStyle);

            bool bVerified = false;

            if (this.m_verifyViewer != null)
                this.m_verifyViewer.Clear();

            string strHtml = "";

            LibraryChannel channel = this.GetChannel();
            channel.Timeout = new TimeSpan(0, 5, 0);    // 保存大量册记录时可能会耗时长一点

            Progress.OnStop += new StopEventHandler(this.DoStop);
            Progress.Initial("正在保存记录 ...");
            Progress.BeginLoop();

            this.ShowMessage("正在保存记录 ...");
            try
            {
                if (this.BiblioChanged == true
                    || Global.IsAppendRecPath(this.BiblioRecPath) == true
                    || this.m_bDeletedMode == true /* 2011/11/8 */)
                {
                    // 2014/7/3
                    if (bVerifyData == true
    && this.ForceVerifyData == true)
                    {
                        GenerateDataEventArgs e1 = new GenerateDataEventArgs();
                        e1.FocusedControl = this.m_marcEditor;

                        // 0: 没有发现校验错误; 1: 发现校验警告; 2: 发现校验错误
                        nRet = this.VerifyData(this, e1, true);
                        if (nRet == 2)
                        {
                            MessageBox.Show(this, "MARC 记录经校验发现有错，被拒绝保存。请修改 MARC 记录后重新保存");
                            return -1;
                        }

                        bVerified = true;
                    }

                    // 保存书目记录到数据库
                    // return:
                    //      -1  出错
                    //      0   没有保存
                    //      1   已经保存
                    nRet = SaveBiblioToDatabase(
                        channel,
                        true,
                        out strHtml,
                        strStyle);
                    if (nRet == 1)
                    {
                        bBiblioSaved = true;
                        strText += "书目信息";
                    }
                    if (nRet == -1)
                    {
                        nErrorCount++;
                    }
                }

                bool bOrdersSaved = false;
                // 提交订购保存请求
                // return:
                //      -1  出错
                //      0   没有必要保存
                //      1   保存成功
                nRet = this.orderControl1.DoSaveItems(channel);
                if (nRet == 1)
                {
                    bOrdersSaved = true;
                    if (strText != "")
                        strText += " ";
                    strText += "采购信息";
                }
                if (nRet == -1)
                {
                    nErrorCount++;

                    // 2013/1/18
                    // 如果订购信息保存不成功，则不要继续保存后面的其他信息。这主要是为了订购验收环节考虑，避免在订购信息保存失败的情况下继续保存验收所创建的新的册信息
                    return -1;
                }

                bool bIssuesSaved = false;
                bool bIssueError = false;
                // 提交期保存请求
                // return:
                //      -1  出错
                //      0   没有必要保存
                //      1   保存成功
                nRet = this.issueControl1.DoSaveItems(channel);
                if (nRet == 1)
                {
                    bIssuesSaved = true;
                    if (strText != "")
                        strText += " ";
                    strText += "期信息";
                }
                if (nRet == -1)
                {
                    nErrorCount++;
                    bIssueError = true;

                    // 2013/1/18
                    // 如果期信息保存不成功，则不要继续保存后面的其他信息。这主要是为了期刊验收环节考虑，避免在期信息保存失败的情况下继续保存验收所创建的新的册信息
                    return -1;
                }

                bool bEntitiesSaved = false;

                // 注：在期刊记到后，如果期信息保存不成功，则不保存册信息。以免发生不一致
                if (bIssueError == false)
                {
                    // 提交实体保存请求
                    // return:
                    //      -1  出错
                    //      0   没有必要保存
                    //      1   保存成功
                    nRet = this.entityControl1.DoSaveItems(channel);
                    if (nRet == 1)
                    {
                        bEntitiesSaved = true;
                        if (strText != "")
                            strText += " ";
                        strText += "册信息";
                    }
                    if (nRet == -1)
                    {
                        nErrorCount++;
                    }
                }

                bool bCommentsSaved = false;
                // 提交评注保存请求
                // return:
                //      -1  出错
                //      0   没有必要保存
                //      1   保存成功
                nRet = this.commentControl1.DoSaveItems(channel);
                if (nRet == 1)
                {
                    bCommentsSaved = true;
                    if (strText != "")
                        strText += " ";
                    strText += "评注信息";
                }
                if (nRet == -1)
                {
                    nErrorCount++;
                }

                bool bObjectSaved = false;
                string strError = "";

                // 当允许编目功能的时候才能允许保存对象资源。否则会把书目记录摧毁为空记录
                if (this.Cataloging == true)
                {
                    // 提交对象保存请求
                    // return:
                    //		-1	error
                    //		>=0 实际上载的资源对象数
                    nRet = this.binaryResControl1.Save(
                        channel,
                        this.MainForm.ServerVersion,
                        out strError);
                    if (nRet == -1)
                    {
                        MessageBox.Show(this, "保存对象信息时出错: " + strError);
                        nErrorCount++;
                    }

                    if (nRet >= 1)
                    {
                        bObjectSaved = true;
                        if (strText != "")
                            strText += " ";
                        strText += "对象信息";

                        /*
                        string strSavedBiblioRecPath = this.BiblioRecPath;

                        // 刷新书目记录的时间戳
                        string strOutputBiblioRecPath = "";
                        string strXml = "";
                        nRet = LoadBiblioRecord(this.BiblioRecPath,
                            "",
                            false,
                            out strOutputBiblioRecPath,
                            out strXml,
                            out strError);
                        if (nRet == -1)
                        {
                            // 如果提取记录失败，并且原有书目记录路径被摧毁，需要恢复
                            if (String.IsNullOrEmpty(this.BiblioRecPath) == true)
                            {
                                this.BiblioRecPath = strSavedBiblioRecPath;
                            }

                            MessageBox.Show(this, strError + "\r\n\r\n注意：当前窗口内的书目记录时间戳可能没有正确刷新，这将导致后继的保存书目记录操作出现时间戳不匹配报错");
                            nErrorCount++;
                        }
                        */
                    }
                }

                if (string.IsNullOrEmpty(strHtml) == false)
                {
                    this.m_webExternalHost_biblio.SetHtmlString(strHtml,
    "entityform_biblio");
                }

                if (bDisplaySuccess == true)
                {
                    if (bEntitiesSaved == true
                        || bBiblioSaved == true
                        || bIssuesSaved == true
                        || bOrdersSaved == true
                        || bObjectSaved == true
                        || bCommentsSaved == true)
                        this.MainForm.StatusBarMessage = strText + " 保存 成功";
                }

                if (nErrorCount > 0)
                {
                    return -1;
                }

                // 保存成功后再校验 MARC 记录
                if (bVerifyData == true
                    && this.AutoVerifyData == true
                    && bVerified == false)
                {
                    // TODO: 注意中途关闭 EntityForm 会发生什么
                    API.PostMessage(this.Handle, WM_VERIFY_DATA, 0, 0);
                }

                return 0;
            }
            finally
            {
                if (nErrorCount == 0)
                    this.ShowMessage("记录保存成功", "green", true);
                else
                    this.ShowMessage("记录保存失败", "red", true);

                Progress.EndLoop();
                Progress.OnStop -= new StopEventHandler(this.DoStop);
                Progress.Initial("");

                this.ReturnChannel(channel);
            }
        }


		        // TODO: 有这样一种情况：虽然书目记录和下属的记录都不存在，但是窗口内容被改变了，已然不是以前的内容。如果这时保存记录，会有意外发生，例如本来就有的册信息被清空了。
        // 要想办法在这种情况下保持窗口内全部信息不变；或者，既然已经改变，索性把MARC窗内的记录全部清除，书目记录路径也清楚，避免误会
        // parameters:
        //      bWarningNotSave 是否警告尚未保存？如果==false，并且“自动保存”checkbox为true，会自动保存，不警告
        //      bSetFocus   装载完成后是否把焦点切换到MarcEditor上
        // return:
        //      -1  出错
        //      0   没有装载(例如发现窗口内的记录没有保存，出现警告对话框后，操作者选择了Cancel；或者“到头”“到尾”)
        //      1   成功装载
        //      2   通道被占用
        /// <summary>
        /// 装载记录
        /// </summary>
        /// <param name="strBiblioRecPath">书目记录路径</param>
        /// <param name="strPrevNextStyle">前后翻动风格</param>
        /// <param name="bCheckInUse">是否检查通道占用情况</param>
        /// <param name="bSetFocus">装载完成后是否把焦点切换到MarcEditor上</param>
        /// <param name="strTotalError">返回总的出错情况</param>
        /// <param name="bWarningNotSave">是否警告尚未保存？如果==false，并且“自动保存”checkbox为true，会自动保存，不警告</param>
        /// <returns>
        ///      -1  出错
        ///      0   没有装载(例如发现窗口内的记录没有保存，出现警告对话框后，操作者选择了Cancel；或者“到头”“到尾”)
        ///      1   成功装载
        ///      2   通道被占用
        /// </returns>
        public int LoadRecord(string strBiblioRecPath,
            string strPrevNextStyle,
            bool bCheckInUse,
            bool bSetFocus,
            out string strTotalError,
            bool bWarningNotSave = false)
        {
            strTotalError = "";

            if (Progress.IsInLoop == true && Progress.AllowNest == false)
            {
                strTotalError = "种册窗正在执行长操作。装载书目记录 "
                    + strBiblioRecPath
                    + (string.IsNullOrEmpty(strPrevNextStyle) == true ? "" : "|" + strPrevNextStyle)
                    + " 的操作被放弃。请稍后重试";
                return 2;
            }

            string strError = "";

            bool bMarcEditorContentChanged = false; // MARC编辑器内的内容可曾修改?
            bool bBiblioRecordExist = false;    // 书目记录是否存在?
            bool bSubrecordExist = false;   // 至少有一个从属的记录存在
            bool bSubrecordListCleared = false; // 子记录的list是否被清除了?

            string strOutputBiblioRecPath = "";

            if (this.EntitiesChanged == true
                || this.IssuesChanged == true
                || this.BiblioChanged == true
                || this.ObjectChanged == true
                || this.OrdersChanged == true
                || this.CommentsChanged == true)
            {
                // 2008/6/25 
                if (this.checkBox_autoSavePrev.Checked == true
                    && bWarningNotSave == false)
                {
                    int nRet = this.DoSaveAll();
                    if (nRet == -1)
                    {
                        // strTotalError = "当前记录尚未保存";  // 2014/7/8
                        return -1;
                    }
                }
                else
                {
                    // 警告尚未保存
                    DialogResult result = MessageBox.Show(this,
                        "当前窗口内有 " + GetCurrentChangedPartName() + " 被修改后尚未保存。若此时装载新内容，现有未保存信息将丢失。\r\n\r\n确实要装入新内容? ",
                        "EntityForm",
                        MessageBoxButtons.YesNo,
                        MessageBoxIcon.Question,
                        MessageBoxDefaultButton.Button2);
                    if (result == DialogResult.No)
                        return 0;
                }
            }

            LibraryChannel channel = this.GetChannel();
            TimeSpan old_timeout = channel.Timeout;
            channel.Timeout = new TimeSpan(0, 1, 0);    // 保存大量册记录时可能会耗时长一点

            string strMessage = "正在装载书目记录 " + strBiblioRecPath + " " + strPrevNextStyle + " ...";
            Progress.OnStop += new StopEventHandler(this.DoStop);
            Progress.Initial(strMessage);
            Progress.BeginLoop();

            this.ShowMessage(strMessage);

            EnableControls(false);
            try
            {
                // 2012/7/25 移动到这里
                // 因为 LoadBiblioRecord() 会导致填充AutoGen菜单
                this._genData.ClearViewer();

                if (this.m_commentViewer != null)
                    this.m_commentViewer.Clear();

                bool bLoadSubrecords = true;
                if (StringUtil.CompareVersion(this.MainForm.ServerVersion, "2.91") < 0)
                    bLoadSubrecords = false;


                string strXml = "";
                string strSubRecords = "";
                int nRet = this.LoadBiblioRecord(
                    channel,
                    strBiblioRecPath,
                    strPrevNextStyle,
                    false,
                    bLoadSubrecords,
                    out strOutputBiblioRecPath,
                    out strXml,
                    out strSubRecords,
                    out strError);
                if (nRet == -1)
                {
                    string strErrorText = "装载书目记录 '" + strBiblioRecPath + "' (style='" + strPrevNextStyle + "')时发生错误: " + strError;
#if NO
                            Global.SetHtmlString(this.webBrowser_biblioRecord,
                                strErrorText);
#endif
                    this.m_webExternalHost_biblio.SetHtmlString(strErrorText, "entityform_error");

                    // MessageBox.Show(this, strErrorText);
                    if (String.IsNullOrEmpty(strTotalError) == false)
                        strTotalError += "\r\n";
                    strTotalError += strErrorText;
                }
                else if (nRet == 0)
                {
                    bBiblioRecordExist = false;
                    // 虽然种记录不存在，但是也继续装载册记录
                    // return 0;

                    string strText = "";

                    // 在不是前后翻看记录的情况下，要清空MARC窗，避免误会
                    if (String.IsNullOrEmpty(strPrevNextStyle) == true)
                    {
                        strText = "书目记录 '" + strBiblioRecPath + "' 没有找到...";

                        // 清空MARC窗，避免误会
                        // this.m_marcEditor.Marc = "012345678901234567890123";
                        this.SetMarc("012345678901234567890123");
                        bMarcEditorContentChanged = true;

                        // 如果书目记录不存在，则沿用strBiblioRecPath的路径
                        if (String.IsNullOrEmpty(strOutputBiblioRecPath) == true)
                        {
                            strOutputBiblioRecPath = strBiblioRecPath;
                        }
                    }
                    else
                    {
                        if (strPrevNextStyle == "prev")
                            strText = "到头";
                        else if (strPrevNextStyle == "next")
                            strText = "到尾";

                        strText += "\r\n\r\n(窗口内的原记录没有被刷新)";

                        strOutputBiblioRecPath = "";    // 这时候继续装载下属记录也无法进行了，因为不知道书目记录的路径。TODO: 将来可以采用猜测法，把书目记录路径+1或者-1,直到遇到下一条记录
                        // MessageBox.Show(this, strText);

                        if (String.IsNullOrEmpty(strTotalError) == false)
                            strTotalError += "\r\n";
                        strTotalError += strText;

                        return 0;   // 2008/11/2 
                    }

                    // MessageBox.Show(this, strText);
                    if (String.IsNullOrEmpty(strTotalError) == false)
                        strTotalError += "\r\n";
                    strTotalError += strText;
                }
                else
                {
                    bBiblioRecordExist = true;
                }

                bool bError = false;

                // 注：当bBiblioRecordExist==true时，LoadBiblioRecord()函数中已经设好了书目记录路径

                strBiblioRecPath = null;    // 防止后面继续使用。因为prev/next风格时，strBiblioRecPath的路径并不是所获得的记录的路径

                // 清空4个下属记录的控件
                this.entityControl1.ClearItems();
                this.textBox_itemBarcode.Text = ""; // 2009/1/5 

                this.issueControl1.ClearItems();
                this.orderControl1.ClearItems();   // 2008/11/2 
                this.commentControl1.ClearItems();
                this.binaryResControl1.Clear(); // 2008/11/2 
                if (this.m_verifyViewer != null)
                    this.m_verifyViewer.Clear();
                /*
                if (this.m_genDataViewer != null)
                    this.m_genDataViewer.Clear();
                 * */

                bSubrecordListCleared = true;

                XmlDocument collection_dom = new XmlDocument();
                if (string.IsNullOrEmpty(strSubRecords) == false)
                    collection_dom.LoadXml(strSubRecords);

                if (String.IsNullOrEmpty(strOutputBiblioRecPath) == false)
                {
                    string strBiblioDbName = "";

                    /*
                    if (String.IsNullOrEmpty(strOutputBiblioRecPath) == false)
                        strBiblioDbName = Global.GetDbName(strOutputBiblioRecPath);
                    else
                    {
                        Debug.Assert(String.IsNullOrEmpty(strBiblioRecPath) == false, "");
                        strBiblioDbName = Global.GetDbName(strBiblioRecPath);
                    }
                     * */
                    strBiblioDbName = Global.GetDbName(strOutputBiblioRecPath);

                    // 接着装入相关的所有册
                    string strItemDbName = this.MainForm.GetItemDbName(strBiblioDbName);
                    if (String.IsNullOrEmpty(strItemDbName) == false) // 仅在当前书目库有对应的实体库时，才装入册记录
                    {
                        this.EnableItemsPage(true);

                        if (IsAccessDenied(collection_dom, "item"))
                            this.entityControl1.ErrorInfo = "权限不足，获取实体信息被拒绝";
                        else
                        {
                            nRet = this.entityControl1.LoadItemRecords(
                                channel,
                                strOutputBiblioRecPath,    // 2008/11/2 new changed
                                GetItems(collection_dom, "item"),
                                // this.DisplayOtherLibraryItem,
                                this.DisplayOtherLibraryItem == true ? "getotherlibraryitem" : "",
                                out strError);
                            if (nRet == -1)
                            {
                                strError = "装载册记录时出错: " + strError;
                                if (channel.ErrorCode == ErrorCode.AccessDenied)
                                {
                                    // 在 ListView 背景上显示报错信息，不要用 MessageBox 报错
                                    this.entityControl1.ErrorInfo = strError;
                                }
                                else
                                {
                                    // MessageBox.Show(this, strError);
                                    if (String.IsNullOrEmpty(strTotalError) == false)
                                        strTotalError += "\r\n";
                                    strTotalError += strError;

                                    bError = true;
                                    // return -1;
                                }
                            }

                            if (nRet == 1)
                                bSubrecordExist = true;
                        }
                    }
                    else
                    {
                        this.EnableItemsPage(false);
                    }

                    // 接着装入相关的所有期
                    string strIssueDbName = this.MainForm.GetIssueDbName(strBiblioDbName);
                    if (String.IsNullOrEmpty(strIssueDbName) == false) // 仅在当前书目库有对应的期库时，才装入期记录
                    {
                        this.EnableIssuesPage(true);

                        if (IsAccessDenied(collection_dom, "issue"))
                            this.issueControl1.ErrorInfo = "权限不足，获取期信息被拒绝";
                        else
                        {

                            nRet = this.issueControl1.LoadItemRecords(
                                channel,
                                strOutputBiblioRecPath,  // 2008/11/2 changed
                                GetItems(collection_dom, "issue"),
                                "",
                                out strError);
                            if (nRet == -1)
                            {
                                strError = "装载期记录时出错: " + strError;
                                if (channel.ErrorCode == ErrorCode.AccessDenied)
                                {
                                    // 在 ListView 背景上显示报错信息，不要用 MessageBox 报错
                                    this.issueControl1.ErrorInfo = strError;
                                }
                                else
                                {
                                    // MessageBox.Show(this, strError);
                                    if (String.IsNullOrEmpty(strTotalError) == false)
                                        strTotalError += "\r\n";
                                    strTotalError += strError;

                                    bError = true;
                                    // return -1;
                                }
                            }

                            if (nRet == 1)
                                bSubrecordExist = true;
                        }
                    }
                    else
                    {
                        this.EnableIssuesPage(false);
                    }

                    // 接着装入相关的所有订购信息
                    string strOrderDbName = this.MainForm.GetOrderDbName(strBiblioDbName);
                    if (String.IsNullOrEmpty(strOrderDbName) == false) // 仅在当前书目库有对应的采购库时，才装入采购记录
                    {
                        if (String.IsNullOrEmpty(strIssueDbName) == false)
                            this.orderControl1.SeriesMode = true;
                        else
                            this.orderControl1.SeriesMode = false;

                        this.EnableOrdersPage(true);

                        if (IsAccessDenied(collection_dom, "order"))
                            this.orderControl1.ErrorInfo = "权限不足，获取订购信息被拒绝";
                        else
                        {

                            nRet = this.orderControl1.LoadItemRecords(
                                channel,
                                strOutputBiblioRecPath,  // 2008/11/2 changed
                                GetItems(collection_dom, "order"),
                                "",
                                out strError);
                            if (nRet == -1)
                            {
                                strError = "装载订购记录时出错: " + strError;
                                if (channel.ErrorCode == ErrorCode.AccessDenied)
                                {
                                    // 在 ListView 背景上显示报错信息，不要用 MessageBox 报错
                                    this.orderControl1.ErrorInfo = strError;
                                }
                                else
                                {
                                    // MessageBox.Show(this, strError);
                                    if (String.IsNullOrEmpty(strTotalError) == false)
                                        strTotalError += "\r\n";
                                    strTotalError += strError;

                                    bError = true;
                                    // return -1;
                                }
                            }

                            if (nRet == 1)
                                bSubrecordExist = true;
                        }
                    }
                    else
                    {
                        this.EnableOrdersPage(false);
                    }

                    // 接着装入相关的所有评注信息
                    string strCommentDbName = this.MainForm.GetCommentDbName(strBiblioDbName);
                    if (String.IsNullOrEmpty(strCommentDbName) == false) // 仅在当前书目库有对应的采购库时，才装入采购记录
                    {
                        this.EnableCommentsPage(true);

                        if (IsAccessDenied(collection_dom, "comment"))
                            this.commentControl1.ErrorInfo = "权限不足，获取评注信息被拒绝";
                        else
                        {

                            nRet = this.commentControl1.LoadItemRecords(
                                channel,
                                strOutputBiblioRecPath,
                                GetItems(collection_dom, "comment"),
                                "",
                                out strError);
                            if (nRet == -1)
                            {
                                strError = "装载评注记录时出错: " + strError;
                                if (channel.ErrorCode == ErrorCode.AccessDenied)
                                {
                                    // 在 ListView 背景上显示报错信息，不要用 MessageBox 报错
                                    this.commentControl1.ErrorInfo = strError;
                                }
                                else
                                {
                                    if (String.IsNullOrEmpty(strTotalError) == false)
                                        strTotalError += "\r\n";
                                    strTotalError += strError;

                                    bError = true;
                                }
                            }

                            if (nRet == 1)
                                bSubrecordExist = true;
                        }
                    }
                    else
                    {
                        this.EnableCommentsPage(false);
                    }

                    // 接着装入对象资源
                    {
                        nRet = this.binaryResControl1.LoadObject(
                            channel,
                            strOutputBiblioRecPath,    // 2008/11/2 changed
                            strXml,
                            this.MainForm.ServerVersion,
                            out strError);
                        if (nRet == -1)
                        {
                            strError = "装载对象记录时出错: " + strError;

                            if (channel.ErrorCode == ErrorCode.AccessDenied)
                            {
                                // 在 ListView 背景上显示报错信息，不要用 MessageBox 报错
                                this.binaryResControl1.ErrorInfo = strError;
                            }
                            else
                            {
                                // MessageBox.Show(this, strError);
                                if (String.IsNullOrEmpty(strTotalError) == false)
                                    strTotalError += "\r\n";
                                strTotalError += strError;

                                bError = true;
                                // return -1;
                            }
                        }

                        if (nRet == 1)
                            bSubrecordExist = true;
                    }

                    // 装载书目和<dprms:file>以外的其它XML片断
                    if (string.IsNullOrEmpty(strXml) == false)
                    {
                        nRet = LoadXmlFragment(strXml,
                            out strError);
                        if (nRet == -1)
                        {
                            if (String.IsNullOrEmpty(strTotalError) == false)
                                strTotalError += "\r\n";
                            strTotalError += strError;

                            bError = true;
                        }
                    }
                } // end of if (String.IsNullOrEmpty(strOutputBiblioRecPath) == false)

                if (string.IsNullOrEmpty(this.m_strUsedActiveItemPage) == false)
                {
                    // 只要有实体库，即便当前书目记录没有下属的实体记录，也要显示册listview page
                    if (LoadActiveItemIssuePage(m_strUsedActiveItemPage) == true)
                        this.m_strUsedActiveItemPage = "";
                }

                if (bBiblioRecordExist == false && bSubrecordExist == true)
                    this.BiblioRecPath = strOutputBiblioRecPath;

                if (bBiblioRecordExist == false
                    && bSubrecordExist == false
                    && bSubrecordListCleared == true)
                {
                    if (bMarcEditorContentChanged == false)
                    {
                        this.m_marcEditor.Marc = "012345678901234567890123";
                        this.SetMarc("012345678901234567890123");
                        bMarcEditorContentChanged = true;
                    }

                    if (this.DeletedMode == false)
                        this.BiblioRecPath = "";    // 避免残余记录覆盖了不该覆盖的记录
                }

                // 2008/11/2 
                if (bMarcEditorContentChanged == true)
                    this.BiblioChanged = false; // 避免后面自动保存时错误覆盖了不该覆盖的记录

                // 2008/9/16 
                this.DeletedMode = false;

                if (bError == true)
                    return -1;

                // 2013/11/13
                if (bBiblioRecordExist == false
&& bSubrecordExist == false
&& bSubrecordListCleared == true)
                    return -1;

                // 2008/11/26 
                if (m_strFocusedPart == "marceditor"
                    && bSetFocus == true)
                {
                    SwitchFocus(MARC_EDITOR);
                }

                DoViewComment(false);
                return 1;
            }
            finally
            {
                EnableControls(true);

                Progress.EndLoop();
                Progress.OnStop -= new StopEventHandler(this.DoStop);
                Progress.Initial("");

                channel.Timeout = old_timeout;
                this.ReturnChannel(channel);

                // this.m_nChannelInUse--;
                this.ClearMessage();
            }
        }


		        // 移动书目记录
        private void toolStripButton_marcEditor_moveTo_Click(object sender, EventArgs e)
        {
            string strError = "";
            int nRet = 0;

            if (StringUtil.CompareVersion(this.MainForm.ServerVersion, "2.95") < 0)   // "2.39"
            {
                strError = "本功能需要配合 dp2library 2.95 或以上版本才能使用";
                goto ERROR1;
            }

            string strTargetRecPath = this.m_marcEditor.Record.Fields.GetFirstSubfield("998", "t");
            if (string.IsNullOrEmpty(strTargetRecPath) == false)
            {
                DialogResult result = MessageBox.Show(this,
    "当前窗口内的记录原本是从 '" + strTargetRecPath + "' 复制过来的。是否要移动回原有位置？\r\n\r\nYes: 是; No: 否，继续进行普通移动操作; Cancel: 放弃本次操作",
    "EntityForm",
    MessageBoxButtons.YesNoCancel,
    MessageBoxIcon.Question,
    MessageBoxDefaultButton.Button1);
                if (result == System.Windows.Forms.DialogResult.Cancel)
                    return;
                if (result == System.Windows.Forms.DialogResult.Yes)
                {
                    // strTargetRecPath会发生作用
                }

                if (result == System.Windows.Forms.DialogResult.No)
                {
                    strTargetRecPath = "";
                }
            }

            // 源记录就是 ？
            if (Global.IsAppendRecPath(this.BiblioRecPath) == true)
            {
                strError = "源记录尚未建立，无法执行移动操作";
                goto ERROR1;
            }

            // string strMergeStyle = "";
            MergeStyle merge_style = MergeStyle.CombineSubrecord | MergeStyle.ReserveSourceBiblio;

            BiblioSaveToDlg dlg = new BiblioSaveToDlg();
            MainForm.SetControlFont(dlg, this.Font, false);

            dlg.Text = "移动书目记录到 ...";
            dlg.MainForm = this.MainForm;
            if (string.IsNullOrEmpty(strTargetRecPath) == false)
                dlg.RecPath = strTargetRecPath;
            else
            {
                dlg.RecPath = this.MainForm.AppInfo.GetString(
                    "entity_form",
                    "move_to_used_path",
                    this.BiblioRecPath);
                dlg.RecID = "?";
            }

            dlg.MessageText = "将当前窗口中的书目记录 " + this.BiblioRecPath + " (连同下属的册、期、订购、实体记录和对象资源)移动到:";
            dlg.CopyChildRecords = true;
            dlg.EnableCopyChildRecords = false;

            dlg.BuildLink = false;

            {
                string strMarcSyntax = this.GetCurrentMarcSyntax();
                if (string.IsNullOrEmpty(strMarcSyntax) == true)
                    strMarcSyntax = this.MarcSyntax;    // 外来数据的 MARC 格式

                dlg.MarcSyntax = strMarcSyntax;
            }

            // dlg.CurrentBiblioRecPath = this.BiblioRecPath;
            this.MainForm.AppInfo.LinkFormState(dlg, "entityform_BiblioMoveToDlg_state");
            dlg.ShowDialog(this);
            // this.MainForm.AppInfo.UnlinkFormState(dlg);

            if (dlg.DialogResult != DialogResult.OK)
                return;

            if (this.BiblioRecPath == dlg.RecPath)
            {
                strError = "要移动到的位置 '" + dlg.RecPath + "' 和当前记录本来的位置 '" + this.BiblioRecPath + "' 相同，移动操作被拒绝。若确实要这样保存记录，请直接使用保存功能。";
                goto ERROR1;
            }

            this.MainForm.AppInfo.SetString(
    "entity_form",
    "move_to_used_path",
    dlg.RecPath);

            {
                // 如果当前记录没有保存，则先保存
                if (//this.EntitiesChanged == true
                    //|| this.IssuesChanged == true
                    //|| this.BiblioChanged == true
        this.ObjectChanged == true
                    //|| this.OrdersChanged == true
                    //|| this.CommentsChanged == true
                )
                {
                    // 警告尚未保存
                    DialogResult result = MessageBox.Show(this,
                        "当前窗口内有 " + GetCurrentChangedPartName() + " 被修改后尚未保存。移动操作前必须先保存当前记录。\r\n\r\n请问要立即保存么？\r\n\r\n(OK: 保存; Cancel: 放弃本次移动操作)",
                        "EntityForm",
                        MessageBoxButtons.OKCancel,
                        MessageBoxIcon.Question,
                        MessageBoxDefaultButton.Button2);
                    if (result == DialogResult.OK)
                    {
                        // 提交所有保存请求
                        // return:
                        //      -1  有错。此时不排除有些信息保存成功。
                        //      0   成功。
                        nRet = DoSaveAll();
                        if (nRet == -1 || nRet == -2)
                        {
                            strError = "因为保存操作出错，所以后续的移动操作被放弃";
                            goto ERROR1;
                        }
                    }
                    else
                    {
                        strError = "移动操作被放弃";
                        goto ERROR1;
                    }
                }
            }

            // 看看要另存的位置，记录是否已经存在?
            if (dlg.RecID != "?")
            {
                byte[] timestamp = null;

                // 检测特定位置书目记录是否已经存在
                // parameters:
                // return:
                //      -1  error
                //      0   not found
                //      1   found
                nRet = DetectBiblioRecord(dlg.RecPath,
                    out timestamp,
                    out strError);
                if (nRet == 1)
                {
                    //bool bOverwrite = false;
                    if (dlg.RecPath != strTargetRecPath)    // 移动回998$t情况就不询问是否覆盖了，直接选用归并方式
                    {
#if NO
                        // TODO: 用专用对话框实现
                        // 提醒覆盖？
                        DialogResult result = MessageBox.Show(this,
                            "目标书目记录 " + dlg.RecPath + " 已经存在。\r\n\r\n要用当前窗口中的书目记录(连同数字对象和下属的子记录)覆盖此记录，还是归并到此记录? \r\n\r\nYes: 覆盖; No: 归并; Cancel: 放弃本次移动操作",
                            "EntityForm",
                            MessageBoxButtons.YesNoCancel,
                            MessageBoxIcon.Question,
                            MessageBoxDefaultButton.Button2);
                        if (result == DialogResult.Cancel)
                            return;
                        if (result == System.Windows.Forms.DialogResult.Yes)
                            bOverwrite = true;
                        else
                            bOverwrite = false;
#endif
                        GetMergeStyleDialog merge_dlg = new GetMergeStyleDialog();
                        MainForm.SetControlFont(merge_dlg, this.Font, false);
                        merge_dlg.SourceRecPath = this.BiblioRecPath;
                        merge_dlg.TargetRecPath = dlg.RecPath;
                        merge_dlg.MessageText = "目标书目记录 " + dlg.RecPath + " 已经存在。\r\n\r\n请指定当前窗口中的书目记录(源)和此目标记录合并的方法";

                        merge_dlg.UiState = this.MainForm.AppInfo.GetString(
        "entity_form",
        "GetMergeStyleDialog_uiState",
        "");
                        this.MainForm.AppInfo.LinkFormState(merge_dlg, "entityform_GetMergeStyleDialog_state");
                        merge_dlg.ShowDialog(this);
                        this.MainForm.AppInfo.UnlinkFormState(merge_dlg);
                        this.MainForm.AppInfo.SetString(
"entity_form",
"GetMergeStyleDialog_uiState",
merge_dlg.UiState);

                        if (merge_dlg.DialogResult == System.Windows.Forms.DialogResult.Cancel)
                            return;

                        merge_style = merge_dlg.GetMergeStyle();
                    }

                    // this.BiblioTimestamp = timestamp;   // 为了顺利覆盖

                    // TODO: 预先检查操作者权限，确保删除书目记录和下级记录都能成功，否则就警告

#if NO
                    if (bOverwrite == true)
                    {
                        // 删除目标位置的书目记录
                        // 如果为归并模式，则保留其下属的实体等记录
                        nRet = DeleteBiblioRecordFromDatabase(dlg.RecPath,
                            bOverwrite == true ? "delete" : "onlydeletebiblio",
                            timestamp,
                            out strError);
                        if (nRet == -1)
                            goto ERROR1;
                    }
#endif
                    if ((merge_style & MergeStyle.OverwriteSubrecord) != 0)
                    {
                        // 删除目标记录整个，或者删除目标位置的下级记录
                        // TODO: 测试的时候，注意不用下述调用而测试保留目标书目记录中对象的可能性
                        nRet = DeleteBiblioRecordFromDatabase(dlg.RecPath,
                            (merge_style & MergeStyle.ReserveSourceBiblio) != 0 ? "delete" : "onlydeletesubrecord",
                            timestamp,
                            out strError);
                        if (nRet == -1)
                        {
                            if ((merge_style & MergeStyle.ReserveSourceBiblio) != 0)
                                strError = "删除目标位置的书目记录 '" + dlg.RecPath + "' 时出错: " + strError;
                            else
                                strError = "删除目标位置的书目记录 '" + dlg.RecPath + "' 的全部子记录时出错: " + strError;
                            goto ERROR1;
                        }
                    }
                }
            }

            string strOutputBiblioRecPath = "";
            byte[] baOutputTimestamp = null;
            string strXml = "";

            string strOldBiblioRecPath = this.BiblioRecPath;
            string strOldMarc = this.GetMarc(); //  this.m_marcEditor.Marc;
            bool bOldChanged = this.GetMarcChanged();   // this.m_marcEditor.Changed;
            bool bSucceed = false;

            this.EnableControls(false);

            LibraryChannel channel = this.GetChannel();
            TimeSpan old_timeout = channel.Timeout;
            channel.Timeout = new TimeSpan(0, 2, 0);    // 查重和复制一般都需要较长时间

            try
            {
                // 保存原来的记录路径
                bool bOldReadOnly = this.m_marcEditor.ReadOnly;
                Field old_998 = null;

                string strDlgTargetDbName = Global.GetDbName(dlg.RecPath);
                string str998TargetDbName = Global.GetDbName(strTargetRecPath);

                // 如果移动目标和strTargetRecPath同数据库，则要去掉记录中可能存在的998$t
                if (strDlgTargetDbName == str998TargetDbName)
                {
                    // 保存当前记录的998字段
                    old_998 = this.m_marcEditor.Record.Fields.GetOneField("998", 0);

                    // 清除可能存在的998$t
                    if (old_998 != null)
                    {
                        SubfieldCollection subfields = old_998.Subfields;
                        Subfield old_t = subfields["t"];
                        if (old_t != null)
                        {
                            old_998.Subfields = subfields.Remove(old_t);
                            // 如果998内一个子字段也没有了，是否这个字段要删除?
                        }
                        else
                            old_998 = null; // 表示(既然没有删除$t，就)不用恢复
                    }
                }

                string strMergeStyle = "";
                if ((merge_style & MergeStyle.ReserveSourceBiblio) != 0)
                    strMergeStyle = "reserve_source";
                else
                    strMergeStyle = "reserve_target";

                if ((merge_style & MergeStyle.MissingSourceSubrecord) != 0)
                    strMergeStyle += ",missing_source_subrecord";
                else if ((merge_style & MergeStyle.OverwriteSubrecord) != 0)
                {
                    // dp2library 尚未实现这个功能，不过本函数前面已经用 SetBiblioInfo() API 主动删除了目标位置下属的子记录，效果是一样的。(当然，这样实现起来原子性不是那么好)
                    // strMergeStyle += ",overwrite_target_subrecord";
                }
                // combine 情况时缺省的，不用声明

                SavedInfo info = new SavedInfo();

                nRet = CopyBiblio(
                    channel,
                    "move",
                    dlg.RecPath,
                    strMergeStyle,
                    out strXml,
                    out strOutputBiblioRecPath,
                    out baOutputTimestamp,
                    out strError);
#if NO
                if (nRet == -1)
                    MessageBox.Show(this, strError);
#endif
                if (nRet == 0)
                {
                    info.bBiblioSaved = true;
                    info.SavedNames.Add("书目信息");
                    this.BiblioChanged = false;
                    this.BiblioRecPath = strOutputBiblioRecPath;
                    this.BiblioTimestamp = baOutputTimestamp;
                    bSucceed = true;
                }
                if (nRet == -1)
                {
                    info.ErrorCount++;
                    goto ERROR1; // 书目记录若保存不成功，后继的实体记录保存就没法定位正确的书目记录路径
                }

                {
                    /// 
                    LoadSubRecordsInfo load_info = new LoadSubRecordsInfo();

                    if (String.IsNullOrEmpty(strOutputBiblioRecPath) == false)
                    {
                        // 装载下级记录，为保存下级记录的修改做准备
                        nRet = LoadSubRecords(
                            channel,
                            strOutputBiblioRecPath,
                            null,   // strXml, // 书目记录 XML
                            "", // strSubRecords,
                            load_info,
                            true,
                            out strError);
                        if (nRet == -1)
                            goto ERROR1;
                        // TODO: load_info.ErrorCount ?
                    }

                    nRet = SaveSubRecords(channel,
                        info,
                        strOutputBiblioRecPath,
                        out strError);
                    if (nRet == -1)
                        return;
                }
            }
            finally
            {
                channel.Timeout = old_timeout;
                this.ReturnChannel(channel);

                this.EnableControls(true);

#if NO
                // 复原当前窗口的记录
                if (this.m_marcEditor.Marc != strOldMarc)
                    this.m_marcEditor.Marc = strOldMarc;
                if (this.m_marcEditor.Changed != bOldChanged)
                    this.m_marcEditor.Changed = bOldChanged;
#endif
                if (bSucceed == false)
                {
                    if (this.GetMarc() /*this.m_marcEditor.Marc*/ != strOldMarc)
                    {
                        // this.m_marcEditor.Marc = strOldMarc;
                        this.SetMarc(strOldMarc);
                    }
                    if (this.GetMarcChanged() /*this.m_marcEditor.Changed*/ != bOldChanged)
                    {
                        // this.m_marcEditor.Changed = bOldChanged;
                        this.SetMarcChanged(bOldChanged);
                    }
                    this.BiblioRecPath = strOldBiblioRecPath;
                }
            }

#if NO
            // 将目标记录装入当前窗口
            this.LoadRecordOld(strOutputBiblioRecPath, "", false);
#endif
            return;
        ERROR1:
            MessageBox.Show(this, strError);
        }


		~~~~~~~~~~~~~~~~~

		        void FillItems(List<BiblioStore> items)
        {
            this.ClearMessage();

            StringBuilder text = new StringBuilder();

            string strBinDir = Environment.CurrentDirectory;

            string strCssUrl = Path.Combine(this.MainForm.DataDir, "Order\\BatchOrder.css");
            string strSummaryJs = Path.Combine(this.MainForm.DataDir, "Order\\BatchOrder.js");
            string strLink = "<link href='" + strCssUrl + "' type='text/css' rel='stylesheet' />";
            string strScriptHead = "<script type=\"text/javascript\" src=\"%bindir%/jquery/js/jquery-1.4.4.min.js\"></script>"
                + "<script type=\"text/javascript\" src=\"%bindir%/jquery/js/jquery-ui-1.8.7.min.js\"></script>"
                + "<script type='text/javascript' charset='UTF-8' src='" + strSummaryJs + "'></script>";
            // string strStyle = "<link href=\"%bindir%/select2/select2.min.css\" rel=\"stylesheet\" />" +
            // "<script src=\"%bindir%/select2/select2.min.js\"></script>";
            text.Append("<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\"><html xmlns=\"http://www.w3.org/1999/xhtml\"><head>"
                + strLink
                + strScriptHead.Replace("%bindir%", strBinDir)
                // + strStyle.Replace("%bindir%", strBinDir)
                + "</head><body>");

            AppendHtml(text.ToString(), false);
            text.Clear();

            int nStart = 0;
            foreach (BiblioStore item in items)
            {
                // Application.DoEvents();

                text.Append("\r\n<" + TABLE + " class=''>");

                text.Append("\r\n\t<" + TR + " class='check' biblio-recpath='" + item.RecPath + "' " + strOnClick + ">");
                text.Append("\r\n\t\t<" + TD + " class='biblio-index'><div>" + (nStart + 1).ToString() + "</div></" + TD + ">");
                text.Append("\r\n\t\t<" + TD + " class='nowrap' colspan='10'>"
                    + "<div class='biblio-head'>" + HttpUtility.HtmlEncode(item.RecPath) + "</div>"
                    + "<div class='biblio-table-container'>" + BuildBiblioHtml(item.RecPath, item.Xml) + "</div>"
                    + "</" + TD + ">");

                text.Append("\r\n\t</" + TR + ">");

                if (item.Orders.Count > 0)
                {
                    text.Append(GetOrderTitleLine());
                    int i = 0;
                    foreach (OrderStore order in item.Orders)
                    {
                        text.Append(BuildOrderHtml(item.RecPath, order, i, null));

                        i++;
                    }
                }

                nStart++;
                text.Append("\r\n</" + TABLE + ">");

                AppendHtml(text.ToString(), false);
                text.Clear();
            }
            text.Append("</body></html>");

            AppendHtml(text.ToString(), false);
            text.Clear();
#if NO
            Global.SetHtmlString(this.webBrowser1,
    text.ToString(),
    Program.MainForm.DataDir,
    "bo_");
#endif
        }


		~~~~~~~~~~~~~~~

		        internal void DoPrintPage(
            IWin32Window owner,
            LabelParam label_param,
            string strStyle,
            PrintPageEventArgs e)
        {
            string strError = "";
            int nRet = 0;

            if (e.Cancel == true)
                return;

            bool bTestingGrid = false;
            if (StringUtil.IsInList("TestingGrid", strStyle) == true)
                bTestingGrid = true;


            int nYCount = 0;
            int nXCount = 0;

            double PageWidth = label_param.PageWidth;
            double PageHeight = label_param.PageHeight;
#if NO
            if (label_param.Landscape == true)
            {
                double nTemp = PageHeight;
                PageHeight = PageWidth;
                PageWidth = nTemp;
            }
#endif
#if NO
            if (e.PageSettings.Landscape == true)
            {
                double nTemp = PageHeight;
                PageHeight = PageWidth;
                PageWidth = nTemp;
            }
#endif

            int nPageWidth = e.PageBounds.Width;    // PageBounds 中已经是按照 Landscape 处理过的方向了
            if (PageWidth != 0)
                nPageWidth = (int)PageWidth;

            int nPageHeight = e.PageBounds.Height;
            if (PageHeight != 0)
                nPageHeight = (int)PageHeight;

            DecimalPadding PageMargins = RotatePadding(label_param.PageMargins,
                e.PageSettings.Landscape);  // label_param.Landscape
#if NO
            // 垂直方向的个数
            nYCount = (e.PageBounds.Height - label_param.PageMargins.Top - label_param.PageMargins.Bottom)
                / label_param.Height;
            // 水平方向的个数
            nXCount = (e.PageBounds.Width - label_param.PageMargins.Left - label_param.PageMargins.Right)
            / label_param.Width;
#endif
            // 垂直方向的个数
            nYCount = (int)
                (
                (double)(nPageHeight - PageMargins.Top - PageMargins.Bottom)
                / (double)label_param.LabelHeight
                );
            // 水平方向的个数
            nXCount = (int)
                (
                (double)(nPageWidth - PageMargins.Left - PageMargins.Right)
                / (double)label_param.LabelWidth
                );

            int from = 0;
            int to = 0;
            bool bOutput = true;
            // 如果 e.PageSettings.PrinterSettings.FromPage == 0，会被当作打印第一页
            if (e.PageSettings.PrinterSettings.PrintRange == PrintRange.SomePages
                && e.PageSettings.PrinterSettings.FromPage >= 1)
            {
                from = e.PageSettings.PrinterSettings.FromPage;
                to = e.PageSettings.PrinterSettings.ToPage;

                // 交换，保证from为小
                if (from > to)
                {
                    int temp = to;
                    to = from;
                    from = temp;
                }

                if (this.m_nPageNo == 0)
                {
                    this.m_nPageNo = from;

                    Debug.Assert(this.m_nPageNo >= 1, "");
                    long nLabelCount = (nXCount * nYCount) * (this.m_nPageNo - 1);

                    // 从文件中跳过这么多label的内容行
                    for (int i = 0; i < nLabelCount; i++)
                    {
                        List<string> lines = null;
                        nRet = this.GetLabelLines(out lines,
                            out strError);
                        if (nRet == -1)
                            goto ERROR1;

                        if (nRet == 1)
                        {
                            e.Cancel = true;
                            return;
                        }
                    }
                }

                /*
                if (this.m_nPageNo >= from
                    && this.m_nPageNo <= to)
                {
                    bOutput = true;
                }
                else
                {
                    bOutput = false;
                }
                 * */
            }
            else
            {
                if (this.m_nPageNo == 0)
                    this.m_nPageNo = 1; // 一般性的初始化
            }


            // 加快运行速度
            float nXDelta = e.PageSettings.PrintableArea.Left;
            float nYDelta = e.PageSettings.PrintableArea.Top;

            /*
            if (this.PrintController.IsPreview == true)
            {
                nXDelta = 0;
                nYDelta = 0;
            }
             * */

            if (this.OriginAtMargins == true
                || this.PreviewMode == true)   // false
            {
                // true 如果图形起始于页面边距。否则起始于可打印区域
                nXDelta = 0;
                nYDelta = 0;
            }

            if (this.OriginPoint != null)
            {
                nXDelta -= this.OriginPoint.X;
                nYDelta -= this.OriginPoint.Y;
            }

#if NO
            float nPrintableWidth = e.PageSettings.PrintableArea.Width;
            float nPrintableHeight = e.PageSettings.PrintableArea.Height;
#endif


            if (this.IsDesignMode)
            {
                // 绘制整个纸张背景 白色
                using (Brush brushBack = new SolidBrush(Color.White))
                {
                    RectangleF rectPaper = new RectangleF(0 + 1 - nXDelta,
                        0 + 1 - nYDelta,
                        e.PageBounds.Width - 2,
                        e.PageBounds.Height - 2);
                    e.Graphics.FillRectangle(brushBack, rectPaper);
                }
            }

            // 绘制可打印区域
            // 鲜红色
            if (bTestingGrid == true && bOutput == true)
            {
                float nXOffs = 0;
                float nYOffs = 0;

                // 如果为正式打印，左上角(0,0)已经就是可以打印区域的左上角
                // 如果为preview模式，则左上角要向右向下移动，才能模拟出显示效果

#if NO
                if (this.OriginAtMargins == true
                    || this.PreviewMode == true)
                {
                    nXOffs = e.PageSettings.PrintableArea.Left;
                    nYOffs = e.PageSettings.PrintableArea.Top;
                }
#endif


                if (this.OriginPoint != null)
                {
                    nXOffs += this.OriginPoint.X;
                    nYOffs += this.OriginPoint.Y;
                }

                RectangleF rect = RotateRectangle(e.PageSettings.PrintableArea,
                    e.PageSettings.Landscape);  // label_param.Landscape

                if (this.OriginAtMargins == true
    || this.PreviewMode == true)
                {
                }
                else
                {
                    rect.X = 0;
                    rect.Y = 0;
                }

                rect.Offset(nXOffs, nYOffs);

                using (Pen pen = new Pen(Color.Red, (float)1))
                {
                    DrawFourAngel(
    e.Graphics,
    pen,
    rect,
    50);    // 半英寸
                }
            }

            // 加入变换
            e.Graphics.TranslateTransform(-nXDelta, -nYDelta);
            nXDelta = 0;
            nYDelta = 0;

            if (label_param.RotateDegree != 0)
            {
                float x_offs, y_offs;
                CenterMove(label_param.RotateDegree,
            (float)label_param.PageWidth,  // e.PageBounds.Width,
            (float)label_param.PageHeight, // e.PageBounds.Height,
            out x_offs,
            out y_offs);
                e.Graphics.TranslateTransform(x_offs, y_offs);
                e.Graphics.RotateTransform((float)label_param.RotateDegree);
            }

            if (this.IsDesignMode)
            {
                // 绘制配置文件的页面区域
                if (PageHeight > 0 && PageWidth > 0)
                {
                    using (Brush brushBack = new SolidBrush(Color.FromArgb(128, Color.LightYellow)))
                    {
                        RectangleF rectPaper = new RectangleF(0 - nXDelta,
                            0 - nYDelta,
                            (float)PageWidth,
                            (float)PageHeight);
                        e.Graphics.FillRectangle(brushBack, rectPaper);
                    }
                }
            }

            // 绘制内容区域边界(也就是排除了页面边空的中间部分)
            // 淡绿色
            if (bTestingGrid == true && bOutput == true)
            {
                using (Pen pen = new Pen(Color.FromArgb(0, 100, 0), (float)2)) // 3
                {

#if NO
                e.Graphics.DrawRectangle(pen,
                    PageMargins.Left - nXDelta,
                    PageMargins.Top - nYDelta,
                    e.PageBounds.Width - PageMargins.Left - PageMargins.Right,
                    e.PageBounds.Height - PageMargins.Top - PageMargins.Bottom);
#endif
                    e.Graphics.DrawRectangle(pen,
        (float)PageMargins.Left - nXDelta,
        (float)PageMargins.Top - nYDelta,
        (float)nPageWidth - (float)PageMargins.Left - (float)PageMargins.Right,
        (float)nPageHeight - (float)PageMargins.Top - (float)PageMargins.Bottom);

                }
            }

            bool bEOF = false;

            float y = (float)PageMargins.Top;
            // 每一行的循环
            for (int i = 0; i < nYCount; i++)
            {
                bool bDisplay = true;
                if (this.IsDesignMode == true)
                {
                    RectangleF rectLine = new RectangleF(
    (float)0 - nXDelta,
    (float)y - nYDelta,
    (float)label_param.LabelWidth * nXCount,
    (float)label_param.LabelHeight);
                    if (rectLine.Top > e.Graphics.ClipBounds.Bottom)
                    {
                        // Debug.WriteLine("break line loop at " + i.ToString());
                        break;  // 当前行在剪裁区域的下方，可以中断循环了
                    }
                    if (rectLine.IntersectsWith(e.Graphics.ClipBounds) == false)
                    {
                        // Debug.WriteLine("skip line " + i.ToString());
                        bDisplay = false;
                    }
                }
                float x = (float)PageMargins.Left;
                // 每一列的循环
                for (int j = 0; j < nXCount; j++)
                {
                    List<string> lines = null;
                    nRet = this.GetLabelLines(out lines,
                        out strError);
                    if (nRet == -1)
                        goto ERROR1;

                    if (nRet == 1)
                        bEOF = true;

                    if (bOutput == true && bDisplay == true)
                    {
                        // 标签
                        RectangleF rectLabel = new RectangleF(
    (float)x - nXDelta,
    (float)y - nYDelta,
    (float)label_param.LabelWidth,
    (float)label_param.LabelHeight);

                        if (rectLabel.Left > e.Graphics.ClipBounds.Right)
                        {
                            // Debug.WriteLine("break label loop at i=" + i.ToString() + " j=" + j.ToString());
                            // 当前标签在剪裁区域的右方，可以不要显示后面的标签了
                            bDisplay = false;
                        }

                        if (this.IsDesignMode == false
                            || rectLabel.IntersectsWith(e.Graphics.ClipBounds) == true)
                        {
                            // Debug.WriteLine("i="+i.ToString()+" j="+j.ToString()+" rectLabel = "+rectLabel.ToString()+", clipbounds " + e.Graphics.ClipBounds.ToString());
                            // 标签内容区域
                            RectangleF rectContent = new RectangleF(
                                    (float)x + (float)label_param.LabelPaddings.Left - nXDelta,
                                    (float)y + (float)label_param.LabelPaddings.Top - nYDelta,
                                    (float)label_param.LabelWidth - (float)label_param.LabelPaddings.Left - (float)label_param.LabelPaddings.Right - 1,
                                    (float)label_param.LabelHeight - (float)label_param.LabelPaddings.Top - (float)label_param.LabelPaddings.Bottom - 1);


                            // 绘制标签边界
                            // 灰色
                            if (bTestingGrid == true)
                            {
                                // 标签白色背景
                                if (this.IsDesignMode == true)
                                {
                                    using (Brush brushBack = new SolidBrush(Color.FromArgb(200, Color.White)))
                                    {
                                        e.Graphics.FillRectangle(brushBack, rectLabel);
                                    }
                                }

                                // 标签边界
                                using (Pen pen = new Pen(Color.FromArgb(200, 200, 200), this.IsDesignMode ? (float)0.5 : (float)1))
                                {
                                    e.Graphics.DrawRectangle(pen,
                                        rectLabel.X,
                                        rectLabel.Y,
                                        rectLabel.Width,
                                        rectLabel.Height);
#if NO
                            e.Graphics.DrawRectangle(pen,
                                x - nXDelta,
                                y - nYDelta,
                                (float)label_param.LabelWidth,
                                (float)label_param.LabelHeight);
#endif

                                }


                                // 绘制标签内部文字区域边界
                                // 淡红色

                                using (Pen pen = new Pen(Color.FromArgb(255, 200, 200), this.IsDesignMode ? (float)0.5 : (float)1))
                                {
                                    e.Graphics.DrawRectangle(pen,
                                        rectContent.X,
                                        rectContent.Y,
                                        rectContent.Width,
                                        rectContent.Height);
#if NO
                            e.Graphics.DrawRectangle(pen,
                                (float)x + (float)label_param.LabelPaddings.Left - nXDelta,
                                (float)y + (float)label_param.LabelPaddings.Top - nYDelta,
                                (float)label_param.LabelWidth - (float)label_param.LabelPaddings.Left - (float)label_param.LabelPaddings.Right - 1,
                                (float)label_param.LabelHeight - (float)label_param.LabelPaddings.Top - (float)label_param.LabelPaddings.Bottom - 1);
#endif

                                }
                            }

#if NO
                        RectangleF clip = new RectangleF((float)x + (float)label_param.LabelPaddings.Left - nXDelta,
    (float)y + (float)label_param.LabelPaddings.Top - nYDelta,
    (float)label_param.LabelWidth - (float)label_param.LabelPaddings.Left - (float)label_param.LabelPaddings.Right,
    (float)label_param.LabelHeight - (float)label_param.LabelPaddings.Top - (float)label_param.LabelPaddings.Bottom);
#endif

                            using (Region old_clip = e.Graphics.Clip)
                            {
                                e.Graphics.IntersectClip(rectContent);

                                float y0 = 0;
                                for (int k = 0; k < lines.Count; k++)
                                {
                                    string strText = lines[k];

                                    LineFormat format = null;
                                    if (k < label_param.LineFormats.Count)
                                        format = label_param.LineFormats[k];

                                    Font this_font = null;
                                    bool bIsBarcodeFont = false;
                                    if (format != null && format.Font != null)
                                    {
                                        this_font = format.Font;
                                        bIsBarcodeFont = format.IsBarcodeFont;
                                    }
                                    else
                                    {
                                        this_font = label_param.Font;
                                        bIsBarcodeFont = label_param.IsBarcodeFont;
                                    }

                                    if (bIsBarcodeFont == true && string.IsNullOrEmpty(strText) == false)
                                        strText = "*" + strText + "*";

                                    float nLineHeight = this_font.GetHeight(e.Graphics);

                                    RectangleF rect = new RectangleF((float)x + (float)label_param.LabelPaddings.Left - nXDelta,
                                        (float)y + (float)label_param.LabelPaddings.Top + y0 - nYDelta,
                                        (float)label_param.LabelWidth - (float)label_param.LabelPaddings.Left - (float)label_param.LabelPaddings.Right,
                                        nLineHeight);

                                    bool bAbsLocation = false;
                                    // 行格式的 start 和 offset
                                    if (format != null)
                                    {
                                        if (double.IsNaN(format.StartX) == false)
                                            rect.X = (float)format.StartX;
                                        if (double.IsNaN(format.StartY) == false)
                                        {
                                            rect.Y = (float)format.StartY;
                                            bAbsLocation = true;    // Y 绝对定位后，行高度不参与累计
                                        }
                                        rect.Offset((float)format.OffsetX, (float)format.OffsetY);

                                        y0 += (float)format.OffsetY;    // Y 偏移后，累计值也跟着调整

                                    }

                                    StringFormat s_format = new StringFormat();
                                    if (format != null)
                                    {
                                        if (format.Align == "right")
                                            s_format.Alignment = StringAlignment.Far;
                                        else if (format.Align == "center")
                                            s_format.Alignment = StringAlignment.Center;
                                        else
                                            s_format.Alignment = StringAlignment.Near;

                                        s_format.Trimming = StringTrimming.EllipsisCharacter;
                                        // s_format.LineAlignment = StringAlignment.Center;
                                    }

                                    if (format != null && string.IsNullOrEmpty(format.BackColor) == false)
                                    {
                                        using (Brush brush = new SolidBrush(GetColor(format.BackColor)))
                                        {
                                            e.Graphics.FillRectangle(brush, rect);
                                        }
                                    }

                                    {
                                        Brush brushText = null;
                                        try
                                        {
                                            if (format != null && string.IsNullOrEmpty(format.ForeColor) == false)
                                            {
                                                brushText = new SolidBrush(GetColor(format.ForeColor));
                                            }
                                            else
                                                brushText = System.Drawing.Brushes.Black;

                                            e.Graphics.DrawString(strText,
                                                this_font,
                                                brushText,
                                                rect,
                                                s_format);
                                        }
                                        finally
                                        {
                                            if (brushText != System.Drawing.Brushes.Black)
                                                brushText.Dispose();
                                        }
                                    }


                                    // 文字行区域边界
                                    // 黑色点
                                    if (bTestingGrid == true && label_param.LineSep > 0)
                                    {
                                        using (Pen pen = new Pen(Color.Black, (float)1))
                                        {
                                            // pen.DashStyle = System.Drawing.Drawing2D.DashStyle.Custom;

#if NO
                                            e.Graphics.DrawRectangle(pen,
                                                rect.Left,
                                                rect.Top,
                                                rect.Width,
                                                rect.Height);
#endif
                                            pen.DashPattern = new float[] { 1F, 3F, 1F, 3F };
                                            e.Graphics.DrawLine(pen,
                                                new PointF(rect.Left, rect.Top),
                                                new PointF(rect.Right, rect.Top)
                                                );
                                            e.Graphics.DrawLine(pen,
                                                new PointF(rect.Left + 2, rect.Bottom),
                                                new PointF(rect.Right, rect.Bottom)
                                                );
                                        }
                                    }

                                    if (bAbsLocation == false)
                                        y0 += nLineHeight + (float)label_param.LineSep;
                                }

                                e.Graphics.Clip = old_clip;
                            } // end of using clip

                        } // end if IntersectsWith



                    } // end if bOutput == true


                    x += (float)label_param.LabelWidth;
                }

                //CONTINUE_LINE:
                y += (float)label_param.LabelHeight;
            }

            // If more lines exist, print another page.
            if (bEOF == false)
            {
                if (e.PageSettings.PrinterSettings.PrintRange == PrintRange.SomePages)
                {
                    if (this.m_nPageNo >= to)
                    {
                        e.HasMorePages = false;
                        return;
                    }
                }
            }
            else
            {
                e.HasMorePages = false;
                return;
            }

            this.m_nPageNo++;
            e.HasMorePages = true;
            return;
        ERROR1:
            MessageBox.Show(owner, strError);
        }


		~~~~~~~~~~~~~
		        void InstallBarcodeFont()
        {
            bool bInstalled = true;
            try
            {
                FontFamily family = new FontFamily("C39HrP24DhTt");
            }
            catch
            {
                bInstalled = false;
            }

            if (bInstalled == true)
            {
                // 已经安装
                return;
            }

            {
                string strFontFilePath = Path.Combine(this.DataDir, "b3901.ttf");
                int nRet = API.AddFontResourceA(strFontFilePath);
                if (nRet == 0)
                {
                    // 失败
                    MessageBox.Show(this, "安装字体文件 " + strFontFilePath + " 失败");
                    return;
                }
                // 为了解决 GDI+ 的一个 BUG
                // PrivateFontCollection m_pfc = new PrivateFontCollection();
                GlobalVars.PrivateFonts.AddFontFile(strFontFilePath);
            }

            {
                string strFontFilePath = Path.Combine(this.DataDir, "ocr-b.ttf");
                int nRet = API.AddFontResourceA(strFontFilePath);
                if (nRet == 0)
                {
                    // 失败
                    MessageBox.Show(this, "安装字体文件 " + strFontFilePath + " 失败");
                    return;
                }
                // 'OCR-B 10 BT' 字体
                GlobalVars.PrivateFonts.AddFontFile(strFontFilePath);
            }
#if NO
            /*
            try
            {
                FontFamily family = new FontFamily("C39HrP24DhTt");
            }
            catch (Exception ex)
            {
                bInstalled = false;
            }
             * */
            InstalledFontCollection enumFonts = new InstalledFontCollection();
            FontFamily[] fonts = enumFonts.Families;

            string strResult = "";
            foreach (FontFamily m in fonts)
            {
                strResult += m.Name + "\r\n";
            }

            int i = 0;
            i++;
#endif
        }


		~~~~~~~~~~~

		        void RemoveBarcodeFont()
        {
            GlobalVars.PrivateFonts.Dispose();

            {
                string strFontFilePath = Path.Combine(this.DataDir, "b3901.ttf");
                API.RemoveFontResourceA(strFontFilePath);
            }

            {
                string strFontFilePath = Path.Combine(this.DataDir, "ocr-b.ttf");
                API.RemoveFontResourceA(strFontFilePath);
            }
        }


		~~~~~~~~~
		        // 校验订购记录
        int VerifyOrderRecord(out string strError)
        {
            strError = "";
            int nRet = 0;

            bool bControl = Control.ModifierKeys == Keys.Control;

            Debug.Assert(this.DbType == "order", "");

            if (this.listView_records.SelectedItems.Count == 0)
            {
                strError = "尚未选定要进行批处理的事项";
                return -1;
            }

            if (stop != null && stop.State == 0)    // 0 表示正在处理
            {
                strError = "目前有长操作正在进行，无法进行校验订购记录的操作";
                return -1;
            }

            // 切换到“操作历史”属性页
            this.MainForm.ActivateFixPage("history");

            int nCount = 0;
            int nModifyCount = 0;

            this.MainForm.OperHistory.AppendHtml("<div class='debug begin'>" + HttpUtility.HtmlEncode(DateTime.Now.ToLongTimeString())
                + " 开始进行订购记录校验</div>");

            stop.Style = StopStyle.EnableHalfStop;
            stop.OnStop += new StopEventHandler(this.DoStop);
            stop.Initial("正在进行校验订购记录的操作 ...");
            stop.BeginLoop();

            this.EnableControls(false);
            try
            {
                stop.SetProgressRange(0, this.listView_records.SelectedItems.Count);

                List<ListViewItem> items = new List<ListViewItem>();
                foreach (ListViewItem item in this.listView_records.SelectedItems)
                {
                    if (string.IsNullOrEmpty(item.Text) == true)
                        continue;

                    items.Add(item);
                }

                bool bOldSource = true; // 是否要从 OldXml 开始做起

                if (bControl)
                {
                    int nChangeCount = this.GetItemsChangeCount(items);
                    if (nChangeCount > 0)
                    {
                        bool bHideMessageBox = true;
                        DialogResult result = MessageDialog.Show(this,
                            "当前选定的 " + items.Count.ToString() + " 个事项中有 " + nChangeCount + " 项修改尚未保存。\r\n\r\n请问如何进行修改? \r\n\r\n(重新修改) 重新进行修改，忽略以前内存中的修改; \r\n(继续修改) 以上次的修改为基础继续修改; \r\n(放弃) 放弃整个操作",
        MessageBoxButtons.YesNoCancel,
        MessageBoxDefaultButton.Button1,
        null,
        ref bHideMessageBox,
        new string[] { "重新修改", "继续修改", "放弃" });
                        if (result == DialogResult.Cancel)
                        {
                            strError = "放弃";
                            return 0;
                        }
                        if (result == DialogResult.No)
                        {
                            bOldSource = false;
                        }
                    }
                }

                ListViewPatronLoader loader = new ListViewPatronLoader(this.Channel,
    stop,
    items,
    this.m_biblioTable);
                loader.DbTypeCaption = this.DbTypeCaption;

                int i = 0;
                foreach (LoaderItem item in loader)
                {
                    Application.DoEvents();	// 出让界面控制权

                    if (stop != null
                        && stop.State != 0)
                    {
                        strError = "用户中断";
                        return -1;
                    }

                    bool bChanged = false;

                    BiblioInfo info = item.BiblioInfo;

                    XmlDocument itemdom = new XmlDocument();
                    try
                    {
                        // itemdom.LoadXml(info.OldXml);
                        if (bOldSource == true)
                        {
                            itemdom.LoadXml(info.OldXml);
                            // 放弃上一次的修改
                            if (string.IsNullOrEmpty(info.NewXml) == false)
                            {
                                info.NewXml = "";
                                this.m_nChangedCount--;
                            }
                        }
                        else
                        {
                            if (string.IsNullOrEmpty(info.NewXml) == false)
                                itemdom.LoadXml(info.NewXml);
                            else
                                itemdom.LoadXml(info.OldXml);
                        }
                    }
                    catch (Exception ex)
                    {
                        strError = "记录 '" + info.RecPath + "' 的 XML 装入 DOM 时出错: " + ex.Message;
                        return -1;
                    }

                    List<string> errors = new List<string>();

                    // 检查根元素下的元素名是否有重复的
                    nRet = VerifyDupElementName(itemdom,
            out strError);
                    if (nRet == -1)
                        errors.Add(strError);

                    // 校验 XML 记录中是否有非法字符
                    string strReplaced = DomUtil.ReplaceControlCharsButCrLf(info.OldXml, '*');
                    if (strReplaced != info.OldXml)
                    {
                        errors.Add("XML 记录中有非法字符");
                    }

                    nRet = VerifyRefID(itemdom,
                        bControl,
                        out strError);
                    if (nRet == -1)
                    {
                        errors.Add(strError);
                        if (bControl)
                            bChanged = true;
                    }

                    nRet = VerifyOrder(itemdom,
                        bControl,
                        ref bChanged,
                        out strError);
                    if (nRet == -1)
                        errors.Add(strError);

                    if (errors.Count > 0)
                    {
                        this.MainForm.OperHistory.AppendHtml("<div class='debug recpath'>" + HttpUtility.HtmlEncode(info.RecPath) + "</div>");
                        foreach (string error in errors)
                        {
                            this.MainForm.OperHistory.AppendHtml("<div class='debug error'>" + HttpUtility.HtmlEncode(error) + "</div>");
                        }

                        {
                            item.ListViewItem.BackColor = Color.FromArgb(155, 0, 0);
                            item.ListViewItem.ForeColor = Color.FromArgb(255, 255, 255);
                        }
                    }

                    if (bChanged == true)
                    {
                        string strXml = itemdom.OuterXml;
                        Debug.Assert(info != null, "");
                        if (info != null)
                        {
                            if (string.IsNullOrEmpty(info.NewXml) == true)
                                this.m_nChangedCount++;
                            info.NewXml = strXml;
                        }

                        item.ListViewItem.BackColor = SystemColors.Info;
                        item.ListViewItem.ForeColor = SystemColors.InfoText;
                        nModifyCount++;
                    }

                    nCount++;
                    stop.SetProgressValue(++i);
                }

                return nCount;
            }
            finally
            {
                stop.EndLoop();
                stop.OnStop -= new StopEventHandler(this.DoStop);
                stop.Initial("");
                stop.HideProgress();
                stop.Style = StopStyle.None;

                this.EnableControls(true);

                this.MainForm.OperHistory.AppendHtml("<div class='debug end'>" + HttpUtility.HtmlEncode(DateTime.Now.ToLongTimeString())
                    + " 结束执行订购记录校验</div>");
                if (nModifyCount > 0)
                    this.MainForm.OperHistory.AppendHtml("<div class='debug end'>" + HttpUtility.HtmlEncode(DateTime.Now.ToLongTimeString())
                        + " 发生修改 " + nModifyCount + " 条</div>");
            }
        }



		~~~~~~~~~~~~~~~

		        // 老版本，没有 channel 参数
        // 准备DOM和书目摘要等
        // parameters:
        //      bFillSummaryColumn  是否要填充书目摘要列。如果为 false，则只设定 info.BiblioRecPath 的值
        internal virtual int GetSummaries(
            bool bFillSummaryColumn,
            string [] summary_col_names,
            List<DigitalPlatform.LibraryClient.localhost.Record> records,
            out List<RecordInfo> infos,
            out string strError)
        {
            strError = "";
            infos = new List<RecordInfo>();

            // 准备DOM和书目摘要
            for (int i = 0; i < records.Count; i++)
            {
                Application.DoEvents();

                if (stop != null && stop.State != 0)
                    {
                        strError = "用户中断1";
                        return -1;
                    }

                RecordInfo info = new RecordInfo();
                info.Record = records[i];
                infos.Add(info);

                if (info.Record.RecordBody == null)
                {
                    strError = "请升级dp2Kernel到最新版本";
                    return -1;
                }

                if (info.Record.RecordBody.Result.ErrorCode != ErrorCodeValue.NoError)
                    continue;

                info.Dom = new XmlDocument();
                try
                {
                    info.Dom.LoadXml(info.Record.RecordBody.Xml);
                }
                catch (Exception ex)
                {
                    strError = "册记录的XML装入DOM时出错: " + ex.Message;
                    return -1;
                }

                // 准备书目记录路径
                string strParentID = DomUtil.GetElementText(info.Dom.DocumentElement,
"parent");
                string strBiblioDbName = this.MainForm.GetBiblioDbNameFromItemDbName(Global.GetDbName(info.Record.Path));
                if (string.IsNullOrEmpty(strBiblioDbName) == true)
                {
                    strError = "根据册记录路径 '" + info.Record.Path + "' 获得书目库名时出错";
                    return -1;
                }
                info.BiblioRecPath = strBiblioDbName + "/" + strParentID;
            }

            // 准备摘要
            if (bFillSummaryColumn == true)
            {
                if (summary_col_names == null || summary_col_names.Length == 0)
                {
                    strError = "当 bFillSummaryColumn 为 true 的时候，summary_col_names 不应为空";
                    return -1;
                }

                // 归并书目记录路径
                List<string> bibliorecpaths = new List<string>();
                foreach (RecordInfo info in infos)
                {
                    bibliorecpaths.Add(info.BiblioRecPath);
                }

                // 去重
                StringUtil.RemoveDupNoSort(ref bibliorecpaths);

                // 看看cache中是否已经存在，如果已经存在则不再从服务器取
                for (int i = 0; i < bibliorecpaths.Count; i++)
                {
                    string strPath = bibliorecpaths[i];
                    SummaryInfo summary = (SummaryInfo)this.m_summaryTable[strPath];
                    if (summary != null)
                    {
                        bibliorecpaths.RemoveAt(i);
                        i--;
                    }
                }

                // 从服务器获取
                if (bibliorecpaths.Count > 0)
                {
                REDO_GETBIBLIOINFO_0:
                    string strCommand = "@path-list:" + StringUtil.MakePathList(bibliorecpaths);

#if NO
                    string[] formats = new string[2];
                    formats[0] = "summary";
                    formats[1] = "@isbnissn";
                    formats[2] = "targetrecpath";
#endif

                    string[] results = null;
                    byte[] timestamp = null;

                    // stop.SetMessage("正在装入书目记录 '" + bibliorecpaths[0] + "' 等的摘要 ...");

                    // TODO: 有没有可能希望取的事项数目一次性取得没有取够?
                REDO_GETBIBLIOINFO:
                    long lRet = Channel.GetBiblioInfos(
                        stop,
                        strCommand,
                        "",
                        summary_col_names,
                        out results,
                        out timestamp,
                        out strError);
                    if (lRet == -1)
                    {
                        DialogResult temp_result = MessageBox.Show(this,
        strError + "\r\n\r\n是否重试?",
        this.FormCaption,
        MessageBoxButtons.RetryCancel,
        MessageBoxIcon.Question,
        MessageBoxDefaultButton.Button1);
                        if (temp_result == DialogResult.Retry)
                            goto REDO_GETBIBLIOINFO;
                    }
                    if (lRet == -1 || lRet == 0)
                    {
                        if (lRet == 0 && String.IsNullOrEmpty(strError) == true)
                            strError = "书目记录 '" + StringUtil.MakePathList(bibliorecpaths) + "' 不存在";

                        strError = "获得书目摘要时发生错误: " + strError;
                        // 如果results.Length表现正常，其实还可以继续处理
                        if (results != null /* && results.Length == 2 * bibliorecpaths.Count */)
                        {
                        }
                        else
                            return -1;
                    }


                    if (results != null/* && results.Length == 2 * bibliorecpaths.Count*/)
                    {
                        // Debug.Assert(results != null && results.Length == 2 * bibliorecpaths.Count, "results必须包含 " + (2 * bibliorecpaths.Count).ToString() + " 个元素");

                        // 放入缓存
                        for (int i = 0; i < results.Length / summary_col_names.Length; i++)
                        {
                            SummaryInfo summary = new SummaryInfo();

                            summary.Values = new string[summary_col_names.Length];
                            for (int j = 0; j < summary_col_names.Length; j++)
                            {
                                summary.Values[j] = results[i * summary_col_names.Length + j];
                            }

                            this.m_summaryTable[bibliorecpaths[i]] = summary;
                        }
                    }

                    if (results != null && results.Length != summary_col_names.Length * bibliorecpaths.Count)
                    {
                        // 没有取够，需要继续处理
                        bibliorecpaths.RemoveRange(0, results.Length / summary_col_names.Length);
                        goto REDO_GETBIBLIOINFO_0;
                    }
                }

                // 挂接到每个记录附近
                foreach (RecordInfo info in infos)
                {
                    SummaryInfo summary = (SummaryInfo)this.m_summaryTable[info.BiblioRecPath];
                    if (summary == null)
                    {
                        strError = "缓存中找不到书目记录 '" + info.BiblioRecPath + "' 的摘要事项";
                        return -1;
                    }

                    info.SummaryInfo = summary;
                }

                // 避免cache占据的内存太多
                if (this.m_summaryTable.Count > 1000)
                    this.m_summaryTable.Clear();
            }

            return 0;
        }


		~~~~~~~

		        // (复制)另存书目记录为。注：包括下属的册、订购、期、评注记录和对象资源
        private void toolStripButton1_marcEditor_saveTo_Click(object sender, EventArgs e)
        {
            string strError = "";
            int nRet = 0;

            if (StringUtil.CompareVersion(this.MainForm.ServerVersion, "2.39") < 0)
            {
                strError = "本功能需要配合 dp2library 2.39 或以上版本才能使用";
                goto ERROR1;
            }

            string strTargetRecPath = this.m_marcEditor.Record.Fields.GetFirstSubfield("998", "t");
            if (string.IsNullOrEmpty(strTargetRecPath) == false)
            {
                DialogResult result = MessageBox.Show(this,
    "当前窗口内的记录原本是从 '" + strTargetRecPath + "' 复制过来的。是否要复制回原有位置？\r\n\r\nYes: 是; No: 否，继续进行普通复制操作; Cancel: 放弃本次操作",
    "EntityForm",
    MessageBoxButtons.YesNoCancel,
    MessageBoxIcon.Question,
    MessageBoxDefaultButton.Button1);
                if (result == System.Windows.Forms.DialogResult.Cancel)
                    return;
                if (result == System.Windows.Forms.DialogResult.Yes)
                {
                    // strTargetRecPath会发生作用
                }

                if (result == System.Windows.Forms.DialogResult.No)
                {
                    strTargetRecPath = "";
                }
            }

            bool bSaveAs = false;   // 源记录ID就是'?'，追加方式。这意味着数据库中没有源记录

            // 源记录就是 ？
            if (Global.IsAppendRecPath(this.BiblioRecPath) == true)
            {
                bSaveAs = true;
            }

            MergeStyle merge_style = MergeStyle.CombineSubrecord | MergeStyle.ReserveSourceBiblio;

            BiblioSaveToDlg dlg = new BiblioSaveToDlg();
            MainForm.SetControlFont(dlg, this.Font, false);

            dlg.MainForm = this.MainForm;
            // dlg.RecPath = this.BiblioRecPath;
            if (string.IsNullOrEmpty(strTargetRecPath) == false)
                dlg.RecPath = strTargetRecPath;
            else
            {
                dlg.RecPath = this.MainForm.AppInfo.GetString(
                    "entity_form",
                    "save_to_used_path",
                    this.BiblioRecPath);
                dlg.RecID = "?";
            }

            if (bSaveAs == false)
                dlg.MessageText = "(注：本功能*可选择*是否复制书目记录下属的册、期、订购、实体记录和对象资源)\r\n\r\n将当前窗口中的书目记录 " + this.BiblioRecPath + " 复制到:";
            else
            {
                dlg.Text = "保存新书目记录到特定位置";
                dlg.MessageText = "注：\r\n1) 当前执行的是保存而不是复制操作(因为数据库里面还没有这条记录);\r\n2) 书目记录下属的册、期、订购、实体记录和对象资源会被一并保存";
                dlg.EnableCopyChildRecords = false;
            }

            if (string.IsNullOrEmpty(strTargetRecPath) == false)
                dlg.BuildLink = false;
            else
            {
                if (bSaveAs == false)
                    dlg.BuildLink = this.MainForm.AppInfo.GetBoolean(
                        "entity_form",
                        "when_save_to_build_link",
                        true);
                else
                    dlg.BuildLink = false;
            }

            if (bSaveAs == false)
                dlg.CopyChildRecords = this.MainForm.AppInfo.GetBoolean(
                    "entity_form",
                    "when_save_to_copy_child_records",
                    false);
            else
                dlg.CopyChildRecords = true;

            {
                string strMarcSyntax = this.GetCurrentMarcSyntax();
                if (string.IsNullOrEmpty(strMarcSyntax) == true)
                    strMarcSyntax = this.MarcSyntax;    // 外来数据的 MARC 格式

                dlg.MarcSyntax = strMarcSyntax;
            }

            dlg.CurrentBiblioRecPath = this.BiblioRecPath;
            this.MainForm.AppInfo.LinkFormState(dlg, "entityform_BiblioSaveToDlg_state");
            dlg.ShowDialog(this);
            // this.MainForm.AppInfo.UnlinkFormState(dlg);

            if (dlg.DialogResult != DialogResult.OK)
                return;

            if (this.BiblioRecPath == dlg.RecPath)
            {
                strError = "要保存到的位置 '" + dlg.RecPath + "' 和当前记录本来的位置 '" + this.BiblioRecPath + "' 相同，复制操作被拒绝。若确实要这样保存记录，请直接使用保存功能。";
                goto ERROR1;
            }

            if (bSaveAs == false)
            {
                this.MainForm.AppInfo.SetBoolean(
                    "entity_form",
                    "when_save_to_build_link",
                    dlg.BuildLink);
                this.MainForm.AppInfo.SetBoolean(
                    "entity_form",
                    "when_save_to_copy_child_records",
                    dlg.CopyChildRecords);
            }
            this.MainForm.AppInfo.SetString(
    "entity_form",
    "save_to_used_path",
    dlg.RecPath);

            // 源记录就是 ？
            if (bSaveAs == true)
            {
                this.BiblioRecPath = dlg.RecPath;

                // 提交所有保存请求
                // return:
                //      -2  出错，并且已经放弃保存
                //      -1  有错。此时不排除有些信息保存成功。
                //      0   成功。
                nRet = DoSaveAll();
                if (nRet == -1)
                {
                    strError = "保存操作出错";
                    goto ERROR1;
                }

                return;
            }

            if (dlg.CopyChildRecords == false)
            {
                // 如果当前记录的下级记录没有保存，则警告
                if (this.EntitiesChanged == true
        || this.IssuesChanged == true
        || this.ObjectChanged == true
        || this.OrdersChanged == true
        || this.CommentsChanged == true)
                {
                    // 警告尚未保存
                    DialogResult result = MessageBox.Show(this,
                        "当前窗口内有 " + GetCurrentChangedPartName() + " 被修改后尚未保存。仅复制书目的操作不会复制这些下属记录，继续操作会丢弃这些修改。\r\n\r\n请问是否继续进行复制操作？",
                        "EntityForm",
                        MessageBoxButtons.OKCancel,
                        MessageBoxIcon.Question,
                        MessageBoxDefaultButton.Button2);
                    if (result == DialogResult.Cancel)
                    {
                        strError = "复制操作被放弃";
                        goto ERROR1;
                    }
                }
            }
            else
            {
                // 如果当前记录没有保存，则先保存
                if (this.ObjectChanged == true)
                {
                    // 警告尚未保存
                    DialogResult result = MessageBox.Show(this,
                        "当前窗口内有 " + GetCurrentChangedPartName() + " 被修改后尚未保存。\r\n\r\n请问要在复制书目记录前立即保存这些修改到源记录么？",
                        "EntityForm",
                        MessageBoxButtons.OKCancel,
                        MessageBoxIcon.Question,
                        MessageBoxDefaultButton.Button2);
                    if (result == DialogResult.OK)
                    {
                        // 提交所有保存请求
                        // return:
                        //      -1  有错。此时不排除有些信息保存成功。
                        //      0   成功。
                        nRet = DoSaveAll();
                        if (nRet == -1 || nRet == -2)
                        {
                            strError = "因为保存操作出错，所以后续的复制操作被放弃";
                            goto ERROR1;
                        }
                    }
                    else
                    {
                        strError = "复制操作被放弃";
                        goto ERROR1;
                    }
                }
            }

#if NO
            {
                // TODO: 移动或者复制前，要求下属记录已经保存。否则移动不过去，会造成困惑。
                // 另外一种方法是允许这样做，但移动时候的操作就复杂了，要把内存中的册记录保存到新的书目记录名下，容易造成册条码号重复等问题

                // 如果当前记录没有保存，则先保存
                if (this.EntitiesChanged == true
        || this.IssuesChanged == true
                    // || this.BiblioChanged == true
        || this.ObjectChanged == true
        || this.OrdersChanged == true
        || this.CommentsChanged == true)
                {
                    // 警告尚未保存
                    DialogResult result = MessageBox.Show(this,
                        "当前窗口内有 " + GetCurrentChangedPartName() + " 被修改后尚未保存。仅复制书目的操作不会复制下属记录。\r\n\r\n请问要在复制书目记录前立即保存这些修改到源记录么？",
                        "EntityForm",
                        MessageBoxButtons.OKCancel,
                        MessageBoxIcon.Question,
                        MessageBoxDefaultButton.Button2);
                    if (result == DialogResult.OK)
                    {
                        // 提交所有保存请求
                        // return:
                        //      -1  有错。此时不排除有些信息保存成功。
                        //      0   成功。
                        nRet = DoSaveAll();
                        if (nRet == -1)
                        {
                            strError = "因为保存操作出错，所以后续的复制操作被放弃";
                            goto ERROR1;
                        }
                    }
                    else
                    {
                        strError = "复制操作被放弃";
                        goto ERROR1;
                    }
                }
            }
#endif

            // 看看要另存的位置，记录是否已经存在?
            // TODO：　需要改造为合并，或者覆盖。覆盖是先删除目标位置的记录。
            if (dlg.RecID != "?")
            {
                byte[] timestamp = null;

                // 检测特定位置书目记录是否已经存在
                // parameters:
                // return:
                //      -1  error
                //      0   not found
                //      1   found
                nRet = DetectBiblioRecord(dlg.RecPath,
                    out timestamp,
                    out strError);
                if (nRet == 1)
                {
                    if (dlg.RecPath != strTargetRecPath)
                    {
#if NO
                        // 提醒覆盖？
                        DialogResult result = MessageBox.Show(this,
                            "书目记录 " + dlg.RecPath + " 已经存在。\r\n\r\n要用当前窗口中的书目记录覆盖此记录么? ",
                            "EntityForm",
                            MessageBoxButtons.YesNo,
                            MessageBoxIcon.Question,
                            MessageBoxDefaultButton.Button2);
                        if (result != DialogResult.Yes)
                            return;
#endif
                        GetMergeStyleDialog merge_dlg = new GetMergeStyleDialog();
                        MainForm.SetControlFont(merge_dlg, this.Font, false);
                        merge_dlg.Operation = "复制";
                        merge_dlg.SourceRecPath = this.BiblioRecPath;
                        merge_dlg.TargetRecPath = dlg.RecPath;
                        merge_dlg.MessageText = "目标书目记录 " + dlg.RecPath + " 已经存在。\r\n\r\n请指定当前窗口中的书目记录(源)和此目标记录合并的方法";

                        merge_dlg.UiState = this.MainForm.AppInfo.GetString(
        "entity_form",
        "GetMergeStyleDialog_copy_uiState",
        "");
                        merge_dlg.EnableSubRecord = dlg.CopyChildRecords;

                        this.MainForm.AppInfo.LinkFormState(merge_dlg, "entityform_GetMergeStyleDialog_copy_state");
                        merge_dlg.ShowDialog(this);
                        this.MainForm.AppInfo.UnlinkFormState(merge_dlg);
                        this.MainForm.AppInfo.SetString(
"entity_form",
"GetMergeStyleDialog_copy_uiState",
merge_dlg.UiState);

                        if (merge_dlg.DialogResult == System.Windows.Forms.DialogResult.Cancel)
                            return;

                        merge_style = merge_dlg.GetMergeStyle();
                    }

                    // this.BiblioTimestamp = timestamp;   // 为了顺利覆盖

                    // TODO: 预先检查操作者权限，确保删除书目记录和下级记录都能成功，否则就警告

#if NO
                    // 删除目标位置的书目记录，但保留其下属的实体等记录
                    nRet = DeleteBiblioRecordFromDatabase(dlg.RecPath,
                        "onlydeletebiblio",
                        timestamp,
                        out strError);
                    if (nRet == -1)
                        goto ERROR1;
#endif
                    if ((merge_style & MergeStyle.OverwriteSubrecord) != 0)
                    {
                        // 删除目标记录整个，或者删除目标位置的下级记录
                        // TODO: 测试的时候，注意不用下述调用而测试保留目标书目记录中对象的可能性
                        nRet = DeleteBiblioRecordFromDatabase(dlg.RecPath,
                            (merge_style & MergeStyle.ReserveSourceBiblio) != 0 ? "delete" : "onlydeletesubrecord",
                            timestamp,
                            out strError);
                        if (nRet == -1)
                        {
                            if ((merge_style & MergeStyle.ReserveSourceBiblio) != 0)
                                strError = "删除目标位置的书目记录 '" + dlg.RecPath + "' 时出错: " + strError;
                            else
                                strError = "删除目标位置的书目记录 '" + dlg.RecPath + "' 的全部子记录时出错: " + strError;
                            goto ERROR1;
                        }
                    }
                }
            }

            string strOutputBiblioRecPath = "";
            byte[] baOutputTimestamp = null;
            string strXml = "";

            string strOldBiblioRecPath = this.BiblioRecPath;
            string strOldMarc = this.GetMarc();    //  this.m_marcEditor.Marc;
            bool bOldChanged = this.GetMarcChanged();   //  this.m_marcEditor.Changed;
            bool bSucceed = false;

            this.EnableControls(false);

            LibraryChannel channel = this.GetChannel();
            TimeSpan old_timeout = channel.Timeout;
            channel.Timeout = new TimeSpan(0, 2, 0);    // 查重和复制一般都需要较长时间

            try
            {
                // 保存原来的记录路径
                bool bOldReadOnly = this.m_marcEditor.ReadOnly;
                Field old_998 = null;

                if (dlg.BuildLink == true)
                {
                    nRet = this.MainForm.CheckBuildLinkCondition(
                        dlg.RecPath,    // 即将创建/保存的记录
                        strOldBiblioRecPath,    // 保存前的记录
                        false,
                        out strError);
                    if (nRet == -1 || nRet == 0)
                    {
                        // 
                        strError = "无法为记录 '" + this.BiblioRecPath + "' 建立指向 '" + strOldBiblioRecPath + "' 的目标关系：" + strError;
                        MessageBox.Show(this, strError);
                    }
                    else
                    {
                        // 保存当前记录的998字段
                        old_998 = this.m_marcEditor.Record.Fields.GetOneField("998", 0);

                        this.m_marcEditor.Record.Fields.SetFirstSubfield("998", "t", strOldBiblioRecPath);
                        /*
                        if (bOldReadOnly == false)
                            this.MarcEditor.ReadOnly = true;
                        */
                    }
                }
                else
                {
                    // 保存当前记录的998字段
                    old_998 = this.m_marcEditor.Record.Fields.GetOneField("998", 0);

                    // 清除可能存在的998$t
                    if (old_998 != null)
                    {
                        SubfieldCollection subfields = old_998.Subfields;
                        Subfield old_t = subfields["t"];
                        if (old_t != null)
                        {
                            old_998.Subfields = subfields.Remove(old_t);
                            // 如果998内一个子字段也没有了，是否这个字段要删除?
                        }
                        else
                            old_998 = null; // 表示(既然没有删除$t，就)不用恢复
                    }
                }

                string strMergeStyle = "";
                if ((merge_style & MergeStyle.ReserveSourceBiblio) != 0)
                    strMergeStyle = "reserve_source,file_reserve_source";
                else
                    strMergeStyle = "reserve_target,file_reserve_target";

                if ((merge_style & MergeStyle.MissingSourceSubrecord) != 0)
                    strMergeStyle += ",missing_source_subrecord";
                else if ((merge_style & MergeStyle.OverwriteSubrecord) != 0)
                {
                    // dp2library 尚未实现这个功能，不过本函数前面已经用 SetBiblioInfo() API 主动删除了目标位置下属的子记录，效果是一样的。(当然，这样实现起来原子性不是那么好)
                    // strMergeStyle += ",overwrite_target_subrecord";
                }

                SavedInfo info = new SavedInfo();

                if (dlg.CopyChildRecords == false)
                {
                    nRet = CopyBiblio(
                        channel,
        "onlycopybiblio",
        dlg.RecPath,
        strMergeStyle,
        out strXml,
        out strOutputBiblioRecPath,
        out baOutputTimestamp,
        out strError);
                }
                else
                {
                    nRet = CopyBiblio(
                        channel,
                        "copy",
                        dlg.RecPath,
                        strMergeStyle,
                        out strXml,
                        out strOutputBiblioRecPath,
                        out baOutputTimestamp,
                        out strError);
                }

#if NO
                if (nRet == -1)
                {
                    MessageBox.Show(this, strError);
                }
#endif
                if (nRet == 0)
                {
                    info.bBiblioSaved = true;
                    info.SavedNames.Add("书目信息");
                    this.BiblioChanged = false;
                    this.BiblioRecPath = strOutputBiblioRecPath;
                    this.BiblioTimestamp = baOutputTimestamp;
                    bSucceed = true;
                }
                if (nRet == -1)
                {
                    info.ErrorCount++;
                    goto ERROR1; // 书目记录若保存不成功，后继的实体记录保存就没法定位正确的书目记录路径
                }

                if (dlg.CopyChildRecords == false)
                {
                    // 清空4个下属记录的控件
                    this.entityControl1.ClearItems();
                    this.textBox_itemBarcode.Text = "";

                    this.issueControl1.ClearItems();
                    this.orderControl1.ClearItems();
                    this.commentControl1.ClearItems();
                    this.binaryResControl1.Clear();
                    if (this.m_verifyViewer != null)
                        this.m_verifyViewer.Clear();
                }
                else
                {
                    /// 
                    LoadSubRecordsInfo load_info = new LoadSubRecordsInfo();

                    if (String.IsNullOrEmpty(strOutputBiblioRecPath) == false)
                    {
                        // 装载下级记录，为保存下级记录的修改做准备
                        nRet = LoadSubRecords(
                            channel,
                            strOutputBiblioRecPath,
                            null,   // strXml, // 书目记录 XML
                            "", // strSubRecords,
                            load_info,
                            true,
                            out strError);
                        if (nRet == -1)
                            goto ERROR1;
                        // TODO: load_info.ErrorCount ?
                    }

                    nRet = SaveSubRecords(channel,
                        info,
                        strOutputBiblioRecPath,
                        out strError);
                    if (nRet == -1)
                        return;
                }

            }
            finally
            {
                channel.Timeout = old_timeout;
                this.ReturnChannel(channel);

                this.EnableControls(true);

                if (bSucceed == false)
                {
                    if (this.GetMarc() /*this.m_marcEditor.Marc*/ != strOldMarc)
                    {
                        // this.m_marcEditor.Marc = strOldMarc;
                        this.SetMarc(strOldMarc);
                    }
                    if (this.GetMarcChanged() /*this.m_marcEditor.Changed*/ != bOldChanged)
                    {
                        // this.m_marcEditor.Changed = bOldChanged;
                        this.SetMarcChanged(bOldChanged);
                    }

                    this.BiblioRecPath = strOldBiblioRecPath;
                }
            }

#if NO
            // TODO: 询问是否要立即装载目标记录到当前窗口，还是装入新的一个种册窗，还是不装入？
            {
                DialogResult result = MessageBox.Show(this,
        "复制操作已经成功。\r\n\r\n请问是否立即将目标记录 '" + strOutputBiblioRecPath + "' 装入一个新的种册窗以便进行观察? \r\n\r\n是(Yes): 装入一个新的种册窗；\r\n否(No): 装入当前窗口；\r\n取消(Cancel): 不装入目标记录到任何窗口",
        "EntityForm",
        MessageBoxButtons.YesNoCancel,
        MessageBoxIcon.Question,
        MessageBoxDefaultButton.Button1);
                if (result == System.Windows.Forms.DialogResult.Yes)
                {
                    EntityForm form = new EntityForm();
                    form.MdiParent = this.MainForm;
                    form.MainForm = this.MainForm;
                    form.Show();
                    Debug.Assert(form != null, "");

                    form.LoadRecordOld(strOutputBiblioRecPath, "", true);
                    return;
                }
                if (result == System.Windows.Forms.DialogResult.Cancel)
                    return;
            }

            // 将目标记录装入当前窗口
            this.LoadRecordOld(strOutputBiblioRecPath, "", false);
#endif
            return;
        ERROR1:
            MessageBox.Show(this, strError);
        }



		~~~~~~~~~~~~~~~~
		biblioitemshost.cs:

		        /// <summary>
        /// 获得种次号以外的其他区分号，主要是著者号
        /// </summary>
        /// <param name="strQufenhaoTypes">区分号类型。可以是一个区分号类型，也可以是逗号间隔的若干个区分号类型</param>
        /// <param name="strQufenhao">返回区分号</param>
        /// <param name="strError">返回出错信息</param>
        /// <returns>-1: 出错; 0: 没有找到(注意此时 strError 中也返回了内容); 1: 找到</returns>
        public virtual int GetAuthorNumber(string strQufenhaoTypes,
            out string strQufenhao,
            out string strError)
        {
            strError = "";
            strQufenhao = "";
            int nRet = 0;

            List<string> types = StringUtil.SplitList(strQufenhaoTypes);

            List<AuthorLevel> authors = new List<AuthorLevel>();

            // *** 第一阶段，遍历获取每个区分号类型的著者字符串
            foreach (string type in types)
            {
                string strAuthor = "";
                float fLevel = 0;

                AuthorLevel author = new AuthorLevel();
                author.Type = type;
                if (type == "GCAT"
                    || type == "四角号码"
                    || type == "Cutter-Sanborn Three-Figure"
#if SHITOUTANG

 || type == "石头汤著者号"
                    || type == "石头汤"
#endif
)
                {
                    // 根据区分号类型从MARC记录中获得作者字符串
                    // return:
                    //      -1  error
                    //      0   not found
                    //      1   found
                    nRet = GetAuthor(type,
                        out strAuthor,
                        out fLevel,
                        out strError);

#if DEBUG
                    if (nRet == 0)
                    {
                        Debug.Assert(String.IsNullOrEmpty(strAuthor) == true, "");
                    }

                    if (nRet == 1)
                    {
                        Debug.Assert(String.IsNullOrEmpty(strAuthor) == false, "");
                    }
#endif

                    if (nRet == -1 || nRet == 0)
                        author.Level = nRet;
                    else
                        author.Level = fLevel;
                    if (nRet == 1)
                        author.Author = strAuthor;
                    else
                        author.Author = strError;
                    authors.Add(author);
                    continue;
                }
                else if (type == "手动")
                {
                    author.Level = 1;
                    author.Author = "?";
                    authors.Add(author);
                    continue;
                }
                else if (type == "<无>")
                {
                    author.Level = 1;
                    author.Author = "";
                    authors.Add(author);
                    continue;
                }
                else
                {
                    strError = "未知的区分号类型 '" + type + "'";
                    goto ERROR1;
                }
            }

            // *** 第二阶段，选择一个 level 最高的著者信息
            AuthorLevel one = null;
            if (authors.Count == 0)
            {
                strError = "没有指定任何区分号类型，无法获得著者字符串";
                return 0;
            }
            else if (authors.Count == 1)
            {
                one = authors[0];
            }
            if (authors.Count > 1)
            {
                // TODO: 同 level 的排序，就需要一些暗示信息。例如记录来自某个数据库。UNIMARC 格式的库，可以让中文的字符串稍微级别高一点
                authors.Sort(new AuthorLevelComparer());

                one = authors[0];
                if (one.Level <= 0)
                {
                    string strWarning = "";
                    string strErrorText = "";
                    foreach (AuthorLevel author in authors)
                    {
                        if (author.Level == -1)
                        {
                            if (string.IsNullOrEmpty(strErrorText) == false)
                                strErrorText += "; ";
                            strErrorText += author.Author;
                        }
                        if (author.Level == 0)
                        {
                            if (string.IsNullOrEmpty(strWarning) == false)
                                strWarning += "; ";
                            strWarning += author.Author;
                        }
                    }

                    if (string.IsNullOrEmpty(strErrorText) == false)
                    {
                        strError = strErrorText;
                        return -1;
                    }

                    strError = strWarning;
                    return 0;
                }
            }

            if (one.Level == -1)
            {
                strError = one.Author;
                return -1;
            }
            if (one.Level == 0)
            {
                strError = one.Author;
                return 0;
            }

            // 2014/4/15
            if (one.Type == "<无>"
                || one.Type == "手动")
            {
                strQufenhao = one.Author;
                return 1;
            }

            // *** 第三阶段，从著者字符串创建著者号
            {
                string type = one.Type;
                string strAuthor = one.Author;
                Debug.Assert(String.IsNullOrEmpty(strAuthor) == false, "");

            REDO:
                if (type == "GCAT")
                {
                    // 获得著者号
                    string strGcatWebServiceUrl = Program.MainForm.GcatServerUrl;   // "http://dp2003.com/dp2libraryws/gcat.asmx";

                    // 获得著者号
                    // return:
                    //      -4  ??
                    //      -1  error
                    //      0   canceled
                    //      1   succeed
                    nRet = GetGcatAuthorNumber(strGcatWebServiceUrl,
                        strAuthor,
                        out strQufenhao,
                        out strError);
                    if (nRet == -1)
                        goto ERROR1;

                    // 放弃回答问题
                    if (nRet == 0)
                    {
                        if (string.IsNullOrEmpty(strError) == true)
                            strError = "放弃从 GCAT 取号";
                        return 0;
                    }

                    return 1;
                }
                else if (type == "四角号码")
                {
                    // 获得著者号
                    // return:
                    //      -1  error
                    //      0   canceled
                    //      1   succeed
                    nRet = GetSjhmAuthorNumber(
                        strAuthor,
                        out strQufenhao,
                        out strError);
                    if (nRet == -1)
                        goto ERROR1;

                    // 放弃回答问题
                    if (nRet == 0)
                    {
                        if (string.IsNullOrEmpty(strError) == true)
                            strError = "放弃从四角号码取号";
                        return 0;
                    }
                    return 1;
                }
                else if (type == "Cutter-Sanborn Three-Figure")
                {
                    // 获得著者号
                    // return:
                    //      -1  error
                    //      0   canceled
                    //      1   succeed
                    nRet = GetCutterAuthorNumber(
                        strAuthor,
                        out strQufenhao,
                        out strError);
                    if (nRet == -1)
                        goto ERROR1;

                    // 放弃回答问题
                    if (nRet == 0)
                    {
                        if (string.IsNullOrEmpty(strError) == true)
                            strError = "放弃从卡特表取号";
                        return 0;
                    }

                    return 1;
                }
#if SHITOUTANG
                else if (type == "石头汤著者号"
                    || type == "石头汤")
                {
                    strQufenhao = strAuthor;
                    return 1;
                }
#endif
                else if (type == "手动")
                {
                    strQufenhao = "?";
                    return 1;
                }
                else if (type == "<无>")
                {
                    strQufenhao = "";
                    return 1;
                }
                else
                {
                    strError = "未知的区分号类型 '" + type + "'";
                    goto ERROR1;
                }
            }
        //return 0;
        ERROR1:
            return -1;
        }


		~~~~~~~~~~~~
		        // TODO: 可否把循环过程做成一个 Loader 类？注意解决网络环境不良时候的重试操作问题
        // 注意：上级函数RunScript()已经使用了BeginLoop()和EnableControls()
        // 对每个书目记录进行循环
        // return:
        //      0   普通返回
        //      1   要全部中断
        int DoLoop(out string strError,
            out string strWarning)
        {
            strError = "";
            strWarning = "";

            int nRet = 0;
            long lRet = 0;

            bool bSyntaxWarned = false;
            bool bFilterWarned = false;

            // List<string> LogFileNames = null;

            // 清除错误信息窗口中残余的内容
            ClearErrorInfoForm();

            /*
            // 馆藏地点过滤列表
            string strLocationList = this.textBox_locationNames.Text;
            if (String.IsNullOrEmpty(strLocationList) == true)
                strLocationList = "*";

            string[] locations = strLocationList.Split(new char[] { ',' });

            StringMatchList location_matchlist = new StringMatchList(locations);

            // 读者类型过滤列表
            string strItemTypeList = this.textBox_itemTypes.Text;
            if (String.IsNullOrEmpty(strItemTypeList) == true)
                strItemTypeList = "*";

            string[] itemtypes = strItemTypeList.Split(new char[] { ',' });

            StringMatchList itemtype_matchlist = new StringMatchList(itemtypes);
             * */

            // 记录路径临时文件
            string strTempRecPathFilename = Path.GetTempFileName();

            string strInputFileName = "";   // 外部制定的输入文件，为条码号文件或者记录路径文件格式
            string strAccessPointName = "";

            try
            {

                if (this.InputStyle == BiblioStatisInputStyle.BatchNo)
                {
                    nRet = SearchBiblioRecPath(
                        this.tabComboBox_inputBatchNo.Text,
                        strTempRecPathFilename,
                        out strError);
                    if (nRet == -1)
                        return -1;

                    strInputFileName = strTempRecPathFilename;
                    strAccessPointName = "记录路径";
                }
                else if (this.InputStyle == BiblioStatisInputStyle.RecPathFile)
                {
                    strInputFileName = this.textBox_inputRecPathFilename.Text;
                    strAccessPointName = "记录路径";
                }
                else if (this.InputStyle == BiblioStatisInputStyle.RecPaths)
                {
                    using (StreamWriter sw = new StreamWriter(strTempRecPathFilename, false, Encoding.UTF8))
                    {
                        sw.Write(this.textBox_inputStyle_recPaths.Text);
                    }

                    strInputFileName = strTempRecPathFilename;
                    strAccessPointName = "记录路径";
                }
                else
                {
                    Debug.Assert(false, "");
                }

                StreamReader sr = null;

                try
                {
                    sr = new StreamReader(strInputFileName, Encoding.UTF8);
                }
                catch (Exception ex)
                {
                    strError = "打开文件 " + strInputFileName + " 失败: " + ex.Message;
                    return -1;
                }

                this.progressBar_records.Minimum = 0;
                this.progressBar_records.Maximum = (int)sr.BaseStream.Length;
                this.progressBar_records.Value = 0;

                /*
                stop.OnStop += new StopEventHandler(this.DoStop);
                stop.Initial("正在获取书目记录 ...");
                stop.BeginLoop();

                EnableControls(false);
                 * */

                try
                {
                    int nCount = 0;

                    for (int i = 0; ; i++)
                    {
                        Application.DoEvents();	// 出让界面控制权

                        if (stop != null)
                        {
                            if (stop.State != 0)
                            {
                                DialogResult result = MessageBox.Show(this,
                                    "准备中断。\r\n\r\n确实要中断全部操作? (Yes 全部中断；No 中断循环，但是继续收尾处理；Cancel 放弃中断，继续操作)",
                                    "bibliostatisform",
                                    MessageBoxButtons.YesNoCancel,
                                    MessageBoxIcon.Question,
                                    MessageBoxDefaultButton.Button3);

                                if (result == DialogResult.Yes)
                                {
                                    strError = "用户中断";
                                    return -1;
                                }
                                if (result == DialogResult.No)
                                    return 0;   // 假装loop正常结束

                                stop.Continue(); // 继续循环
                            }
                        }

                        // string strItemBarcode = barcodes[i];
                        string strRecPath = sr.ReadLine();

                        if (strRecPath == null)
                            break;

                        strRecPath = strRecPath.Trim();
                        nRet = strRecPath.IndexOf("\t");
                        if (nRet != -1)
                            strRecPath = strRecPath.Substring(0, nRet).Trim();

                        if (String.IsNullOrEmpty(strRecPath) == true)
                            continue;

                        stop.SetMessage("正在获取第 " + (i + 1).ToString() + " 个书目记录，" + strAccessPointName + "为 " + strRecPath);
                        this.progressBar_records.Value = (int)sr.BaseStream.Position;

                        // 获得书目记录
                        // string strOutputRecPath = "";
                        // byte[] baTimestamp = null;


                        string strAccessPoint = "";
                        if (this.InputStyle == BiblioStatisInputStyle.BatchNo)
                            strAccessPoint = strRecPath;
                        else if (this.InputStyle == BiblioStatisInputStyle.RecPathFile)
                            strAccessPoint = strRecPath;
                        else if (this.InputStyle == BiblioStatisInputStyle.RecPaths)
                            strAccessPoint = strRecPath;
                        else
                        {
                            Debug.Assert(false, "");
                        }

                        string strBiblio = "";
                        // string strBiblioRecPath = "";

#if NO
                        // Result.Value -1出错 0没有找到 1找到 >1命中多于1条
                        lRet = Channel.GetBiblioInfo(
                            stop,
                            strAccessPoint,
                            "", // strBiblioXml
                            "xml",   // strResultType
                            out strBiblio,
                            out strError);
#endif
                        string[] formats = new string[1];
                        formats[0] = "xml";
                        string[] results = null;
                        byte[] baTimestamp = null;
                        lRet = Channel.GetBiblioInfos(
                            stop,
                            strAccessPoint,
                            "",
                            formats,
                            out results,
                            out baTimestamp,
                            out strError);
                        if (lRet == -1)
                        {
                            strError = "获得书目记录 " + strAccessPoint + " 时发生错误: " + strError;
                            GetErrorInfoForm().WriteHtml(strError + "\r\n");
                            continue;
                        }

                        if (lRet == 0)
                        {
                            strError = "书目记录" + strAccessPointName + " " + strRecPath + " 对应的XML数据没有找到。";
                            GetErrorInfoForm().WriteHtml(strError + "\r\n");
                            continue;
                        }

                        if (lRet > 1)
                        {
                            strError = "书目记录" + strAccessPointName + " " + strRecPath + " 对应数据多于一条。";
                            GetErrorInfoForm().WriteHtml(strError + "\r\n");
                            continue;
                        }

                        if (results == null || results.Length == 0)
                        {
                            strError = "书目记录" + strAccessPointName + " " + strRecPath + " 获取时 results 出错。";
                            GetErrorInfoForm().WriteHtml(strError + "\r\n");
                            continue;
                        }
                        strBiblio = results[0];
                        objStatis.Timestamp = baTimestamp;

                        string strXml = "";

                        strXml = strBiblio;


                        // 看看是否在希望统计的范围内
                        XmlDocument dom = new XmlDocument();
                        try
                        {
                            dom.LoadXml(strXml);
                        }
                        catch (Exception ex)
                        {
                            strError = "书目记录装入DOM发生错误: " + ex.Message;
                            continue;
                        }

                        /*
                        // 按照馆藏地点筛选
                        if (this.textBox_locationNames.Text != ""
                            && this.textBox_locationNames.Text != "*")
                        {
                            // 注：空字符串或者"*"表示什么都满足。也就等于不使用此筛选项

                            string strLocation = DomUtil.GetElementText(dom.DocumentElement,
                                "location");
                            if (location_matchlist.Match(strLocation) == false)
                                continue;
                        }

                        // 按照册类型筛选
                        if (this.textBox_itemTypes.Text != ""
                            && this.textBox_itemTypes.Text != "*")
                        {
                            // 注：空字符串或者"*"表示什么都满足。也就等于不使用此筛选项

                            string strItemType = DomUtil.GetElementText(dom.DocumentElement,
                                "bookType");
                            if (itemtype_matchlist.Match(strItemType) == false)
                                continue;
                        }
                         * */

                        // Debug.Assert(false, "");

                        // strXml中为书目记录
                        string strBiblioDbName = Global.GetDbName(strRecPath);

                        string strSyntax = Program.MainForm.GetBiblioSyntax(strBiblioDbName);
                        if (String.IsNullOrEmpty(strSyntax) == true)
                            strSyntax = "unimarc";

                        bool bItemDomsCleared = false;

                        if (strSyntax == "usmarc" || strSyntax == "unimarc")
                        {
                            // 将XML书目记录转换为MARC格式
                            string strOutMarcSyntax = "";
                            string strMarc = "";

                            // 将MARCXML格式的xml记录转换为marc机内格式字符串
                            // parameters:
                            //		bWarning	==true, 警告后继续转换,不严格对待错误; = false, 非常严格对待错误,遇到错误后不继续转换
                            //		strMarcSyntax	指示marc语法,如果==""，则自动识别
                            //		strOutMarcSyntax	out参数，返回marc，如果strMarcSyntax == ""，返回找到marc语法，否则返回与输入参数strMarcSyntax相同的值
                            nRet = MarcUtil.Xml2Marc(strXml,
                                true,   // 2013/1/12 修改为true
                                "", // strMarcSyntax
                                out strOutMarcSyntax,
                                out strMarc,
                                out strError);
                            if (nRet == -1)
                                return -1;

                            if (String.IsNullOrEmpty(strOutMarcSyntax) == false)
                            {
                                if (strOutMarcSyntax != strSyntax
                                    && bSyntaxWarned == false)
                                {
                                    strWarning += "书目记录 " + strRecPath + " 的syntax '" + strOutMarcSyntax + "' 和其所属数据库 '" + strBiblioDbName + "' 的定义syntax '" + strSyntax + "' 不一致\r\n";
                                    bSyntaxWarned = true;
                                }
                            }

                            objStatis.MarcRecord = strMarc;

                            if (this.MarcFilter != null)
                            {
                                // 触发Script中PreFilter()代码
                                if (objStatis != null)
                                {
                                    objStatis.Xml = strXml;
                                    objStatis.BiblioDom = dom;
                                    objStatis.CurrentDbSyntax = strSyntax;  // strOutputMarcSyntax?
                                    objStatis.CurrentRecPath = strRecPath;
                                    objStatis.CurrentRecordIndex = i;
                                    bItemDomsCleared = true;
                                    objStatis.ClearItemDoms();
                                    objStatis.ClearOrderDoms();
                                    objStatis.ClearIssueDoms();
                                    objStatis.ClearCommentDoms();

                                    StatisEventArgs args = new StatisEventArgs();
                                    objStatis.PreFilter(this, args);
                                    if (args.Continue == ContinueType.SkipAll)
                                        return 1;
                                }

                                // 触发filter中的Record相关动作
                                nRet = this.MarcFilter.DoRecord(
                                    null,
                                    objStatis.MarcRecord,
                                    strOutMarcSyntax,   // 2012/9/6
                                    i,
                                    out strError);
                                if (nRet == -1)
                                    return -1;
                            }
                        }
                        else
                        {
                            objStatis.MarcRecord = "";

                            if (this.MarcFilter != null
                                && bFilterWarned == false)
                            {
                                // TODO: 是否需要警告？因为配置了filter, 但是因为所涉及的库不是MARC格式，没有办法应用
                                // 可以最后集中警告一次
                                strWarning += "当前统计方案中配置了MarcFilter，但是因为数据库 '" + strBiblioDbName + "' (可能不仅限于这一个数据库)的定义syntax '" + strSyntax + "' 不是MARC类格式，所以统计过程中至少对这个库无法启用MarcFilter功能。\r\n";
                                bFilterWarned = true;
                            }
                        }

                        // 触发Script中OnRecord()代码
                        if (objStatis != null)
                        {
                            objStatis.Xml = strXml;
                            objStatis.BiblioDom = dom;
                            objStatis.CurrentDbSyntax = strSyntax;  // strOutputMarcSyntax?
                            objStatis.CurrentRecPath = strRecPath;
                            objStatis.CurrentRecordIndex = i;
                            if (bItemDomsCleared == false)
                            {
                                objStatis.ClearItemDoms();
                                objStatis.ClearOrderDoms();
                                objStatis.ClearIssueDoms();
                                objStatis.ClearCommentDoms();
                                bItemDomsCleared = true;
                            }

                            StatisEventArgs args = new StatisEventArgs();
                            objStatis.OnRecord(this, args);
                            if (args.Continue == ContinueType.SkipAll)
                                return 1;
                        }

                        nCount++;
                    }

                }
                finally
                {
                    /*
                    EnableControls(true);

                    stop.EndLoop();
                    stop.OnStop -= new StopEventHandler(this.DoStop);
                    stop.Initial("");
                     * */

                    if (sr != null)
                        sr.Close();
                }
            }
            finally
            {
                File.Delete(strTempRecPathFilename);
            }

            return 0;
        }