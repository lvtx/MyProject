using System;
using System.Xml;
using System.Threading ;
using System.Collections ;
using System.Data;
using System.Data.SqlClient;
using System.IO ;
using System.Globalization;
using System.Text;

using DigitalPlatform.Xml ;
using DigitalPlatform.Text ;
using DigitalPlatform.IO ;
using DigitalPlatform.Store ;
using DigitalPlatform;  //用到自定义的Exception
using DigitalPlatform.rms ;
using DigitalPlatform.Threading ;
using DigitalPlatform.ResultSet ;


namespace DigitalPlatform.rms
{
	public delegate bool IsConnected(string strText);

	//专门用于检索的类
	public class DatabaseCommandTask
	{
		public SqlCommand m_command = null;
		public AutoResetEvent m_event = new AutoResetEvent(false);
		public bool bError= false;
		public string strErrorInfo = "";
		public SqlDataReader m_dataReader = null; //供外部使用

		public DatabaseCommandTask(SqlCommand command)
		{
			m_command = command;
		}

		public void Cancel()
		{
			m_command.Cancel();
		}

		public void ThreadMain()
		{
			try
			{
				//FileUtil.WriteText ("L:\\debug.txt","开始做ExecuteReader---时间"+System.DateTime.Now.ToString ()+"\r\n");
				m_dataReader = m_command.ExecuteReader();
			}
			catch (Exception ex)
			{
				bError = true;
				strErrorInfo += "检索线程:"+ex.Message;
				//FileUtil.WriteText("L:\\debug.txt","["+strErrorInfo+"]------时间"+System.DateTime.Now.ToString ()+"\r\n");
			}
			finally
			{
				m_event.Set();
			}
			//FileUtil.WriteText("L:\\debug.txt","正常完成------时间"+System.DateTime.Now.ToString ()+"\r\n");
		}
	}


	public delegate int RestoreDelegate(int nCount,long nPosition);

	//数据库集合
	public class DatabaseCollection : ArrayList
	{
		#region 成员变量

		//调试信息
		public string m_strDebugInfo = "";

		//定义了一种锁，提供唯一写/多读的机制，使得读写的同步
		private ReaderWriterLock m_lock = new ReaderWriterLock();

		//申请锁的时间，超过则退出，避免死锁
		private int m_nTimeOut = 60000;  //1分钟

		//存放虚拟目录路径
		private string m_strRootDir;
	
		// 配置文件目录路径
		private string m_strCfgDir;  

		//所有库总配置xml文件名称，如databases.xml，纯粹文件名，不包含路径
		private string m_fileName; 

		//对应databases.xml的Dom
		private XmlDocument m_dom = null;  

		//帐户集合指针，
		//主要用于修改帐户库记录时，刷新当前帐户
		public UserCollection m_userColl;

		//在服务器上存放备份文件的目录地址
		public string m_strBackUpDir;

		public RestoreDelegate restoreDelegate = null;

		#endregion

		#region 构造函数 与 析构函数

		~DatabaseCollection()
		{
			Close();
		}

		//构造函数
		public DatabaseCollection()
		{
		}

		//两参数构造函数
		//strDbsFileName: 数据库配置文件
		//strRootDir: 根目录文件
		public DatabaseCollection(string strDbsFileName,
			string strRootDir)
		{
			m_strRootDir = strRootDir;

			//配置文件目录\data\，
			//记住最后是加"\"，在用到的地方不用再加了
			m_strCfgDir = m_strRootDir + "\\data" + "\\"; 

			//调Create()函数，
			//根据数据库总配置XML文件，创建多个数据库，加到集合里
			CreateBy(strDbsFileName);
		}

		#endregion

		#region 公共函数


		//功能: 合并两个数组
		//strStyle: 运算风格 OR , AND , SUB
		//sourceLeft: 源左边结果集
		//sourceRight: 源右边结果集
		//targetLeft: 目标左边结果集
		//targetMiddle: 目标中间结果集
		//targetRight: 目标右边结果集
		//strInfo: 处理信息
		//返回值:0成功，-1失败
		public static int MergeFileList(ArrayList sourceLeft,
			ArrayList sourceRight,
			ArrayList targetLeft,
			ArrayList targetMiddle,
			ArrayList targetRight,
			out string strInfo)
		{
			strInfo = "";

			int i = 0;   
			int j = 0;

            strInfo += "sourceLeft内容:\r\n";
			strInfo += rmsUtil.ArrayList2String (sourceLeft) + "\r\n";

			strInfo += "sourceRight内容:\r\n";
			strInfo += rmsUtil.ArrayList2String (sourceRight) + "\r\n";

			//上面为指示信息


			string strLeft;
			string strRight;

			int ret;
			while (true)
			{
				strLeft = null;
				strRight = null;
				if (i >= sourceLeft.Count)
				{
					strInfo += "i大于等于sourceLeft的个数，将i改为-1" + "\r\n";
					i = -1;
				}
				else if (i != -1)
				{
					try
					{
						strLeft = (string)sourceLeft[i];
						strInfo += "取出sourceLeft集合中第"+Convert.ToString(i)+"个元素，ID为"+strLeft+"\r\n";
					}
					catch
					{
						Exception ex = new Exception("i="+Convert.ToString(i)+"----Count="+Convert.ToString(sourceLeft.Count)+"<br/>");
						throw(ex);
					}
				}
				if (j >= sourceRight.Count)
				{
					strInfo += "j大于等于sourceRight的个数，将j改为-1" + "\r\n";
					j = -1;
				}
				else if (j != -1)
				{
					try
					{
						strRight = (string)sourceRight[j];
						strInfo += "取出sourceRight集合中第"+Convert.ToString(j)+"个元素，ID为"+strRight+"\r\n";
					}
					catch
					{
						Exception ex = new Exception("j="+Convert.ToString(j)+"----Count="+Convert.ToString(sourceLeft.Count)+sourceRight.GetHashCode()+"<br/>");
						throw(ex);
					}
				}
				if (i == -1 && j == -1)
				{
					strInfo += "i,j都等于-1跳出" + "\r\n";
					break;
				}

				if (strLeft == null)
				{
					strInfo += "strLeft为null，设ret等于1" + "\r\n";
					ret = 1;
				}
				else if (strRight == null)
				{
					strInfo += "strRight为null，设ret等于-1" + "\r\n";
					ret = -1;
				}
				else
				{
					ret = strLeft.CompareTo(strRight);  //MyCompareTo(oldOneKey); //改CompareTO
					strInfo += "strLeft与strLeft均不为null，比较strLeft:"+strLeft+"与strRight:" + strRight+ "两条记录得到ret等于"+Convert.ToString(ret) + "\r\n";
				}

				if (ret == 0 && targetMiddle != null) 
				{
					strInfo += "ret等于0,加到targetMiddle里面" + "\r\n";
					targetMiddle.Add(strLeft);
					i++;
					j++;
				}

				if (ret<0) 
				{
					strInfo += "ret小于0,加到targetLeft里面" + "\r\n";

					if (targetLeft != null && strLeft != null)
						targetLeft.Add(strLeft);
					i++;
				}

				if (ret>0 )
				{
					strInfo += "ret大于0,加到targetRight里面" + "\r\n";

					if (targetRight != null && strRight != null)
						targetRight.Add(strRight);

					j++;
				}
			}
			return 0;
		}


		//根据数据库信息文件，创建每一个Database,加到本集合里，
		//注意根据不同的type值，
		//创建不同的类实例:file-->FileDatabase，其它-->SqlDatabase
		//strFileName: 传入的数据库总配置文件名
		//返回值: 0:正常  出错会抛出异常
		//线: 安全的
		//创建数据库并加到集合的的时候,
		//即不能读dom也不能写dom，所以加写锁
		public int CreateBy(string strDbsFileName)
		{
			//**********对库集合加写锁****************
			m_lock.AcquireWriterLock(m_nTimeOut); 

			try
			{
				//给m_fileName赋值
				m_fileName = strDbsFileName;
			
				//给m_dom赋值,并加载XML文件
				if (m_dom == null)
					m_dom = new XmlDocument();
				try
				{
					m_dom.Load(m_fileName);
				}
				catch (Exception ex)  //如果数据库总配置XML文件有格式错误，抛出异常
				{
					Exception ex1 = new Exception ("加载" + m_fileName + "到dom时出错 "+ex.Message );
					throw(ex1);
				}

				//得到数据库节点列表
				XmlNodeList listDatabase;
				listDatabase =
					m_dom.SelectNodes(@"/root/dbs/database");

				foreach(XmlNode nodeDb in listDatabase)
				{
					string strType = DomUtil.GetAttr(nodeDb,"type");
					strType = strType.Trim();

					//file类型创建为FileDatabase对象，其它创建为SqlDatabase对象
					if (StringUtil.isInList("file",strType) == true)
					{
						Add(new FileDatabase(nodeDb,this));
					}
					else
					{
						Add(new SqlDatabase(nodeDb,this));
					}
				}
			}
			finally
			{
				m_lock.ReleaseWriterLock();  
				//***********解库集合写锁****************
			}
			return 0;
		}


		//关闭
		public int Close()
		{
			SaveXml();
			return 0;
		}

		//写数据库总配置XML文件
		//注意:一部分节点不变，一部分节点被覆盖
		//线: 安全的
		public void SaveXml()
		{
			//******************加写锁******
			m_lock.AcquireWriterLock(m_nTimeOut); 

			try
			{
				string strTemp;
				strTemp = "";
				foreach(Database oneDb in this)
				{
					strTemp += oneDb.m_nodeRoot.OuterXml;  //每个数据库都有一个m_nodeRoot结构节点
				}
				XmlNode nodeDbs;
				nodeDbs = m_dom.SelectSingleNode("/root/dbs");

				//可能使用innerXml较慢
				nodeDbs.InnerXml = strTemp;

				m_dom.Save(m_fileName);
			}
			finally
			{
				m_lock.ReleaseWriterLock(); 
				//*************解写锁***********
			}
		}

		#endregion

		#region 属性

		//得到虚拟目录路径
		public string RootDir
		{
			get
			{
				return m_strRootDir;
			}
			set
			{
				m_strRootDir = value;
			}
		}

		//get or set CfgDir，配置文件目录路径
		public string CfgDir
		{
			get
			{
				return m_strCfgDir;
			}
			set 
			{
				m_strCfgDir = value;
			}
		}

		//内部函数(internal可以在本dll中使用)，Key的长度
		//get or set KeySize
		//返回值: int类型，key的长度
		//线: 不安全
		internal int GetKeySize()
		{
			XmlNode nodeKeysize = m_dom.SelectSingleNode("/root/keySize");  //当m_dom为null时就有异常

			string strKeysize =	DomUtil.GetNodeText(nodeKeysize);
			strKeysize = strKeysize.Trim();
			return Convert.ToInt32(strKeysize);  //ToInt32函数当strKeysize为汉字时，有异常
		}

		//线: 安全的
		//加锁原因:从m_dom中读数据了
		public int KeySize
		{
			get
			{
				//**************加读锁
				m_lock.AcquireReaderLock(m_nTimeOut); 

				int nTemp;

				//GetKeySize()可能抛出异常
				try
				{
					nTemp = GetKeySize();
				}
				finally
				{
					m_lock.ReleaseReaderLock(); 
					//*****************解读锁*********
				}
				return nTemp;
			}
		}

		//得到连接字符串，只有库类型为SqlDatabase时才有意思
		//可能会抛出异常
		//string类型，返回连接字符串
		//线: 不安全
		private string GetConnString()
		{
			XmlNode	nodeDataSource = m_dom.SelectSingleNode("/root/datasource");

			string strUserID;  
			strUserID = DomUtil.GetAttr(nodeDataSource,"userID");
			strUserID = strUserID.Trim();

			string strPassword; 
			strPassword = DomUtil.GetAttr(nodeDataSource,"password");
			strPassword = strPassword.Trim();

			string strServerName;  
			strServerName = DomUtil.GetAttr(nodeDataSource,"serverName");	
			strServerName = strServerName.Trim();

			string strConn = @"Persist Security Info=False;"
				+ "User ID=" + strUserID + ";"    //帐户和密码
				+ "Password=" + strPassword + ";"
				//+ "Integrated Security=SSPI; "      //信任连接
				+ "Data Source=" + strServerName + ";"
				+ "Connect Timeout=30";

			return strConn;
		}

		//内部属性,得到链接字符串
		//线: 安全的
		internal string ConnString
		{
			get
			{
				//**************加读锁
				m_lock.AcquireReaderLock(m_nTimeOut);

				string strTemp;

				//GetConnString()函数可能会抛出异常
				try
				{
					strTemp = GetConnString();
				}
				finally
				{
					m_lock.ReleaseReaderLock();  
					//*************解读锁*************
				}
				return strTemp;
			}
		}

		
		//注意以下多个得到数据库成员的函数，对外只透露GetDatabase()及其安全版本GetDatabaseSafety()
		//分析数据库名称格式，找对应数据库
		//strName: 数据库名
		public Database GetDatabase(string strName)
		{
			Database foundDB = null;
			string strFirst = "";
			string strSecond = "";

			int nPosition;
			nPosition = strName.LastIndexOf ("[");
			if (nPosition>=0)
			{
				strFirst = strName.Substring (0,nPosition);
				strSecond = strName.Substring (nPosition+1);
			}
			else
			{
				strFirst = strName;
			}

			if (strFirst != "" && strFirst.Substring (0,1) == "@")
				foundDB = GetDatabaseByID(strFirst);
			else
				foundDB = GetDatabaseByLogicName(strFirst);

			return foundDB;
		}

		//上面函数的安全版本
		public Database GetDatabaseSafety(string strName)
		{
			//******************加读锁******
			m_lock.AcquireReaderLock(m_nTimeOut); 
			Database foundDB = null;
			try
			{
				foundDB = GetDatabase(strName);
			}
			finally
			{
				m_lock.ReleaseReaderLock();  
				//*****************解读锁
			}
			return foundDB;
		}

		//根据逻辑名找数据库，任何语言版本都可以
		public Database GetDatabaseByLogicName(string strLogicName)
		{
			foreach(Database oneDatabase in this)
			{
				if (StringUtil.isInList (strLogicName,
					oneDatabase.GetCaption()) == true)
				{
					return oneDatabase;
				}
			}
			return null;
		}

		//通过数据库ID找到指定的数据库，注意这里的ID带@
		//strId: 数据库ID
		//返回值: 找到返回数据库对象，没找到返回null
		//安全，供内部调
		public Database GetDatabaseByID(string strId)
		{
			foreach(Database oneDatabase in this)
			{
				if (oneDatabase.ID == strId)  
				{
					return oneDatabase;
				}
			}
			return null;
		}

		/*
		/// <summary>
		/// 对应上面函数的安全版本
		/// </summary>
		/// <param name="strId"></param>
		/// <returns></returns>
		public Database GetDatabaseSafetyByID(string strId)
		{
			//******************加读锁******
			m_lock.AcquireReaderLock(m_nTimeOut); 
			Database foundDB = null;
			try
			{
				foundDB = GetDatabaseByID(strId);
			}
			finally
			{
				m_lock.ReleaseReaderLock();  
				//*****************解读锁
			}
			return foundDB;
		}
		*/


		//通过标签和语言找到数据库
		//strDatabaseCaption: 数据库的某种语言标签
		//strLang: 语言版本
		//返回值: 找到返回数据库对象，没找到返回null
		public Database GetDatabaseByLang(string strDatabaseCaption,
			string strLang)
		{
			strDatabaseCaption = strDatabaseCaption.Trim();
			foreach(Database oneDatabase in this)
			{
				if (oneDatabase.GetCaption(strLang) ==	strDatabaseCaption)
				{
					return oneDatabase;
				}
			}
			return null;
		}

		/*
		/// <summary>
		/// 上面函数的安全版本
		/// </summary>
		/// <param name="strDatabaseCaption"></param>
		/// <param name="strLang"></param>
		/// <returns></returns>
		public Database GetDatabaseSafetyByLang(string strDatabaseCaption,
			string strLang)
		{
			//******************加读锁******
			m_lock.AcquireReaderLock(m_nTimeOut); 
			Database foundDB = null;
			try
			{
				foundDB = GetDatabaseByLang(strDatabaseCaption,
					strLang);
			}
			finally
			{
				//*************解读锁
				m_lock.ReleaseReaderLock();  
			}
			return null;
		}
		*/

		#endregion

		#region 检索

		// 检索
		// parameter:
		//		strQuery:    检索式XML字符串
		//		resultSet:   结果集,用于存放检索结果
		//		objUser:     帐户对象,用于检索该帐户对某库是否有读权限
		//				     为null,则不进行权限的检查，即按有权限算
		//		isConnected: delegate对象，用于输出中间信息
		//					 为null，则不调delegate函数
		// return:
		//		0:  successed
		//		-1: error 可能原因如下：
		//			strQuery 或 resultSet为null
		public int DoSearch(string strQuery,
			DpResultSet resultSet,
			User objUser,
			IsConnected isConnected,
			out string strError)
		{
			strError = "";

			//加读锁*********************************
			m_lock.AcquireReaderLock(m_nTimeOut); 
			try
			{
				if (strQuery == null)
				{
					strError = "strQuery不能为空字符串";
					return -1;
				}
				if (resultSet == null)
				{
					strError = "resultSet不为能为空对象";
					return -1;
				}

				//一进来先给结果集的m_strQuery成员赋值，
				//不管是否是合法的XML，在用结果集的时候再判断
				resultSet.m_strQuery = strQuery;

				XmlDocument dom = new XmlDocument();
				try
				{
					dom.LoadXml(strQuery);
				}
				catch(Exception ex)
				{
					Exception exc = new Exception(ex.Message + "------检索式不是合法的XML结构" + "---------" + strQuery);
					throw(exc);
				}

				//将本次的检索信息加入到帐户对象的m_dom里
				objUser.SaveConfig("config/search/UIadvanced",dom.DocumentElement);

				//创建Query对象
				Query oQuery = new Query(this,
					objUser,
					dom);

				//进行检索
				int ret;
				ret = oQuery.doQuery(dom.DocumentElement,
					resultSet,
					isConnected,
					out strError);

				//重新给结果集的m_strQuery赋值，这里已带上警告、出错等信息,
				//dom.DocumentElement已经在doQurey()被修改
				resultSet.m_strQuery = dom.DocumentElement.OuterXml;
				if (ret == -1)
				{
					//设结果集的m_nStatus成员值为-1,表示检索出错
					resultSet.m_nStatus = -1;
					return -1;
				}

				//1表示检索成功
				resultSet.m_nStatus = 1;
			}
			finally
			{
				//****************解锁**************
				m_lock.ReleaseReaderLock(); 
			}
			return 0;
		}

		#endregion

		#region 从结果集中取记录

		//resultSet:结果集对象
		//lStart:开始的序号，按结果集的次序
		//lLength:长度
		//得到包含dpRecord的ArrayList
		//return:
		//0:正常
		//-1:出错，原因可能如下
		//resultSet为null
		//lStart+lLength>resultSet，即超出结果集范围
		public int GetRecordsFromResultSet(DpResultSet resultSet,
			long lStart,
			long lLength,
			out ArrayList aRecord)
		{
			aRecord = null;
			if (lStart+lLength>resultSet.Count )
			{
				return -1;
			}
			aRecord = new ArrayList();
			for( long i=lStart;i<lStart+lLength;i++)
			{
				aRecord.Add (resultSet[i]);
			}
			return 0;
		}

		#endregion

		#region 备份

		//db:数据库
		//nStartID:起始记录号
		//nLength:长度
		//strbackMode:对ID的处理
		//streamTarget:目标流
		//strErrorInfo : 出错信息
		//返回值:
		//-1:出错 0:成功 
		public int Backup(Database db,
			int nStartID,
			long nLength,
			string strbackMode,     //AddID
			Stream streamTarget,
			out string strErrorInfo)
		{
			strErrorInfo = "";
			string strRecordID;
			for(int i= nStartID;i<nStartID+nLength;i++)
			{
				strRecordID = DbPath.GetID10 (Convert.ToString (i));

				//每一条记录用一个临时文件
				string strTempFileName = Path.GetTempFileName();
				FileStream streamTemp =	File.Create(strTempFileName);

				try
				{
					int ret;
					ret = writeRecord(db,
						strRecordID,
						strbackMode,
						streamTemp);
					if (ret == -1)
					{
						strErrorInfo += "writeRecord() error!";
						return -1;
					}

					streamTemp.Seek(0,SeekOrigin.Begin);
					StreamUtil.DumpStream(streamTemp,
						streamTarget);
				}
				finally
				{
					streamTemp.Close ();
					File.Delete (strTempFileName);
				}
			}
			return 0;
		}


		//备份结果集总函数
		//strResultSetName: 结果集名
		//streamTarget: 目标流
		//返回值 0:成功 -1:出错
		public int DoStore(string strResultSetName,
			DpResultSetManager resultSetManager,
			Stream streamTarget,
			string strbackMode,
			bool isOutputInfo,
			System.Web.HttpResponse oResponse,
			out string strInfo)
		{
			strInfo = "";
			if (resultSetManager == null)
			{
				strInfo += "结果集管理器为空<br/>";
				return -1;
			}

			DpResultSet resultSet =	resultSetManager.GetResultSet(strResultSetName);
			if (resultSet == null)
			{
				strInfo += "结果集为空";
				return -1;
			}

			if (resultSet.Count == 0)
			{
				strInfo += "结果集Count为0<br/>";
				return 0;
			}

			bool isValue = true;
			try
			{
				int i = 0;
				int nOneCount = 0;
				foreach(DpRecord oRecord in resultSet)
				{
					if (oResponse.IsClientConnected == true) 
					{
						if (isOutputInfo == true)
						{
							if (nOneCount >= 100)
							{
								oResponse.Write("完成"+Convert.ToString (i)+"<br/>");
								oResponse.Flush();
								nOneCount = 0;
							}
						}

						//每一条记录用一个临时文件
						string strTempFileName = Path.GetTempFileName();
						FileStream streamTemp =	File.Create(strTempFileName);

						int ret;
						ret = writeRecord(oRecord,
							strbackMode,
							streamTemp);
						if (ret == -1)
						{
							strInfo += "writeRecord() error!";
							return -1;
						}

						streamTemp.Seek(0,SeekOrigin.Begin);
						StreamUtil.DumpStream(streamTemp,
							streamTarget);

						streamTemp.Close ();
						File.Delete (strTempFileName);
					}
					else
					{
						strInfo = "通讯中断";
						isValue = false;
						break;
					}
					i++;
					nOneCount++;
				}

				if (isOutputInfo == true)
				{
					oResponse.Write("完成"+Convert.ToString (i)+"<br/>");
					oResponse.Flush();
				}
			}
			finally
			{
				streamTarget.Close ();
			}

			if (isValue == false)
			{
				//File.Delete (m_strDir + strFileName);
				return -1;
			}

			strInfo += "成功备份"+Convert.ToString (resultSet.Count)+"条记录<br/>";
			return 0;
		}


		public int writeRecord(DpRecord oRecord,
			string strbackMode,
			FileStream streamTarget)
		{
			//m_strDebugInfo += "走进writeRecord里<br/>";

			string strIDComplete = oRecord.ID;
			int nPosition;
			nPosition = strIDComplete.IndexOf(":");

			string strDbID = "";
			string strRecordID = "";
			if (nPosition>0)
			{
				strDbID = strIDComplete.Substring (0,nPosition);
				strRecordID = strIDComplete.Substring (nPosition+1);
			}

			//m_strDebugInfo += "数据库ID"+strDbID+"------记录ID"+strRecordID+"<br/>";
			Database db = GetDatabaseSafety(strDbID);
			if (db == null)
			{
				//m_strDebugInfo += "没找到数据库ID"+strDbID+"<br/>";
				return -1;
			}

			return writeRecord(db,
				strRecordID,
				strbackMode,
				streamTarget);
		}

		//写一条记录
		public int writeRecord(Database db,
			string strRecordID,
			string strbackMode,
			FileStream streamTarget)
		{
			MemoryStream mfs = new MemoryStream ();
			string strContentType;
			int nRet = db.GetRecord(strRecordID,mfs,out strContentType,null,false);
			if (nRet == -1)
				return -1;

			long lTotalLength = 0;  //总长度

			//长度字节数组
			byte[] sufferLength = new byte[8];

			//1.开头空出8字节，最后写总长度*****************
			streamTarget.Write(sufferLength,0,8);
			//lTotalLength += 8;

			//m_strDebugInfo += "开头空8个字节<br/>";


			//将XMLstream加载到dom，修改id，下面找到所有file
			mfs.Seek(0,SeekOrigin.Begin);
			XmlDocument dom = new XmlDocument();
			dom.Load (mfs);

			if (strbackMode == "completeID")
			{
				XmlNode nodeID = dom.SelectSingleNode ("//__id");
				string strCompleteID = db.ID+":"+DomUtil.GetNodeText (nodeID);
				DomUtil.SetNodeText (nodeID,strCompleteID);
			}

			//2.加XMl文件包*******************
			MemoryStream mfs1 = new MemoryStream ();
			dom.Save (mfs1);
			mfs1.Seek(0,SeekOrigin.Begin);
			MemoryStream msTemp = new MemoryStream ();
			writeXml(mfs1,msTemp);
			mfs1.Close ();

			//这一句话非常重要
			msTemp.Seek(0,SeekOrigin.Begin);   

			StreamUtil.DumpStream (msTemp,
				streamTarget);

			lTotalLength += msTemp.Length ;

			msTemp.Close ();

			//m_strDebugInfo += "加XML包<br/>";



			//将XMLstream加载到dom，以便找到所有file
			//mfs.Seek(0,SeekOrigin.Begin);
			//XmlDocument dom = new XmlDocument();
			//dom.Load (mfs);
			//mfs.Close ();

			XmlNodeList listFile = dom.SelectNodes ("//file");

			
			foreach(XmlNode nodeFile in listFile)
			{
				string strTempFileName =
					Path.GetTempFileName();

				FileStream streamTempFile =
					File.Create(strTempFileName);


				//m_strDebugInfo += "调writeFile函数加文件包<br/>";

				int ret ;
				ret = writeFile(nodeFile,
					db,
					strRecordID,
					streamTempFile);


				if (ret == -1)
					continue;

				//3.写每个文件包*************
				streamTempFile.Seek(0,SeekOrigin.Begin);
				StreamUtil.DumpStream (streamTempFile,
					streamTarget);

				lTotalLength += streamTempFile.Length ;
				

				streamTempFile.Close ();

				File.Delete (strTempFileName);
			}



			//4.写总长度

			sufferLength =
				System.BitConverter.GetBytes(lTotalLength);

			//把指针移到哪里？移到开头是不正确的，第二条就不对了
			//streamTarget.Seek (0,SeekOrigin.End);
			//long nTemp = streamTarget.Position;
			//nTemp = nTemp-lTotalLength-8;
			//streamTarget.Seek (nTemp,SeekOrigin.Begin);

			streamTarget.Seek (0,SeekOrigin.Begin);
			streamTarget.Write (sufferLength,0,8);

			//m_strDebugInfo += "写本记录总长度<br/>";


			//将指针移到最后
			streamTarget.Seek (0,SeekOrigin.End);
			return 0;
		}


		//写XML数据
		public int writeXml(Stream source ,
			Stream target)
		{
			//m_strDebugInfo += "进writeXml函数里<br/>";

			byte[] sufferLength = new byte[8];

			sufferLength = 
				System.BitConverter.GetBytes(source.Length);
			
			//m_strDebugInfo += "Xml文件的字符数"+source.Length+"<br/>";

			target.Write(sufferLength,0,8);
			source.Seek (0,SeekOrigin.Begin);
			StreamUtil.DumpStream (source,target);
			//m_strDebugInfo += "source的字符数"+Convert.ToString(source.Length)+"-------target的字符数"+Convert.ToString(target.Length) +"<br/>";
			return 0;
		}



		//写子文件数据
		//返回值:
		//0,正常得到文件内容
		//-1,文件名为空
		public int writeFile(XmlNode nodeFile,
			Database db,
			string strRecordID,
			FileStream streamTarget)
		{
			//m_strDebugInfo += "进入到writeFile函数里<br/>";

			string strFileName =
				DomUtil.GetNodeText(nodeFile);

			//m_strDebugInfo += "文件名"+strFileName+"<br/>";
			if (strFileName == "")
			{
				//m_strDebugInfo += "文件名为空，返回-1<br/>";
				return -1;
			}

			long lTotalLength = 0;  //总长度

			//长度字节数组
			byte[] sufferLength = new byte[8];

			//1.开头空出8字节，最后写总长度*****************
			streamTarget.Write(sufferLength,0,8);
			//lTotalLength += 8;

			//m_strDebugInfo += "空出8个字节<br/>";

			//2.先写名称字符串的长度;

			//将字符串转换成字符数组
			byte[] sufferFileName =
				System.Text.Encoding.UTF8.GetBytes(strFileName);

			sufferLength =
				System.BitConverter.GetBytes((long)sufferFileName.Length);


			//m_strDebugInfo += "文件名称的长度"+Convert.ToString(sufferFileName.Length)+"<br/>";


			streamTarget.Write (sufferLength,0,8);

			lTotalLength += 8;


			//3.写名称字符串
			streamTarget.Write (sufferFileName,
				0,
				sufferFileName.Length );

			lTotalLength += sufferFileName.Length;

			string strFileID = strRecordID + "_" + strFileName;
			//m_strDebugInfo += "备份文件时的名称:"+strFileID;

			string strTempName =
				Path.GetTempFileName();

			FileStream streamTemp =
				File.Create(strTempName);

			string strContentType;
			db.GetRecord(strFileID,
				streamTemp,
				out strContentType,
				null,
				false);

			sufferLength =
				System.BitConverter.GetBytes(streamTemp.Length);

			//4.二进制文件的长度;
			streamTarget.Write (sufferLength,0,8);

			lTotalLength += 8;


			//5.写真正的二进制文件
			streamTemp.Seek (0,SeekOrigin.Begin);
			StreamUtil.DumpStream (streamTemp,
				streamTarget);


			lTotalLength += streamTemp.Length ;

			//关闭临时stream,删除临时文件
			streamTemp.Close();
			File.Delete (strTempName);


			//6.返回开头写总长度

			sufferLength =
				System.BitConverter.GetBytes(lTotalLength);

			streamTarget.Seek (0,SeekOrigin.Begin);
			streamTarget.Write (sufferLength,0,8);

			//将指针移到最后
			streamTarget.Seek (0,SeekOrigin.End);

			return 0;

		}


		#endregion


		#region 总恢复函数

		//恢复XML类型的数据
		//参数:
		//streamSource: 源流
		//strDataType: 数据类型，为固定值: xml(Xml文件),bin(bin文件)
		//db: 数据库
		//strMode:恢复方式,override:覆盖，append:追加
		//strErrorInfo: 处理信息
		//返回值:
		//-1:出错  0:成功  >0:恢复的记录数
		public int Restore(Stream streamSource,
			string strDataType,
			Database db,
			string strMode,
			out string strErrorInfo)
		{
			strErrorInfo = "";
			if (streamSource == null)
			{
				strErrorInfo = "在Restore()函数，参数streamSource为null";
				return -1;
			}
			if (strDataType == null)
			{
				strErrorInfo = "在Restore()函数，参数strDataType为null";
				return -1;
			}
			if (strMode == null)
			{
				strErrorInfo = "在Restore()函数，参数strMode为null";
				return -1;
			}
			if (db == null)
			{
				strErrorInfo = "在Restore()函数，参数db为null";
				return -1;
			}

			int nRet = -1;

			if (strDataType == "xml")
			{
				nRet = this.RestoreFromXml (streamSource,
					db,
					strMode,
					out strErrorInfo);
			}
			else if (strDataType == "bin")
			{
				nRet = this.RestoreFromBin (streamSource,
					db,
					strMode,
					out strErrorInfo);
			}
			else
			{
				strErrorInfo = "在Restore()函数，strDataType参数值为" + strDataType + "不是合法的值，必须为xml或bin";
				return -1;
			}
			return nRet;
		}


		#endregion

		#region 恢复Xml格式数据

		//恢复XML类型的数据
		//参数:
		//streamSource: 源流
		//db: 数据库
		//strMode:恢复方式,override:覆盖，append:追加
		//strErrorInfo: 处理信息
		//返回值:
		//-1:出错 ;>=0:恢复的记录数
		public int RestoreFromXml(Stream streamSource,
			Database db,
			string strMode,
			out string strErrorInfo)
		{
			strErrorInfo = "";
			if (streamSource == null)
			{
				strErrorInfo = "在RestoreFromXml()函数，参数streamSource为null";
				return -1;
			}
			if (strMode == null)
			{
				strErrorInfo = "在RestoreFromXml()函数，参数strMode为null";
				return -1;
			}
			if (db == null)
			{
				strErrorInfo = "在RestoreFromXml()函数，参数db为null";
				return -1;
			}

			streamSource.Seek (0,SeekOrigin.Begin);
			int nCount = 0;
			int nRet = 0;
			string strPartErrorInfo;
			XmlTextReader reader = null;
			try
			{
				reader = new XmlTextReader (streamSource);

				string strRecordXml = "";
				while (reader.Read())
				{
					//处理每一条记录
					if (reader.Name == "record")
					{
						if (restoreDelegate != null)
						{
							nRet = restoreDelegate(nCount,streamSource.Position);
							if (nRet == -1) //外面停止了
								return 2;
						}

						strRecordXml = reader.ReadOuterXml(); //注意ReadOuterXml会将指针移到下一个节点
						string strRecordID;
						nRet = RestoreRecordFromXml(strRecordXml,
							db,
							strMode,
							null,
							out strRecordID,
							out strPartErrorInfo);

						strErrorInfo += strPartErrorInfo;
						
						if (nRet == -1)  //只要一有错就返回,不再继续恢复后面的记录
							break;

						nCount++;
					}
				}
			}
			finally
			{
				if (reader != null)
				{
					reader.Close ();
					reader = null;
				}
			}
			return nCount;
		}



		public int RestoreRecordFromXml(string strRecordXml,
			Database db,
			string strMode,
			string strID,
			out string strRecordID,
			out string strErrorInfo)
		{
			strRecordID = strID;
			strErrorInfo = "";

			///////////////////////////////////////////
			//首先判断一下传入参数错误
			///////////////////////////////////////////
			if (strRecordXml == null)
			{
				strErrorInfo = "在RestoreRecordFromXml()函数，参数strRecordXml为null";
				return -1;
			}
			if (db == null)
			{
				strErrorInfo = "在RestoreRecordFromXml()函数，参数db为null";
				return -1;
			}
			if (strMode == null)
			{
				strErrorInfo = "在RestoreRecordFromXml()函数，参数strMode为null";
				return -1;
			}
			//不用判断strID,因为strID可以为null，表示不参与处理。


			//1.得到ID
			//DbPath oPath = new DbPath (strID);
			if (strMode == "append")
			{
				strID = "-1";
			}
			else if (strMode == "override")
			{
				//参数ID为空或为null，按数据中的ID算
				if (strID == null)
				{
					//用于找记录ID
					StringReader strReader = new StringReader(strRecordXml);
					XmlTextReader  reader = new XmlTextReader (strReader);
					reader.WhitespaceHandling = WhitespaceHandling.None;
					while (reader.Read())
					{
						if (reader.Name== "__id")//tag" && strValue == "001")
						{
							strID = reader.ReadString () ;
							break;
						}
					}
					reader.Close ();

					if (strID == null)
					{
						strErrorInfo = "在RestoreRecordFromXml()函数,\r\n参数中的strID与数据中的ID均为null,而且是覆盖方式，发生矛盾没法处理了";
						return -1;
					}
					if (StringUtil.isNum (strID) == false )
					{
						strErrorInfo = "在RestoreRecordFromXml()函数,\r\n 数据中的ID为" + strID + "不是合法的ID";
						return -1;
					}
				}
				else
				{
					if (StringUtil.isNum (strID) == false )
					{
						strErrorInfo = "在RestoreRecordFromXml()函数,\r\n参数strID为" + strID + "不是合法的ID";
						return -1;
					}
				}
			}
			else
			{
				strErrorInfo = "在RestoreRecordFromXml()函数,\r\nstrMode的值" + strMode + "不合法，必须为append或者override";
				return -1;
			}

			//2.写到数据库
			//把字符串读入内存Stream
			MemoryStream s = new MemoryStream();
			byte[] aRecord;
			aRecord = Encoding.UTF8.GetBytes(strRecordXml);
			s.Write (aRecord,0,aRecord.Length );

			//写到数据库
			s.Seek (0,SeekOrigin.Begin);
			db.Write(strID,
				s,
				"text/xml",
				false,
				out strRecordID);
			s.Close ();
			return 0;
		}


		#endregion

		#region 恢复bin格式数据


		//恢复Bin格式的备份数据
		//参数:
		//streamSource:源流
		//db:数据库
		//strMode:恢复方式
		//返回值:
		//0:成功  -1:出错  大于0:表示恢复成功，且记录数
		public int RestoreFromBin(Stream streamSource,
			Database db,
			string strMode,
			out string strErrorInfo)
		{
			strErrorInfo = "";
			if (streamSource == null)
			{
				strErrorInfo = "在RestoreBin()函数，参数streamSource为null";
				return -1;
			}
			if (strMode == null)
			{
				strErrorInfo = "在RestoreBin()函数，参数strMode为null";
				return -1;
			}
			if (db == null)
			{
				strErrorInfo = "在RestoreBin()函数，参数db为null";
				return -1;
			}

			streamSource.Seek (0,SeekOrigin.Begin);
			int nRet = -1;
			string strRecordID;
			int nCount = 0;
			string strPartErrorInfo;
			while(true)
			{
				if (restoreDelegate != null)
				{
					nRet = restoreDelegate(nCount,streamSource.Position);
					if (nRet == -1) //外面停止了
						return 2;
				}

				nRet = this.RestoreRecordFromBin(streamSource,
					db,
					strMode,
					null,  //ID
					out strRecordID,
					out strPartErrorInfo);

				nCount ++; //数量不断增加


				if (nRet == 1)//表示完成
					return nCount;

				if (nRet == -1)//当前条记录出错
				{
					strErrorInfo += "第" + Convert.ToString (nCount) + "条出错:" + strPartErrorInfo + "\r\n";
					//当前条出错不应该引用某它条
					//return -1;
				}
			}
		}



		//恢得一条记录
		//参数
		//streamSource:源流
		//strID: 记录ID,纯净的ID，不带库名，可以为null（表示不参与处理）
		//strMode: 恢复方式 append(追加),override(覆盖)
		//db: 数据库
		//strRecordID: out参数,返回恢复成功后的记录号
		//返回值:
		//0:成功 -1:出错  1:一开始就没有数据
		public int RestoreRecordFromBin(Stream streamSource,
			Database db,
			string strMode,
			string strID,
			out string strRecordID,
			out string strErrorInfo)
		{
			strRecordID = strID;
			strErrorInfo = "";

			///////////////////////////////////////////
			//首先判断一下传入参数错误
			///////////////////////////////////////////
			if (streamSource == null)
			{
				strErrorInfo = "在RestoreRecord()函数，参数streamSource为null";
				return -1;
			}
			if (db == null)
			{
				strErrorInfo = "在RestoreRecord()函数，参数db为null";
				return -1;
			}
			if (strMode == null)
			{
				strErrorInfo = "在RestoreRecord()函数，参数strMode为null";
				return -1;
			}
			//不用判断strID,因为strID可以为null，表示不参与处理。



			///////////////////////////////////////////
			//下面开始实做
			///////////////////////////////////////////
			int n = 0;
			byte[] bufferLength = new byte[8];
			long lLength;
			long nMyselfLength = 0; //本记录的总长度
			long nSumLength = 0;    //读一段加一段，不断累加的和，当累加的和等于总长度时，本记录处理完毕，当累加的和大于总长度时，返回-1，出错；

			//1.读出总长度************************
			//要用一个变量累加长度，如果与总长度相同才是正确的。
			n = streamSource.Read(bufferLength,0,8);
			if (n<8)
			{
				strErrorInfo = "一开始没有数据了";
				return 1;
			}
			nMyselfLength = System.BitConverter.ToInt64(bufferLength,0);


			//2.得到XML包***************************
			n = streamSource.Read(bufferLength,0,8);
			if (n<8)
			{
				strErrorInfo += "取Xml包的前8个字节出错";
				return -1;
			}
			nSumLength += 8; //*加8字节的长度

			//2.1读出Xml
			lLength = System.BitConverter.ToInt64(bufferLength,0);
			nSumLength += lLength;   //*加Xml的长度
			MemoryStream streamXml = new MemoryStream();
			StreamUtil.DumpStream(streamSource,
				streamXml,
				lLength);
			streamXml.Seek (0,SeekOrigin.Begin);
			XmlDocument domXml = new XmlDocument ();
			domXml.Load(streamXml);


			//2.2得到ID
			//DbPath oPath = new DbPath (strID);
			if (strMode == "append")
			{
				strID = "-1";
			}
			else if (strMode == "override")
			{
				//参数ID为空或为null，按数据中的ID算
				if (strID == null)
				{
					XmlNode idNode = domXml.SelectSingleNode ("//__id");
					strID = DomUtil.GetNodeTextDiff (idNode);
					if (strID == null)
					{
						strErrorInfo = "参数中的strID与数据中的ID均为null,而且是覆盖方式，发生矛盾没法处理了";
						return -1;
					}
					if (StringUtil.isNum (strID) == false )
					{
						strErrorInfo = "数据中的ID为" + strID + "不是合法的ID";
						return -1;
					}
				}
				else
				{
					if (StringUtil.isNum (strID) == false )
					{
						strErrorInfo = "参数strID为" + strID + "不是合法的ID";
						return -1;
					}
				}
			}
			else
			{
				strErrorInfo = "strMode的值" + strMode + "不合法，必须为append或者override";
				return -1;
			}

			if (strID == "-1" && strMode == "override")
			{
				strErrorInfo = "strID为-1，而保存方式为override，产生矛盾";
				return -1;
			}


			//2.3得到新file数组
			ArrayList aNewFileID = new ArrayList ();
			XmlNodeList newFileList = domXml.SelectNodes ("//file");
			foreach(XmlNode newFileNode in newFileList)
			{
				string strNewFileID = DomUtil.GetNodeText (newFileNode);
				if (strNewFileID != "")
					aNewFileID.Add (strNewFileID);
			}

			//2.4当为覆盖类型时，要将新旧file数组碰
			if (strID != "-1")
			{
				ArrayList aOldFileID = new ArrayList ();
				MemoryStream ms = new MemoryStream ();
				string strContentType;
				int nRet = db.GetRecord (strID,
					ms,
					out strContentType,
					null,
					false);
				if (nRet != -1)
				{
					XmlDocument oldDom = new XmlDocument ();
					oldDom.Load(ms);
					XmlNodeList oldFileList = oldDom.SelectNodes ("//file");
					foreach(XmlNode oldFileNode in oldFileList)
					{
						string strOldFileID = DomUtil.GetNodeText (oldFileNode);
						if (strOldFileID != "")
							aOldFileID.Add (strOldFileID);
					}

					ArrayList targetLeft = new ArrayList ();
					ArrayList targetMiddle = new ArrayList ();
					ArrayList targetRight = new ArrayList ();
					string strInfo;

					//数据必须先排序
					aNewFileID.Sort ();
					aOldFileID.Sort ();

					//新旧两个File数组碰
					DatabaseCollection.MergeFileList (aNewFileID,
						aOldFileID,
						targetLeft,
						targetMiddle,
						targetRight,
						out strInfo);

					//FileUtil.WriteText ("I:\\debug.txt",strInfo);
					//FileUtil.WriteText ("I:\\debug.txt","得到的三个新数组分别为:\r\n");
					//FileUtil.WriteText ("I:\\debug.txt","左: " + rmsUtil.ArrayList2String (targetLeft) + "\r\n");
					//FileUtil.WriteText ("I:\\debug.txt","中: " + rmsUtil.ArrayList2String (targetMiddle) + "\r\n");
					//FileUtil.WriteText ("I:\\debug.txt","右: " + rmsUtil.ArrayList2String (targetRight) + "\r\n");

					//删除多余的旧文件
					if (targetRight.Count > 0)
					{
						foreach(string strNeedDeleteFile in targetRight)
						{
							string strMessage;
							db.DeleteForce (strID + "_" + strNeedDeleteFile,true,out strMessage);
						}
					}
				}

			}
	
			//2.5处理新附件
			StreamItem[] aStream = null;
			ArrayList aTempFile = new ArrayList ();;
			try
			{
				//把附件中带得文件写到库里
				ArrayList aTempStream = new ArrayList ();
				while(true)
				{
					bufferLength = new byte[8];
					n = streamSource.Read(bufferLength,0,8);
					if (n<8)
						break;

					nSumLength += 8; //*加8字节的长度

					lLength = BitConverter.ToInt64(bufferLength,0);
					nSumLength += lLength; //*加一个file的长度

					if (nSumLength > nMyselfLength)
					{
						strErrorInfo = "nSumLength的值" + Convert.ToString (nSumLength) + "大于nMySelfLength的值" + Convert.ToString (nMyselfLength);
						return -1;
					}

					//用一个临时文件存放指定文件的二进制
					string strTempFileName = Path.GetTempFileName();
					FileStream streamTempFile =	File.Create(strTempFileName);
					StreamUtil.DumpStream (streamSource,
						streamTempFile,
						lLength);

					StreamItem oStream;
					streamTempFile.Seek (0,SeekOrigin.Begin);
					RestoreFileFromBin(streamTempFile,
						aTempFile,
						out oStream);    //这里有问题，如果是追加，如何处理文件ID？

					aTempStream.Add (oStream);
					streamTempFile.Close ();
					File.Delete (strTempFileName);

					if (nSumLength > nMyselfLength)
					{
						strErrorInfo = "nSumLength的值" + Convert.ToString (nSumLength) + "大于nMySelfLength的值" + Convert.ToString (nMyselfLength);
						return -1;
					}
					if (nSumLength == nMyselfLength) //本记录包含的文件算完了
					{
						break;
					}
				}
				
				if (aTempStream != null)
				{
					aStream = new StreamItem[aTempStream.Count ];
					for(int i=0;i<aTempStream.Count;i++)
					{
						aStream[i] = (StreamItem)(aTempStream[i]);
					}
				}

				streamXml.Seek (0,SeekOrigin.Begin);
				if (db != null)
				{
					db.Write(strID,
						streamXml,
						"text/xml",
						false,
						aStream,
						out strRecordID);
				}
			}
			catch(Exception ex)
			{
				strErrorInfo += "在RestoreRecordFromBin()出错:"+ex.Message  ;
				return -1;
			}
			finally
			{
				if (aStream != null)
				{
					foreach(StreamItem item in aStream)
					{
						item.m_stream.Close ();
					}
				}
				foreach(string strTempName in aTempFile)
				{
					File.Delete (strTempName);
				}
			}
			return 0;
		}



		//恢复文件
		//streamFile: 文件包stream
		//strID: 文件包stream
		//0:成功 
		public int RestoreFileFromBin(Stream streamFile,
			ArrayList aTempFile,
			out StreamItem oStream)
		{
			oStream = null;
			streamFile.Seek(0,SeekOrigin.Begin);

			//头8个文件名
			byte[] bufferLength = new byte[8];
			int n = streamFile.Read(bufferLength,0,8);
			if (n<8)
				return 0;
			long lLength;
			lLength = System.BitConverter.ToInt64(bufferLength,0);
			byte[] bufferFileName = new  byte[lLength];
			n = streamFile.Read(bufferFileName,0,(int)lLength);

			string strFileName =
				System.Text.Encoding.UTF8.GetString(bufferFileName);

 
			n = streamFile.Read(bufferLength,0,8);
			if (n<8)
				return 0;

			lLength =
				System.BitConverter.ToInt64(bufferLength,0);


			//m_strDebugInfo += "二进制文件的长度"+Convert.ToString (lLength)+"<br/>";

			string strTempFileName = Path.GetTempFileName();
			aTempFile.Add (strTempFileName);
			FileStream streamTempFile =	File.Create(strTempFileName);

			StreamUtil.DumpStream (streamFile,
				streamTempFile,
				lLength);

			oStream = new StreamItem(strFileName,streamTempFile);
			return 0;
		}


		#endregion
		
	} // end of class DatabaseCollection



    //数据库基类
	public class Database
	{
		#region 成员变量

		//定义记录锁集合对象m_recordLockColl
		protected DpRecordLockCollection m_recordLockColl = 
			new DpRecordLockCollection();

		//定义库锁m_lock
		protected ReaderWriterLock m_lock = new ReaderWriterLock();

		//定义m_nTimeOut变量，存放锁等待的时间
		protected int m_nTimeOut = 5000;

		//公共内部变量，调试信息
		public string m_strDebugInfo = "";

		//容器
		public DatabaseCollection m_Container; //在edit.dll里用到
		
		//根节点(数据库结构)
		public XmlNode m_nodeRoot;

		//keys表集合，不应该做缓冲，否则在IIS不重启的情况下，无法对现新修改的检索点配置
		//protected TableCollection m_tables;


		#endregion


		#region 构造函数

		//nodeDatabase: 数据库结构节点
		//parentCollection: 传入的容器指针databaseCollection
		internal Database (XmlNode nodeDatabase,
			DatabaseCollection container)
		{
			//****************加写锁****
			//构造函数加写锁的原因是给m_nodeRoot赋值，
			//并从中读数据，且在于过程中即不能读也不能写
			m_lock.AcquireWriterLock(m_nTimeOut); 
			try
			{
				m_Container = container;
				m_nodeRoot = nodeDatabase;

				//m_tables = new TableCollection(m_Container.CfgDir + this.GetKeys());// strKeyFile);
			}
			finally
			{
				m_lock.ReleaseWriterLock(); 
				//***********解写锁*************
			}
		}
		#endregion

		#region 属性

		//得到检索点的命名空间
		public XmlNamespaceManager GetKeyNsmgr(XmlDocument domData)
		{
			PrefixURIColl m_prefixUriCollKey = new PrefixURIColl(domData,
				this.m_Container .CfgDir + this.GetKeys());
			return m_prefixUriCollKey.m_nsmgr ;
		}

		//得到浏览格式的命名空间
		public XmlNamespaceManager GetBrowseClientNsmgr(XmlDocument domData)
		{
			PrefixURIColl m_prefixUriCollKey = new PrefixURIColl(domData,
				this.m_Container .CfgDir + this.GetBrowseClient ());
			return m_prefixUriCollKey.m_nsmgr ;
		}

		//得到数据库ID，注意前面带"@"
		//线: 不安全
		//返回值: 字符串，数字库ID(前带@)
		public string GetID()
		{
			string strID =
				"@"+DomUtil.GetAttr(m_nodeRoot,"id").Trim();

			return strID;
		}

		//ID属性，安全的
		public string ID  
		{
			get
			{
				//***********加读锁******GetID不会抛异，所以不用加try,catch
				m_lock.AcquireReaderLock(m_nTimeOut); 
				string strTemp = GetID();

				m_lock.ReleaseReaderLock();  
				//*************解读锁
				return strTemp;
			}
		}


		// Tables属性	 同GetTables(), 安全的
		public TableCollection Tables
		{
			get
			{
				//**************加读锁************
				//m_lock.AcquireReaderLock(m_nTimeOut); 

				//每次都从检索点表中得到检索点集合对象，暂不加锁
				TableCollection objTemp = new TableCollection(m_Container.CfgDir + this.GetKeys());

				//m_lock.ReleaseReaderLock();  
				//*************解读锁**************

				return objTemp;
			}
		}

		//根据语言，得到数据的标签名
		//不安全
		//strLanguage: 语言版本
		//返回值:
		//字符串，指定语言版本的库标签名
		//没有找到，会返回空，在用得地方将看不到标签名
		public string GetCaption(string strLanguage)
		{
			//当m_nodeRoot为null时，会抛出异常
			XmlNode nodeName = 
				m_nodeRoot.SelectSingleNode("logicName/caption[@lang='"+strLanguage+"']");  

			return DomUtil.GetNodeText(nodeName).Trim();			
		}


		// GetCaption函数的安全版本
		public string GetCaptionSafety(string strLanguage)
		{
			//***********加读锁******GetCaption可能会抛出异常，所以用try,catch
			m_lock.AcquireReaderLock(m_nTimeOut); 
			string strTemp = "";
			try
			{
				strTemp = GetCaption(strLanguage);
			}
			finally
			{
				m_lock.ReleaseReaderLock();  
				//*****************解读锁
			}
			return strTemp;						
		}


		//得到所有caption的值,以逗号分隔
		public string GetCaption()
		{
			string strResult = "";

			//当m_nodeRoot为null时，会抛出异常
			XmlNodeList nodeList = 
				m_nodeRoot.SelectNodes("logicName/caption");  

			foreach(XmlNode nodeName in nodeList)
			{
				if (strResult != "")
					strResult += ",";

				strResult +=
					DomUtil.GetNodeText(nodeName).Trim();

			}
			return strResult;			
		}

		//上面函数的安全版本
		public string GetCaptionSafety()
		{
			//***********加读锁******GetCaption可能会抛出异常，所以用try,catch
			m_lock.AcquireReaderLock(m_nTimeOut); 
			string strTemp = "";
			try
			{
				strTemp = GetCaption();
			}
			finally
			{
				m_lock.ReleaseReaderLock();  
				//*****************解读锁
			}
			return strTemp;			
		}
	
		//私有GetType方法: 返回数据库类型
		//返回值: string类型，数据库类型
		//线:不安全的
		public string GetDbType()
		{
			return DomUtil.GetAttr(m_nodeRoot,"type").Trim();
		}

		//线: 安全的
		//加锁原因，从数据库配置根节点读数据
		public string Type   //在DigitalPlatform.UserLib里也用到，所以设为public
		{
			get
			{
				//***********加读锁******GetDbType不会抛异，所以不用加try,catch
				m_lock.AcquireReaderLock(m_nTimeOut); 

				string strTemp = GetDbType();

				m_lock.ReleaseReaderLock();  
				//*************************解读锁
				return strTemp;
			}
		}
		//私有GetDataSource方法: 
		//返回数据库库，注意这里SQL和文件系统并不统一
		//返回值: string类型，返回数据库源
		//线: 不安全
		private string GetDataSource()
		{
			//当m_nodeRoot为null时，会抛出异常
			XmlNode nodeDatasource =
				m_nodeRoot.SelectSingleNode("datasource");

			return DomUtil.GetNodeText(nodeDatasource).Trim();
		}


		//受保护的GetLocation()方法，
		//文件系统时返回目录路径，注意是带"\"的
		//SQL server系统时返回连接字符串，
		//注意这里可能改，因为每个数据库也可能有自己的databasesource。
		//现在所有数据库共用一个总的连接配置信息
		//返回值: string类型，返回数据库位置
		//线: 不安全
		//加锁原因，从数据库配置根节点读数据
		protected string GetLocation()
		{
			//************加读锁**************
			m_lock.AcquireReaderLock(m_nTimeOut); 

			string strTemp = "";	
			try
			{
				if (StringUtil.isInList("file",GetDbType()) == true)
					strTemp = m_Container.CfgDir + GetDataSource() + "\\";
				else
					strTemp = m_Container.ConnString;
			}
			finally
			{
				m_lock.ReleaseReaderLock();  
				//*****************解读锁*************
			}
			return strTemp;
		}


		//受保护的GetSqlName方法: 
		//返回值: string类型，返回数据库物理名
		//线: 不安全
		protected string GetSqlName()
		{
			//当m_nodeRoot为null时，会抛出异常
			XmlNode nodeSQLName =
				m_nodeRoot.SelectSingleNode("SQLserverDb");

			return DomUtil.GetAttr(nodeSQLName,"name").Trim();
		}
		
		//受保护的GetKeys()方法: 
		//keys配置文件名
		//返回值: string类型，返回数据库keys配置文件名
		//线: 不安全
		protected string GetKeys()
		{
			//当m_nodeRoot为null时，会抛出异常

			XmlNode nodeKeys =
				m_nodeRoot.SelectSingleNode("keys");

			return DomUtil.GetNodeText(nodeKeys).Trim();
		}

		//私有GetBrowse()方法:
		//浏览记录配置文件名称
		//返回值: string类型，浏览记录配置文件名称
		/// 1.GetBrowseCfgDom()--------      ---------DigitalPlatform.UI.BrowseResultSet
		/// 2.GetResultSetHtml()--------      --------DigitalPlatform.UI.BrowseResultSet
		/// 3.GetErrorInfo()-----------       --------DigitalPlatform.UI.BrowseResultSet
		private string GetBrowse()
		{
			//当m_nodeRoot为null，会抛出异常
			XmlNode nodeBrowse =
				m_nodeRoot.SelectSingleNode("browse");

			return DomUtil.GetNodeText(nodeBrowse).Trim();
		}

		// paramter
		//		strRoleName: 角色名
		//		target:      目标流
		//		strError:    出错信息
		// return:
		//		-1: error
		//		0: successed
		public int GetRoleFile(string strRoleName,
			Stream target,
			long lStart,
			long lLength,
			out string strError)
		{
			strError = "";

			string strFileName = "";
			if (strRoleName == "browse")
				strFileName = this.m_Container.CfgDir + this.GetBrowse();
			else if (strRoleName == "template")
				strFileName = this.m_Container.CfgDir + this.GetTemplate();
			else if (strRoleName == "keys")
				strFileName = this.m_Container.CfgDir + this.GetKeys();
			else if (strRoleName == "browseClient")
				strFileName = this.m_Container.CfgDir + this.GetBrowseClient();
			else if (strRoleName == "stopword")
				strFileName = this.m_Container.CfgDir + this.GetStopword();

			FileStream s = null;
			try
			{
				s = new FileStream(strFileName,FileMode.Open);
			}
			catch(Exception ex)
			{
				strError = ex.Message;
				return -1;
			}

			if (s != null)
			{
				
				s.Seek(lStart,SeekOrigin.Begin);
				StreamUtil.DumpStream(s,target,lLength);
				s.Close();
			}

			return 0;
		}


		//安全的
		//加锁原因，从数据库配置根节点读数据
		public string Browse
		{
			get
			{
				//***************加读锁***********

				m_lock.AcquireReaderLock(m_nTimeOut); 

				string strTemp = "";

				try
				{
					strTemp = GetBrowse();
				}
				finally
				{
					m_lock.ReleaseReaderLock();  

					//**************解读锁***********
				}

				return strTemp;
			}
		}

		//浏览记录配置文件名称
		//返回值: string类型，浏览记录配置文件名称
		//线: 不安全
		//被下列地方调用:
		//1.GetBrowseCfgDom()--------      ---------DigitalPlatform.UI.BrowseResultSet
		//2.GetResultSetHtml()--------      --------DigitalPlatform.UI.BrowseResultSet
		//3.GetErrorInfo()-----------       --------DigitalPlatform.UI.BrowseResultSet
		private string GetBrowseClient()
		{
			//当m_nodeRoot为null，会抛出异常
			XmlNode nodeBrowse =
				m_nodeRoot.SelectSingleNode("browseClient");

			return DomUtil.GetNodeText(nodeBrowse).Trim();
		}


		//安全的
		//加锁原因，从数据库配置根节点读数据
		public string BrowseClient
		{
			get
			{
				//***************加读锁***********

				m_lock.AcquireReaderLock(m_nTimeOut); 

				string strTemp = "";

				try
				{
					strTemp = GetBrowseClient();
				}
				finally
				{
					m_lock.ReleaseReaderLock();  

					//**************解读锁***********
				}

				return strTemp;
			}
		}


		//编辑界面配置文件名称
		//返回值: string类型，返回编辑界面配置文件名称
		//线: 不安全
		private string GetEditCfg()
		{
			//当m_nodeRoot为null，会抛出异常
			XmlNode nodeEditcfg =
				m_nodeRoot.SelectSingleNode("editCfg");

			return DomUtil.GetNodeText(nodeEditcfg).Trim();
		}

		//安全的
		//加锁原因，从数据库配置根节点读数据
		public string EditCfg
		{
			get
			{
				//*************加读锁********

				m_lock.AcquireReaderLock(m_nTimeOut); 

				string strTemp = "";

				try
				{
					strTemp = GetEditCfg();
				}
				finally
				{
					m_lock.ReleaseReaderLock();  
					
					//*************解读锁***********
				}

				return strTemp;
			}
		}


		//私有GetTemplate()方法,
		//数据模板文件名称
		//返回值: string类型，返回数据模板文件名称
		//线: 不安全
		private string GetTemplate()
		{
			//当m_nodeRoot为null,会抛出异常
			XmlNode nodeTemplate =
				m_nodeRoot.SelectSingleNode("template");

			return DomUtil.GetNodeText(nodeTemplate).Trim();
		}


		//公共Template属性：返回数据模板文件
		//安全的
		//加锁原因，从数据库配置根节点读数据
		public string Template
		{
			get
			{
				//*************加读锁***********

				m_lock.AcquireReaderLock(m_nTimeOut); 

				string strTemp = "";

				try
				{
					strTemp = GetTemplate();
				}
				finally
				{
					m_lock.ReleaseReaderLock();  

					//*************解读锁**********
				}

				strTemp = m_Container.CfgDir + strTemp;

				return strTemp;
			}
		}

		

		//得到非用字配置文件
		//返回值: 字符串，非用字配置文件名
		//不安全
		private string GetStopword()
		{
			//当m_nodeRoot为null,会抛出异常
			XmlNode nodeStopword =
				m_nodeRoot.SelectSingleNode("stopword");

			return DomUtil.GetNodeText(nodeStopword).Trim();
		}

		// 公共属性，同GetStopword,
		// 但是安全的
		public string Stopword
		{
			get
			{
				//*********加读锁***
				m_lock.AcquireReaderLock(m_nTimeOut); 

				string strTemp;

				try
				{
					strTemp = GetStopword();
				}
				finally
				{
					m_lock.ReleaseReaderLock(); 
					
					//***********解读锁*************
				}

				return strTemp;
			}
		}

		#endregion


		#region 种子

		//私有的GetSeed()方法
		//返回值: int类型，返回记录尾号
		private int GetSeed()
		{
			//m_nodeRoot为null，会抛出异常
			XmlNode nodeSeed =
				m_nodeRoot.SelectSingleNode("seed");

			return System.Convert.ToInt32(DomUtil.GetNodeText(nodeSeed));
		}


		//受保护的SetSeed()方法，
		//set数据库的尾号
		//nSeed: 传入的尾号数
		protected void SetSeed(int nSeed)  //设为protected是因为在初始化时被访问
		{
			//m_nodeRoot为null，会抛出异常
			XmlNode nodeSeed =
				m_nodeRoot.SelectSingleNode("seed");

			DomUtil.SetNodeText(nodeSeed,
				Convert.ToString(nSeed));
		}

		
		//受保护的getNewSeed()方法，
		//得到记录的ID尾号（先加1再返回）,
		//注意加锁
		//返回整数ID
		//线: 安全的
		//调用下列函数:
		//1.Seed属性--------------安全的-----------Dp.DatabaseLib.DatabaseCollection
		//被下列地方调用:
		//1.Write()------------安全的-----Dp.DatabaseLib.SqlDatabase/FileDatabase
		// 加锁原因，加写锁，修改了nodeSeed内容，并始终保持增加，所以此时他处不能再读和写
		protected int getNewSeed()
		{
			//****************加写锁***********
			m_lock.AcquireWriterLock(m_nTimeOut); 
			//Thread.Sleep(10000);

			int nTemp;
			try
			{
				nTemp = GetSeed();   //必须采用这种方法，不能直接用Seed++
				nTemp++;
				SetSeed(nTemp);
				nTemp = GetSeed();
			}
			finally
			{
				m_lock.ReleaseWriterLock();  
				//***************解写锁************
			}
			return  nTemp;
		}

		/// <summary>
		/// 受保护的SetIfGreaten()方法。
		/// 
		/// 初始加读锁，
		/// 
		/// 如果用户手加输入的记录号大于的数据库的尾号，
		/// 则要修改尾号，此时将读锁升级为写锁，
		/// 
		/// 修改完后再降级为读锁
		/// </summary>
		/// 
		/// <param name="nID">用户手加输入的记录ID</param>
		/// <param name="isExist">是否已存在锁</param>
		/// 
		/// <returns>
		/// 返回当前记录号
		/// </returns>
		/// 
		/// <summary>
		/// 安全的
		/// </summary>
		protected int SetIfGreaten(int nID,bool isExist)
		{
			//这个地方没有考虑

			if (isExist == false)
				m_lock.AcquireReaderLock(m_nTimeOut); //加读锁

			try
			{
				if (nID > GetSeed())
				{
					LockCookie lc = m_lock.UpgradeToWriterLock(m_nTimeOut);
					try
					{
						//Thread.Sleep(5000);

						SetSeed(nID);
					}
					finally
					{
						m_lock.DowngradeFromWriterLock(ref lc);
					}

					//DateTime timeAfter = System.DateTime.Now;
					//m_strDebugInfo += "SetIfGreaten后的时间" + timeAfter.ToString() + "<br/>";

				}
			}
			finally
			{
				if (isExist == false)
					m_lock.ReleaseReaderLock();  //解读锁
			}

			return  GetSeed();
		}

		
		#endregion

		/// <summary>
		/// 将数据库多个表的标签信息，转换为数据库名，
		/// 并检查这个表中是否存在ID途径
		/// </summary>
		/// 
		/// <param name="strTablCaptions">原因的表列表</param>
		/// <param name="strLanguage">语言版本</param>
		/// <param name="isHaveID">
		/// out参数，存在ID途径，返回true,否则返回false
		/// </param>
		/// 
		/// <returns>
		/// 表名的ArrayList
		/// </returns>
		public ArrayList tableCaptions2aTableName(string strTablCaptions,
			string strLanguage,
			out bool isHaveID)
		{

			isHaveID = false;

			ArrayList aTableName = new ArrayList();

			//如果strTableList为空，则返回所有的表
			if (strTablCaptions == "")
			{
				//当不选择检索路径时，按全部路径算，但不包含通过id检索
				foreach(tableItem OneTable in this.Tables )
				{
					aTableName.Add(OneTable.Name);
				}
			}
			else
			{
				string[] aTable = null;
				aTable = strTablCaptions.Split(new Char [] {','});
			
				foreach(string strOneTable in aTable)
				{
					if (strOneTable == "")
						continue;

					//注意这里也需要改SearchByID参数
					//当id时，调SearchByID()，没法和其它和在一起，其它SingleSearch通过union
					if (strOneTable == "__id")
					{
						isHaveID = true;
						continue;
					}

					//根据表的ID得到实际的物理表名,并加到ArrayList
					string strTableName =
						this.Tables .GetPhysicalName(strOneTable,strLanguage);
					if (strTableName == "")
						continue;

					//m_strDebugInfo +=
					//	"数据库名:["+strOneTable+"]----语言["+strLanguage+"]----得到的物理名["+strTableName+"]";

					aTableName.Add(strTableName);
				}
			}

			return aTableName;
		}


		#region 检索

		/// <summary>
		/// 虚函数,通过ID检索记录
		/// </summary>
		/// 
		/// <param name="strText">检索文本__ID</param>
		/// <param name="strMode">检索方式</param>
		/// <param name="strRelation">单个table</param>
		/// <param name="myDataSet">ref参数，修改结果集</param>
		/// 
		/// <returns>
		/// 成功执行0
		/// </returns>
		/// 
		/// <summary>
		/// 线: 不安全
		/// 
		/// 被下列地方调用:
		/// 1.MultipleSearch()
		/// 
		/// </summary>
		protected virtual int SearchByID(string strText,
			string strMode,
			string strRelation,
			string strMaxCount,
			string strOrder,
			IsConnected isConnected,
			DpResultSet myDataSet)
		{
			return 0;
		}

		/// <summary>
		/// 通过union运算符，将多个表组成一个CMD命令
		/// </summary>
		/// 
		/// <param name="strTableList">多个表</param>
		/// <param name="strText">检索词</param>
		/// <param name="strMatch">匹配方式</param>
		/// <param name="strRelation">关系操作符</param>
		/// <param name="strDataType">数据类型</param>
		/// <param name="nWarningLevel">处理警告级别</param>
		/// <param name="strLanguage">语言版本</param>
		/// <param name="oResultSet">结果集</param>
		/// <param name="nResultCount">命中条数</param>
		/// <param name="strErrorInfo"></param>
		/// <param name="strWarningInfo"></param>
		/// <returns></returns>
		public virtual int SearchByUnion(string strTableList,
			string strText,
			string strMatch,
			string strRelation,
			string strDataType,
			string strMaxCount,
			string strOrder,
			int nWarningLevel,
			string strLanguage,
			IsConnected isConnected,
			DpResultSet oResultSet,
			out int nResultCount,
			ref string strErrorInfo,
			ref string strWarningInfo)
		{
			nResultCount = 0;
			return 0;
		}

		#endregion


		//虚函数，
		//初始化数据库，注意虚函数不能为private
		//参数：
		//strInfo: 中间处理信息，包括初始化命令等
		//返回值:
		//0:成功
		//-1:出错
		//
		//线: 安全的，在派生类里加锁
		//被下列地方调用:
		//1.initialize.aspx
		public virtual int Initialize(out string strInfo)
		{
			strInfo = "";
			return 0;
		}




		//虚函数,得到记录
		//线: 安全的，加读锁，在派生类里加锁
		//strID: 记录ID
		//DestFileStream: 目标stream(将数据库中的记录保存到这里)</param>
		//strContentType: out参数，文件类型
		//myConnection: 链接对象
		//bCheckAccount: 是否检查内存帐户对象
		/// <returns>成功执行返回0
		public virtual int GetRecord(string strID,
			Stream DestFileStream,
			out string strContentType,
			DpConnection myConnection,
			bool bCheckAccount)
		{
			strContentType = "";
			return 0;
		}

		//得到image字段内部的长度
		public virtual long GetImageLength(string strID)
		{
			return 0;
		}

		// 按指定范围读资源
		// parameter:
		//		strID:     记录ID
		//		nStart:    开始位置
		//		nLength:   长度 -1:开始到结束
		//		destBuffer: 返回字节数组
		//		timestamp: 返回时间戳
		//		strError:  error info
		// return:
		//		-1: error
		//		>=0: 资源总长度
		public virtual int ReadRes(string strID,
			int nStart,
			int nLength,
			out byte[] destBuffer,
			out byte[] timestamp,
			out string strError)
		{
			destBuffer = null;
			timestamp = null;
			strError = "";
			return 0;
		}


		// 更新指定范围的资源
		// parameter:
		//		strID :       记录id
		//		nStart:       目标起始位置
		//		chucksize:    每次写的块大小
		//		sourceBuffer: 字节数组，将写到image字段
		//		timestamp:    时间戳
		//		strError:     error info
		// return:	
		//		-1: error
		//		0:  successed
		private virtual int UpdateRes(string strID,
			int nStart,
			int chucksize,
			byte[] sourceBuffer,
			byte[] timestamp,
			out string strError)
		{
			strError = "";
			return 0;
		}

		
		//虚函数,写对象资源
		//myID: 记录id
		//SourceFileStream: stream源
		//strContentType: 类型
		//线: 安全的，在派生类里加锁
		//被下列地方调用:
		//1.SaveFileObj()
		public virtual int WriteRes(string myID,
			Stream SourceFileStream,
			string strContentType)
		{
			return 0;
		}

		//假写xml数据，得到检索点集合
		//参数:
		//SourceFileStream: stream源
		//strID:记录ID，构造检索点用
		//keyColl: out参数,返回检索点集合的
		//strErrorInfo: 出错信息
		//返回值: 0:正常  -1:出错
		public int PretendWrite(Stream SourceFileStream,
			string strID,
			out DpKeys keyColl,
			out string strErrorInfo)
		{
			keyColl = new DpKeys();
			strErrorInfo = "";

			//加载检索点配置文件到DOM
			XmlDocument m_cfgDom = new XmlDocument();
			try
			{
				m_cfgDom.Load(m_Container.CfgDir + GetKeys());
			}
			catch(Exception ex)
			{
				strErrorInfo = "在database类的PretendWrite()里，加载配置文件Dom出错\r\n" + ex.Message ;
				return -1;
			}

			//加载数据到DOM
			XmlDocument newDataDom = new XmlDocument();
			try
			{
				newDataDom.Load(SourceFileStream);
			}
			catch(Exception ex)
			{
				strErrorInfo = "在database类的PretendWrite()里，加载数据Dom出错\r\n" + ex.Message ;
				return -1;
			}

			//创建检索点
			keyColl.Create(newDataDom,
				m_cfgDom,
				strID,
				m_Container.KeySize,
				this);   //改stopword

			//排序去重
			keyColl.Sort();
			keyColl.RemoveDup();
			return 0;
		}


		//虚函数,写数据文件，同时写keys表
		//安全的，在派生类加锁
		//myID: 记录ID
		//SourceFileStream: stream源
		//strContentType: 文件类型
		//bCheckAccount: 是否检查内存帐户对象
		//返回处理结束
		public virtual string Write(string myID,
			Stream SourceFileStream,
			string strContentType,
			bool bCheckAccount,
			out string strRecordID)
		{
			strRecordID = myID;
			return "";
		}


		//写Xml和一组附件
		public virtual int Write(string myID,
			Stream SourceFileStream,
			string strContentType,
			bool bCheckAccount,
			StreamItem[] aStream,
			out string strRecordID)
		{
			strRecordID = myID;
			return 0;
		}

		//虚函数,删除记录,普通删除方法
		//strID: 记录ID
		//deleteFromKeysTable: out参数，返回信息
		//成功执行返回0
		//线: 安全的，加写锁，在派生类里加锁
		//被下列地方调用:
		//1.SaveFileObj()---------       ------Dp.DatabaseLib.DpResHolder
		//2.DoDelete()----------       -------Dp.EditLib.DpDbXmlEdit
		public virtual int DeleteForce(string strID,
			bool bFile,
			out string deleteFromKeysTable)
		{
			deleteFromKeysTable="";
			return 0;
		}

		//虚函数,强制删除记录
		//strID: 记录ID
		//strResult: out参数，返回处理信息
		//成功执行返回0
		//线: 安全的，加写锁，在派生类里加锁
		public virtual int Delete(string strID,
			out string strResult)
		{
			strResult = "";
			return 0;
		}

		//删除旧目录（及内容），
		//新建目录
		//返回值:
		//无
		//出错，抛出异常
		//线：不安全
		//被initialize调
		protected void DeleteDir()
		{
			string strPath = GetLocation().Trim();

			if (GetDataSource() == "")
			{
				Exception ex = new Exception("您没有对文件数据库配置数据目录(datasource)");
				throw(ex);
			}

			if (Directory.Exists(strPath)) 
				Directory.Delete(strPath, true);

			Directory.CreateDirectory(strPath);
		}


		//受保护的SplitRangeID()方法，将"00000001-000000100"字符串拆分为两部分
		//strRange: 输入的范围字符串
		//strID1: 返回值参数，返回开始记录号
		//strID2: 返回值参数，返回结束记录号
		//成功执行返回0
		//关系:
		//在singleSearch()和searchByID都用到了
		protected int SplitRangeID(string strRange ,
			out string strID1,
			out string strID2)
		{
			int nPosition;
			nPosition = strRange.IndexOf("-");

			strID1 = "";
			strID2 = "";
		
			if (nPosition > 0)
			{
				strID1 = strRange.Substring(0,nPosition).Trim();
				strID2 = strRange.Substring(nPosition+1).Trim();
			}

			if (nPosition == 0)
			{
				strID1 = "0";
				strID2 = strRange.Substring(1).Trim();
			}

			if (nPosition < 0)
			{
				strID1 = strRange.Trim();
				strID2 = strRange.Trim();
			}

			return 0;
		}

		// 将带比较运算符的式子分成两部分
		protected int GetPartCondition(string strText,
			out string strOperator,
			out string strRealText)
		{
			strText = strText.Trim();

			strOperator = "=";
			strRealText = strText;

			int nPosition;

			nPosition = strText.IndexOf(">=");
			if(nPosition >= 0)
			{
				strRealText = strText.Substring(nPosition+2);

				strOperator = ">=";
				return 0;
			}

			nPosition = strText.IndexOf("<=");
			if(nPosition >= 0)
			{
				strRealText = strText.Substring(nPosition+2);
				strOperator = "<=";
				return 0;
			}

			nPosition = strText.IndexOf("<>");
			if(nPosition >= 0)
			{
				strRealText = strText.Substring(nPosition+2);
				strOperator = "<>";
				return 0;
			}

			nPosition = strText.IndexOf("><");
			if(nPosition >= 0)
			{
				strRealText = strText.Substring(nPosition+2);
				strOperator = "<>";
				return 0;
			}

			nPosition = strText.IndexOf("!=");
			if(nPosition >= 0)
			{
				strRealText = strText.Substring(nPosition+2);
				strOperator = "<>";
				return 0;
			}

			nPosition = strText.IndexOf(">");
			int nPosition2 = strText.IndexOf(">=");
			if(nPosition2<0 && nPosition >= 0)
			{
				strRealText = strText.Substring(nPosition+1);
				strOperator = ">";

				return 0;
			}

			nPosition = strText.IndexOf("<");
			nPosition2 = strText.IndexOf("<=");
			if(nPosition2<0 && nPosition >= 0)
			{
				strRealText = strText.Substring(nPosition+1);
				strOperator = "<";

				return 0;
			}
			return 0;
		}

		//通过非用字dom和指定的非用字表，得到间隔符ArrayList和非用字ArrayList
		//dom: 非用字dom
		//strTableName: 非用字表名
		//aSeparator: out参数，返回间隔符ArrayList
		//aWord: 非用字ArrayList
		public void getTwoArrayListAboutStopword(XmlDocument dom,
			string strTableName,
			out ArrayList aSeparator,
			out ArrayList aWord)
		{
			aSeparator = new ArrayList();
			aWord = new ArrayList();
			
			string strXpath;
			strXpath =
				"/root/stopwordTable[@name='" + strTableName + "']/separator/t";

			if (strTableName == "")
				strXpath = "/root/stopwordTable/separator/t";

			XmlNodeList listSeparator =	dom.SelectNodes(strXpath);
	
			foreach(XmlNode nodeSeparator in listSeparator)
			{
				string strText = DomUtil.GetNodeText(nodeSeparator);
				if (strText != "")
					aSeparator.Add(strText);
			}
	
			strXpath = "/root/stopwordTable[@name='" + strTableName + "']/word/t";

			if (strTableName == "")
				strXpath = "/root/stopwordTable/word/t";
	
			XmlNodeList listWord = dom.SelectNodes(strXpath);;
			foreach(XmlNode nodeWord in listWord)
			{
				string strText = DomUtil.GetNodeText(nodeWord);
				if (strText != "")
					aWord.Add(strText);
			}	
		}

		//从指定起始位置查找子字符串在大字符串出现的位置
		//strComplete: 大字符串
		//strSub: 小字符串
		//nStart: 起始位置
		//返回值: 出现的位置
		public int findsubstring(string strComplete,
			string strSub,
			int nStart)
		{
			for(int i= nStart;i<strComplete.Length;i++)
			{
				if (String.Compare(strComplete, i, strSub, 0, strSub.Length,true) == 0 )
					return i;
			}
	
			return -1;
		}

		//对一个字符串删除非用字
		//strText: 待加工的字符串
		//aSeparator: 间隔符数组
		//aWord: 非用字数组
		//strInfo: out参数，返回处理信息
		//去非用字后的字符串
		public string deleteStopword(string strText,
			ArrayList aSeparator,
			ArrayList aWord,
			out string strInfo)
		{
			strInfo = "";
	
			string strResult = strText;
			strInfo = "进来的字符串:----------------[" + strResult + "]<br/>";
			strInfo += "间隔符如下,数量" + aSeparator.Count + ":----------------<br/>";
			for(int i=0; i<aSeparator.Count ; i++)
			{
				if ((string)aSeparator[i] == "_")
					aSeparator[i] = " ";
		
				strResult = strResult.Replace((string)aSeparator[i],"^");
		
				strInfo += "["+ aSeparator[i] + "]<br/>";		
			}

			strInfo += "将所有的间隔符转换成^:----------------[" + strResult + "]<br/>";
			int nPosition;
			strResult = "^" + strResult + "^";
			strInfo += "给字符串前后加^:----------------[" + strResult + "]<br/>";
	
			//---------------------去非用字------------

			strInfo += "非用字如下,数量" + aWord.Count + ":----------------<br/>";
			int nLength;
			for(int i=0;i<aWord.Count;i++)
			{
				strInfo += "<br/><br/>["+ aWord[i] + "]<br/>";
				int nStart = 0;
				while(true)
				{
					nPosition = findsubstring(strResult,(string)aWord[i],nStart);
			
					if (nPosition<0)
						break;
				
					nLength = ((string)aWord[i]).Length;
					nStart += nLength;
			
					string strStart = strResult.Substring(nPosition-1,1);
					string strEnd = strResult.Substring(nPosition+nLength,1);
			
					string strStopwordStart = ((string)aWord[i]).Substring(0,1);
					string strStopwordEnd = ((string)aWord[i]).Substring(((string)aWord[i]).Length-1);

		
					strInfo += "开始前字符^:----[" + strStart + "]-----------结束后字符:----[" + strEnd + "]<br/>";
					strInfo += "strStopword开始前字符^:----[" + strStopwordStart + "]-----------结束后字符:----[" + strStopwordEnd + "]<br/>";


					if (((strStart == "^") || (isChineseChar(strStart) == true) || (isChineseChar(strStopwordStart) == true))  && ((strEnd == "^") || (isChineseChar(strEnd) == true) || (isChineseChar(strStopwordEnd) == true)) )
					{
						strResult = strResult.Remove(nPosition,nLength);
				
						strInfo += "把非用字[" + aWord[i] + "]去掉后:----------------[" + strResult + "]<br/>";
					}
				}
			}
			strInfo += "<br/><br/>全部处理完带^符号:----------------[" + strResult + "]<br/>";
			strResult = strResult.Replace("^","");
			return strResult;
		}

		//检查字符串是否是汉字
		//</summary>
		//strWord: 传入的字符串
		//字符串每个字符均是汉字，返回ture,出现非汉字，返回false
		public bool isChineseChar(string strWord)
		{
			foreach (Char oneChar in strWord)
			{
				if (Char.GetUnicodeCategory(oneChar) != UnicodeCategory.OtherLetter)
					return false;
			}
	
			return true;
		}


		public string GetStringNumber(string strText)
		{
			ArrayList aDigitalList = new ArrayList ();
			bool bFound = false;
			if (StringUtil.isNum(strText)  == true)
				return strText;
			else
			{
				for(int i=0;i<strText.Length ;i++)
				{
					char oneChar = strText[i];
					if ((Char.IsDigit (oneChar) == true))
					{
						aDigitalList.Add (oneChar);
						bFound =true;
					}
					else if (oneChar=='.')
					{
						aDigitalList.Add (oneChar);
					}
					else
					{
						if (bFound == true)
							break;
					}
				}
			}

			char[] achar= new char[aDigitalList.Count ];

			for(int i=0;i<aDigitalList.Count ;i++)
			{
				achar[i] = (char)aDigitalList[i];
			}
			string strResult = new string (achar);
			if (strResult == "")
				strResult = "-1";
			return strResult;
		}

		//把一数字型字符串变成整数型字符串，并根据精度进行扩展
		//strKey: 传入的字符串
		//strPrecision: 精度
		//返回值: 根据精度加工的字符串，出现返回“-1”
		public string ExtendByPrecision(string strKey,
			string strPrecision)
		{
			//if (isNum(strKey) == false)
			//{
			//	return "-1";
			//}

			strKey = GetStringNumber(strKey);
			if (strKey == "-1")
				return "-1";

			int nPrecision ;
			if (strPrecision == "0")
				nPrecision = 0;
			else
				nPrecision = Convert.ToInt32(strPrecision);

			string strResult = "";
			string str1;
			string str2;

			int nPosition;
			nPosition = strKey.IndexOf(".");


			if (nPosition >= 0)
			{
				str1 = strKey.Substring(0,nPosition);
				str2 = strKey.Substring(nPosition+1);
				str2 = str2.Replace(".","");

				if (str2.Length < nPrecision)
					str2 += new String('0',nPrecision-str2.Length);

				if (str2.Length > nPrecision && nPrecision>0)
					str2 = str2.Substring(0,nPrecision-1);

				strResult = str1 + str2;

				if (nPrecision == 0)
					strResult = str1;
			}
			else
			{
				strResult = strKey + new String('0',nPrecision);
			}


			//加去0的函数
			strResult = Delete0FromString(strResult);

			return strResult;
		}

		//删除字符串前方的“0”
		//strText: 字符串
		//返回值: 去前方0后的字符串</returns>
		public string Delete0FromString(string strText)
		{
			if (strText == "")
				return strText;

			while(strText.Substring(0,1) == "0")
			{
				strText = strText.Substring(1);
			}
			return strText;
		}

		//根据配置节点，加工key
		//node: 配置节点
		//strText: key字符串
		//返回值: 加工后的字符串，出现错误，如果对keystring加工，返回原值，如果对keystringnum加工，返回-1，其它抛出异常</returns>
		public string ConvertKey(XmlNode node,
			string strText)
		{
			//当加没配加工节点，直接返回原内容
			if (node == null)
			{
				//当不需要对检索点进行加工，就不会配置节点，所以这种情况很多，不能抛出异常
				//Exception ex = new Exception("做ConvertKey，传入的node参数为null");
				//throw(ex);

				return "-1" ; //strText;
			}

			//domLoad可能抛出异常
			XmlDocument domStopword =
				DomUtil.domLoad(m_Container.CfgDir + GetStopword());


			string strResult = "";

			string strConvertStyle =
				DomUtil.GetAttr(node,"style");

			string strConvertPrecision =
				DomUtil.GetAttr(node,"precision");

			try
			{
				//在这里将插入一些代码，处理key和keyNum
				if (StringUtil.isInList("money",strConvertStyle) == true)
				{
					if (strConvertPrecision == "")
						strConvertPrecision = "0";

					strResult = ExtendByPrecision(strText,
						strConvertPrecision);
				}
				else if (StringUtil.isInList("integer",strConvertStyle) == true)
				{
					strResult = ExtendByPrecision(strText,"0");
				}

				if (StringUtil.isInList("upper",strConvertStyle) == true)
				{
					strResult = strText.ToUpper();
				}
				if (StringUtil.isInList("lower",strConvertStyle) == true)
				{
					strResult = strText.ToLower();
				}
				if (StringUtil.isInList("stopword",strConvertStyle) == true && domStopword != null )
				{
					string strStopwordTable = DomUtil.GetAttr(node,"stopwordTable");
					
					ArrayList aSeparator;
					ArrayList aWord;
					getTwoArrayListAboutStopword(domStopword,strStopwordTable,out aSeparator,out aWord);

					if (aSeparator != null && aWord != null)
					{
						string strInfo;
						strResult = deleteStopword(strResult,aSeparator,aWord,out strInfo);
					}
				}
			}
			catch
			{
				if (node.Name == "string")   //进行字符的加工，直接返加原文本
				{
					strResult = strText;
				}
				else if (node.Name == "number")  //对数字的加工返回-1
				{
					strResult = "-100";
				}
				else
				{
					Exception ex1 = new Exception("加工key的配置节点出错，应为string或number");
					throw(ex1);
				}
			}

			return strResult;
		}

		//处理关系，注意可能抛出NoMatch异常
		public int processRelation(ref string strMatch,
			ref string strRelation,
			ref string strDataType)
		{
			if (strDataType == "number")
			{
				if (strMatch == "left" || strMatch == "right")
				{
					strMatch = "exact";
					//修改有两种:1.将left换成exact;2.将dataType设为string,我们先按认为dataType优先，将match改为exact

					NoMatchException ex =
						new NoMatchException("匹配方式'"+strMatch+"'与数据类型"+strDataType+"不匹配");
					throw(ex);
				}
			}

			if (strDataType == "string")
			{
				if (strMatch == "left" || strMatch == "right")
				{
					if (strRelation != "=")
					{
						//也可以将left或right改为exact，但意义不大‘
						strRelation = "=";
						NoMatchException ex =
							new NoMatchException("关系操作符'"+strRelation+"'与数据类型"+strDataType+"和匹配方式'"+strMatch+"'不匹配");
						
						throw(ex);
					}
				}
			}
			return 0;
		}

	}// end of class Database


	//SQL库派生类
	public class SqlDatabase : Database
	{
		public SqlDatabase(XmlNode nodeDb,
			DatabaseCollection container):base(nodeDb,container)
		{}

		//重写基类的Initialize,初始化数据库
		//返回处理结束字符串
		//线: 不安全
		//调用下列函数:
		//1.SaveXml()-------------- 安全的-----------Dp.DatabaseLib.DatabaseCollection
		//加写锁的原因，修改记录尾号，另外对SQL的操作不必担心锁
		public override int Initialize(out string strInfo)
		{
			//************加写锁,可以具体到单个,save,delete
			m_lock.AcquireWriterLock(m_nTimeOut); 
			SqlConnection objSqlConnection = null;
			strInfo = "";

			try
			{
				//创建链接对象---------------------
				objSqlConnection =	new SqlConnection(GetLocation());	
				objSqlConnection.Open();

				SqlCommand objSqlCommand;
				string strCmd = "";

				//建库命令
				strCmd = "use master " + "\n" + 
					"if exists (select * from dbo.sysdatabases where name = N'" + GetSqlName()+"')" + "\n" + 
					"drop database " + GetSqlName() + "\n" +
					"CREATE database " + GetSqlName() + "\n" + "\n" ;
					//+ "GO \n";

				//当时为什么要先执行一下建库命令呢，肯定是有原因的，如果这儿先执行则后面改为strCmd = **
				objSqlCommand = new SqlCommand(strCmd, objSqlConnection);
				objSqlCommand.ExecuteNonQuery();
			
				strCmd = " use " + GetSqlName() + "\n"
					+ "if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[records]') and OBJECTPROPERTY(id, N'IsUserTable') = 1)" + "\n"
					+ "drop table [dbo].[records]" + "\n"
					+ "CREATE TABLE [dbo].[records]" + "\n" 
					+ "(" + "\n"
					+ "[id] [nvarchar] (255) COLLATE Chinese_PRC_CI_AS NULL ," + "\n" 
					+ "[data] [image] NULL ," + "\n"
					+ "[contentType] [nvarchar] (255) COLLATE Chinese_PRC_CI_AS NULL" + "\n" 
					//+ "timestamp " + "\n"
					+ ") ON [PRIMARY] TEXTIMAGE_ON [PRIMARY]" + "\n" + "\n";

				foreach(tableItem oneTable in this.Tables )
				{
					strCmd += "\n" +
						"if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].["+oneTable.Name+"]') and OBJECTPROPERTY(id, N'IsUserTable') = 1)" + "\n" +
						"drop table [dbo].["+oneTable.Name+"]" + "\n" +
						"CREATE TABLE [dbo].["+oneTable.Name+"]" + "\n" +
						"(" + "\n" +
						"[keystring] [nvarchar] (" + Convert.ToString(m_Container.GetKeySize()) + ") Null," + "\n" +         //keystring的长度由配置文件定
						"[fromstring] [nvarchar] (255) NULL ," + "\n" +
						"[idstring] [nvarchar] (255)  NULL ," + "\n" +
						"[keystringnum] [bigint] NULL " + "\n" +
						")" + "\n" + "\n";
				}

				strInfo = strCmd;
				objSqlCommand =	new SqlCommand(strCmd, objSqlConnection);
				objSqlCommand.ExecuteNonQuery();

				string strTemp;
				int nRet;
				nRet = CreateIndex(objSqlConnection,out strTemp);
				strInfo += strTemp;

				if (nRet == -1)
				{
					return -1;
				}

				SetSeed(0);
				m_Container.SaveXml();   //调库集合的SaveXml,该函数是安全的
			}
			finally
			{
				if (objSqlConnection != null)
				{
					objSqlConnection.Close(); //关闭连接对象------------
					objSqlConnection = null;
				}
				m_lock.ReleaseWriterLock();  
				//*********************解写锁
			}
			return 0;
		}	

		
		//创建索引
		public int CreateIndex(SqlConnection objSqlConnection,
			out string strInfo)
		{
			if (objSqlConnection == null)
			{
				strInfo = "连接对象为null,创造索引失败";
				return -1;
			}
			string strCmd ;
			strCmd = "use " + GetSqlName() + "\n"
				+ " CREATE INDEX records_id_index " + "\n"
				+ " ON records (id) \n";

			foreach(tableItem oneTable in this.Tables )
			{
				strCmd += " CREATE INDEX " +oneTable.Name+"_keystring_index \n"
					+ " ON "+oneTable.Name+" (keystring) \n";

				strCmd += " CREATE INDEX " +oneTable.Name+"_keystringnum_index \n"
					+ " ON "+oneTable.Name+" (keystringnum) \n";
			}


			strInfo = strCmd;  
			
			//当时是表的去重算法有问题
			//FileUtil.WriteText("L:\\debug.txt","\r\n表的个数"+Convert.ToString (m_tables.Count)+"\r\n");
			//foreach(tableItem oneTable in m_tables)
			//{
			//	FileUtil.WriteText("L:\\debug.txt","表名"+oneTable.Name +"\r\n");
			//}
			//FileUtil.WriteText("L:\\debug.txt","大家好"+strCmd);

			SqlCommand objSqlCommand =	new SqlCommand(strCmd, objSqlConnection);
			objSqlCommand.ExecuteNonQuery();

			return 0;
		}

		//重写SingleSearch函数，检索单个table,保证进来是物理表名
		//strText: 检索文本__id
		//strMode: 检索方式
		//strRelation: 一个table
		//myDataSet: 结果集
		//返回值:
		//>=0 : 返回检索到记录的数量
		//-1 : 出错
		// 线: 不安全
		//调用下列函数:
		//1.GetLocation()--------------      -----------Dp.DatabaseLib.Database
		protected override int SearchByID(string strText,
			string strMode,
			string strRelation,
			string strMaxCount,
			string strOrder,
			IsConnected isConnected,
			DpResultSet myDataSet)
		{
			if (strOrder == "")
				strOrder = "ASC";

			strText = strText.Trim ();
			strMode = strMode.Trim ();
			strRelation = strRelation.Trim ();

			SqlConnection objSqlConnection = null;
			int nResultCount = 0;
			try
			{
				//创建并打开连接对象---------------------
				objSqlConnection =	new SqlConnection(GetLocation());
				objSqlConnection.Open();

				ArrayList aParameter = new ArrayList ();
				string strWhere = "";
				if (strMode == "left" || strMode == "")
				{
					strWhere = " WHERE id LIKE @id";

					//改为parameter
					SqlParameter temp = new SqlParameter ("@id",SqlDbType.NVarChar);
					temp.Value = strText+"%";
					aParameter.Add (temp);
				}
				else if (strMode == "right")
				{
					strWhere = " WHERE id LIKE @id";

					//改为Parameter
					SqlParameter temp = new SqlParameter ("@id",SqlDbType.NVarChar);
					temp.Value = "%" + strText;
					aParameter.Add (temp);
				}
				else if (strMode == "exact")
				{
					if (strRelation == "draw")
					{
						int nPosition;
						nPosition = strText.IndexOf("-");

						if (nPosition >= 0)
						{
							string strID1;
							string strID2;
							SplitRangeID(strText,out strID1, out strID2);
							strID1 = DbPath.GetID10(strID1);
							strID2 = DbPath.GetID10(strID2);

							strWhere = " WHERE @idMin <=id and id<= @idMax and id like N'[0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9]'";

							//改为Parameter
							SqlParameter temp = new SqlParameter ("@idMin",SqlDbType.NVarChar);
							temp.Value = strID1;
							aParameter.Add (temp);

							//改为Parameter
							temp = new SqlParameter ("@idMax",SqlDbType.NVarChar);
							temp.Value = strID2;
							aParameter.Add (temp);
						}
						else
						{
							string strOperator;
							string strRealText;
							GetPartCondition(strText,out strOperator,out strRealText);
							strRealText = DbPath.GetID10(strRealText);

							strWhere = " WHERE id " + strOperator + " @id ";

							//改为Parameter
							SqlParameter temp = new SqlParameter ("@id",SqlDbType.NVarChar);
							temp.Value = strRealText;
							aParameter.Add (temp);
						}
					}
					else
					{
						strText = DbPath.GetID10(strText);
						strWhere = " WHERE id " + strRelation + " @id ";

						//改为Parameter
						SqlParameter temp = new SqlParameter ("@id",SqlDbType.NVarChar);
						temp.Value = strText;
						aParameter.Add (temp);
					}
				}
			
				string strTop = "";
				if (strMaxCount != "")
					strTop = " TOP "+strMaxCount + " ";

				
				string strCommand = "use master \n";
				strCommand += "use " + GetSqlName()  
					+ " SELECT "+strTop+" id,'" + GetID()
					+ "' FROM records "
					+ strWhere 
					+ " ORDER BY id "+strOrder  + "\n";      //将GetLogicName改为GetID


				//FileUtil.WriteText("L:\\debug.txt",strCommand);

				//m_strDebugInfo += strCommand + "<br/>";

				SqlCommand myseletecmd =
					new SqlCommand(strCommand, objSqlConnection);
                				
				foreach(SqlParameter parameter in aParameter)
				{
					myseletecmd.Parameters .Add (parameter);
				}

				//foreach(SqlParameter parameter in myseletecmd.Parameters)
				//{
					//FileUtil.WriteText("L:\\debug.txt","参数名:"+parameter.ParameterName+"\r\n");
					//FileUtil.WriteText("L:\\debug.txt","值:"+parameter.Value+"\r\n");
				//}

				SqlDataReader myReader;
				//myReader = myseletecmd.ExecuteReader();

				DatabaseCommandTask task =
					new DatabaseCommandTask(myseletecmd);


				Thread t1 = new Thread(new ThreadStart(task.ThreadMain));
				t1.Start ();

				bool bRet;
				while(true)
				{
					if (isConnected != null)
					{
						if (isConnected(".") == false)
							break;
					}

					//Thread.Sleep (0);
					bRet = task.m_event.WaitOne(0, false);
					if(bRet == true)
						break;
				}
				if (task.bError == true)
				{
					//FileUtil.WriteText("L:\\debug.txt","["+task.strErrorInfo+"]\r\n");
					throw(new Exception(task.strErrorInfo));
				}

				myReader = task.m_dataReader;
				if (myReader != null)
				{
					while(myReader.Read()) 
					{
						if (isConnected != null)
						{
							if (isConnected("a") == false)
								break;
						}

						if (((string)myReader[0]).Length == 10)
						{
							string strId = ((string)myReader[1]).Trim()+":"+ (string)myReader[0];
							myDataSet.Add(new DpRecord(strId));
							nResultCount++;
						}
					}
					myReader.Close();
				}
			}
			finally
			{
				//关闭连接对象--------------------
				if (objSqlConnection != null)
				{
					objSqlConnection.Close();
					objSqlConnection = null;
				}
			
			}
			return nResultCount;
		}

		/// 私有函数，被singleSearch()函数调，
		/// 可能会抛出的异常:NoMatchException(检索方式与数据类型)
		private string GetKeyCondition(string strText,
			string strMatch,
			string strRelation,
			string strDataType,
			XmlNode nodeConvertquery,
			string strPrefix,       //参数名后缀 
			ArrayList aParameter)
		{
			string strKeyCondition = "";

			//1.首先检查三项是否有矛盾，该函数可能会抛出NoMatchException异常
			processRelation(ref strMatch,ref strRelation,ref strDataType);

			//2.分别得到字符串和数字格式的如何加工的配置节点
			XmlNode nodeString = null;
			XmlNode nodeNumber = null;

			if (nodeConvertquery != null)
			{
				nodeString = nodeConvertquery.SelectSingleNode("string");
				nodeNumber = nodeConvertquery.SelectSingleNode("number");
			}

			//3.根据数据类型，对检索词进行加工
			string strKeyValue = "";
			strKeyValue = strText;
			if (strDataType == "string")    //字符类型调字符的配置，对检索词进行加工
			{
				if (nodeString != null)
					strKeyValue = ConvertKey(nodeString,strText);
			}
			else if(strDataType == "number")   //数字型调数字格式的配置，对检索词进行加工
			{
				if (nodeNumber != null)
					strKeyValue = ConvertKey(nodeNumber,strText);
			}

			string strParameterName;
			//4.根据match的值，分别得到不同的检索表达式
			if (strMatch == "left" || strMatch == "")  //如果strMatch为空，则按"左方一致"
			{
				//其实一开始就已经检查了三顶是否矛盾，如果有矛盾抛出抛异，这里重复检查无害，更严格
				if (strDataType != "string")
				{
					NoMatchException ex = new NoMatchException("在匹配方式值为left或空时，与数据类型值"+strDataType+"矛盾，数据类型应该为string");
					throw(ex);
				}

				strParameterName = "@keyValue"+strPrefix;
				strKeyCondition = "keystring LIKE "+strParameterName + " "; 

				//改为parameter
				SqlParameter temp = new SqlParameter (strParameterName,SqlDbType.NVarChar);
				temp.Value = strKeyValue + "%";
				aParameter.Add (temp);

			}
            else if (strMatch == "right")
			{
				//其实一开始就已经检查了三顶是否矛盾，如果有矛盾抛出抛异，这里重复检查无害，更严格
				if (strDataType != "string")
				{
					NoMatchException ex = new NoMatchException("在匹配方式值为left或空时，与数据类型值"+strDataType+"矛盾，数据类型应该为string");
					throw(ex);
				}
				strParameterName = "@keyValue"+strPrefix;
				strKeyCondition = "keystring LIKE "+strParameterName+" "; //N'%" + strKeyValue + "'";

				//改为parameter
				SqlParameter temp = new SqlParameter (strParameterName,SqlDbType.NVarChar);
				temp.Value = "%" + strKeyValue ;
				aParameter.Add (temp);
			}
			else if (strMatch == "exact") //先看match，再看relation,最后看dataType
			{
				//从词中汲取,较复杂，注意
				if (strRelation == "draw")
				{
					int nPosition;
					nPosition = strText.IndexOf("-");

					//应按"-"算
					if (nPosition >= 0)
					{
						string strText1;
						string strText2;
						SplitRangeID(strText,out strText1,out strText2);

						if (strDataType == "string")
						{
							if (nodeString != null)
							{
								strText1 = ConvertKey(nodeString,strText1);
								strText2 = ConvertKey(nodeString,strText2);
							}
							string strParameterMinName = "@keyValueMin"+strPrefix;
							string strParameterManName = "@keyValueMan"+strPrefix;

							strKeyCondition = " "+strParameterMinName+" "+
								"<=keystring and keystring<= "+
								" "+strParameterManName+" ";

							//改为parameter
							SqlParameter temp = new SqlParameter (strParameterMinName,SqlDbType.NVarChar);
							temp.Value = strText1 ;
							aParameter.Add (temp);

							//改为parameter
							temp = new SqlParameter (strParameterManName,SqlDbType.NVarChar);
							temp.Value = strText2 ;
							aParameter.Add (temp);
						}
						else if(strDataType == "number")
						{
							if (nodeNumber != null)
							{
								strText1 = ConvertKey(nodeNumber,strText1);
								strText2 = ConvertKey(nodeNumber,strText2);
							}
							strKeyCondition = strText1 +
								"<= keystringnum and keystringnum <= " +
								strText2 +
								" and keystringnum <> -1";
						}
					}
					else
					{
						string strOperator;
						string strRealText;

						//如果词中没有包含关系符，则按=号算
						GetPartCondition(strText, 
							out strOperator,
							out strRealText);

						if(strOperator == "!=")
							strOperator = "<>";

						if (strDataType == "string")
						{
							if (nodeString != null)
								strRealText = ConvertKey(nodeString,strRealText);

							strParameterName = "@keyValue"+strPrefix;

							strKeyCondition = " keystring" +
								strOperator +
								" "+strParameterName+" ";

							//改为parameter
							SqlParameter temp = new SqlParameter (strParameterName,SqlDbType.NVarChar);
							temp.Value = strRealText ;
							aParameter.Add (temp);
						}
						else if(strDataType == "number")
						{
							if (nodeNumber != null)
								strRealText = ConvertKey(nodeNumber,strRealText);

							strKeyCondition = " keystringnum" +
								strOperator +
								strRealText +
								" and keystringnum <> -1";    	
						}
					}
				}
				else   //普通的关系操作符
				{

					//当关系操作符为空为，按等于算
					if (strRelation == "")
						strRelation = "=";

					if(strRelation == "!=")
						strRelation = "<>";

					if (strDataType == "string")
					{

						strParameterName = "@keyValue"+strPrefix;

						strKeyCondition = " keystring " +
							strRelation +
							" "+strParameterName+" ";

						//改为parameter
						SqlParameter temp = new SqlParameter (strParameterName,SqlDbType.NVarChar);
						temp.Value = strKeyValue ;
						aParameter.Add (temp);
					}
					else if (strDataType == "number")
					{
						strKeyCondition = " keystringnum " +
							strRelation +
							strKeyValue + 
							" and keystringnum <> -1"; 
					}
				}
			}

			return strKeyCondition;
		}

		//检索
		//-2:中断
		public override int SearchByUnion(string strTableList,
			string strText,
			string strMatch,
			string strRelation,
			string strDataType,
			string strMaxCount,
			string strOrder,
			int nWarningLevel,
			string strLanguage,
			IsConnected isConnected,
			DpResultSet oResultSet,
			out int nResultCount,
			ref string strErrorInfo,
			ref string strWarningInfo)
		{
			if (strOrder == "")
				strOrder = "ASC";

			//FileUtil.WriteText("L:\\debug.txt","走到SearchByUnion里\r\n");
			nResultCount = 0;

			//**********加读锁**************
			m_lock.AcquireReaderLock(m_nTimeOut); 
			SqlConnection objSqlConnection = null;

			try
			{
				nResultCount = 0;

				bool isHaveID;
				ArrayList aTable = tableCaptions2aTableName(strTableList,strLanguage,out isHaveID);

				//FileUtil.WriteText("L:\\debug.txt","1\r\n");

				if (isHaveID == true)
				{
					//FileUtil.WriteText("L:\\debug.txt","2\r\n");

					nResultCount += SearchByID(strText,
						strMatch,
						strRelation,
						strMaxCount,
						strOrder,
						isConnected,
						oResultSet);  //注意一个这个函数
				}

				if (aTable == null || aTable.Count == 0)
				{
					//FileUtil.WriteText("L:\\debug.txt","3\r\n");

					if (isHaveID==false)
						strWarningInfo += "检索途径为null，或为空";
					
					return 0;
				}

				bool bWarning = false;
				
				//创建连接对象-----------------
				objSqlConnection =	new SqlConnection(GetLocation());
				objSqlConnection.Open();

				//存放用SQL库发出的命令
				string strCommand = "";

				//关于key的条件
				string strConditionAboutKey = "";

				//总条件
				string strWhere = "";

				//定义一个表对象(tableItem)
				tableItem oTable;

				//因为用union，所以先得到检索第一个表的命令，它不带union命令
				oTable= this.Tables .GetTableItem((string)aTable[0]);

				ArrayList aParameter = new ArrayList ();
				//FileUtil.WriteText("L:\\debug.txt","4\r\n");

				try
				{
					strConditionAboutKey = GetKeyCondition(strText,
						strMatch,
						strRelation,
						strDataType,
						oTable.m_nodeConvertQuery,
						"0",
						aParameter);

					//FileUtil.WriteText("L:\\debug.txt","5\r\n");
				}
				catch(NoMatchException ex)
				{
					strWarningInfo += ex.Message;
					bWarning = true;

					if (nWarningLevel == 0)
						return -1;
				}


				string strTop = "";
				if (strMaxCount != "")
					strTop = " TOP "+ strMaxCount + "";


			
				if (strConditionAboutKey != "")
					strWhere = " WHERE " + strConditionAboutKey;

				strCommand = " use master \n";
				strCommand += "use " + GetSqlName() + 
					" SELECT "+strTop+" DISTINCT  idstring, '"+GetID()+"'" +  //id 不用改为参数
					" FROM " + (string)aTable[0] + 
					strWhere;	

				//FileUtil.WriteText("L:\\debug.txt","6\r\n");


				//m_strDebugInfo += "<b>检索" + aTable[0] + "表的语句:</b><br/>" + strCommand + "<br/><br/>";

				for(int i = 1;i < aTable.Count;i++)
				{
					if ((string)aTable[i] == "")
						continue;

					oTable = this.Tables .GetTableItem((string)aTable[i]);

					try
					{
						strConditionAboutKey = GetKeyCondition(strText,
							strMatch,
							strRelation,
							strDataType,
							oTable.m_nodeConvertQuery,
							Convert.ToString (i),
							aParameter);

					}
					catch(NoMatchException ex)
					{
						strWarningInfo += ex.Message;
						bWarning = true;

						if (nWarningLevel == 0)
							return -1;
					}

					if (strConditionAboutKey != "")
						strWhere = " WHERE " + strConditionAboutKey;

					string strOneCommand  = " union SELECT "+strTop+" DISTINCT idstring,'" + 
						GetID()+      //id 不用改为参数
						"' FROM " + 
						aTable[i] + 
						strWhere;		//将GetLogicName改为GetID

					strCommand += strOneCommand;
					//m_strDebugInfo += "<b>检索" + aTable[i] + "表的语句:</b><br/>" + strOneCommand + "<br/><br/>";
				}

				//FileUtil.WriteText("L:\\debug.txt","7\r\n");

				strCommand += " ORDER BY idstring " + strOrder;

				//m_strDebugInfo += "<b>union后总的检索语句:</b><br/>" + strCommand + "<br/><br/>";
				SqlDataReader myReader = null;

				SqlCommand myseletecmd = null;

				try
				{
					myseletecmd = new SqlCommand(strCommand,
						objSqlConnection);

					if (aParameter == null)
						return -1;

					//加到命令的Parameters集合中
					foreach(SqlParameter parameter in aParameter)
					{
						myseletecmd.Parameters.Add (parameter);
					}

					myseletecmd.CommandTimeout = 20*60;
					DatabaseCommandTask task =
						new DatabaseCommandTask(myseletecmd);
					Thread t1 = new Thread(new ThreadStart(task.ThreadMain));
					t1.Start ();
					if (task == null)
					{
						//FileUtil.WriteText("L:\\debug.txt","task为null");
						return -1;
					}
					bool bRet;
					while(true)
					{
						if (isConnected != null)
						{
							if (isConnected(".") == false)
							{
								//FileUtil.WriteText ("L:\\debug.txt","中断了");
								break;   //注意这里
								//return -3; //表示中断
							}
							else
							{
								//FileUtil.WriteText ("L:\\debug.txt","连接");
							}
						}
						bRet = task.m_event.WaitOne(0, false);
						if(bRet == true)
						{
							//FileUtil.WriteText ("L:\\debug.txt","检索完毕");
							break;
						}
					}
					myReader = task.m_dataReader; //myseletecmd.ExecuteReader();
				}
				catch(Exception exc )
				{
					//FileUtil.WriteText ("L:\\debug.txt",exc.Message );
					Exception ex = new Exception(exc.Message);
					throw(ex);
				}

				try
				{
					if (myReader != null)
					{
						//FileUtil.WriteText ("L:\\debug.txt","开始做myReader\r\n");

						while(myReader.Read()) 
						{
							if (isConnected != null)
							{
								if (isConnected("a") == false)
								{
									break;  //注意这里
									//return -2 ; //中断
								}
							}
							string strId = ((string)myReader[1]).Trim() + ":" + (string)myReader[0];
							oResultSet.Add(new DpRecord(strId));

							nResultCount++;
						}
						myReader.Close();
					}
					else
					{
						//FileUtil.WriteText ("L:\\debug.txt","read等于null\r\n");
					}
					
					//FileUtil.WriteText("L:\\debug.txt","9\r\n");

					//string strFileName = oResultSet.Detach ();
					//FileUtil.WriteText("L:\\debug.txt","Detach()得到的文件名:["+strFileName+"]\r\n");
					//File.Copy (strFileName,"L:\\resultSet.txt");
					//return -1;

					if (bWarning == true)
						return -2;

					oResultSet.Sort ();
					oResultSet.RemoveDup ();
				}
				catch(Exception ex)
				{
					//FileUtil.WriteText("L:\\debug.txt",ex.Message +"\r\n");
					throw(ex);
				}

				if (aTable.Count>1)  //SQL语句已经去重，只有多个表时才排序，一个表时不用
				{
					oResultSet.Sort ();
				}
			}
			finally
			{
				//关闭连接对象-------------------------
				if (objSqlConnection != null)
				{
					objSqlConnection.Close();
					objSqlConnection = null;
				}
				m_lock.ReleaseReaderLock();  //解读锁
			}

			//FileUtil.WriteText ("L:\\debug.txt","退出searchByUnion");
		
			return 0;
		}




		public override int ReadRes(string strID,
			int nStart,
			int nLength,
			out byte[] destBuffer,
			out byte[] timestamp,
			out string strError)
		{
			destBuffer = null;
			timestamp = null;
			strError = "";

			string strCommand = "";
			SqlCommand command = null;

			SqlConnection connection = new SqlConnection (this.GetLocation());
			connection.Open();

			strCommand = "use " + this.GetSqlName()
				+ " SELECT @Pointer=TEXTPTR(data),"
				+ "@Length=DataLength(data),"
				+ "@timestamp=timestamp"
				+ " FROM records WHERE id=@id";
			
			command = new SqlCommand(strCommand,
				connection);

			// 给参数赋值
			SqlParameter idParam  =
				command.Parameters.Add("@id",
				SqlDbType.NVarChar);
			idParam.Value = strID;

			SqlParameter PointerOutParam =
				command.Parameters.Add("@Pointer",
				SqlDbType.VarBinary,
				100);
			PointerOutParam.Direction = ParameterDirection.Output;

			SqlParameter LengthOutParam  =
				command.Parameters.Add("@Length",
				SqlDbType.Int);
			LengthOutParam.Direction = ParameterDirection.Output;

			SqlParameter timestampParam = command.Parameters.Add("@timestamp",
				SqlDbType.VarBinary,
				8);
			timestampParam.Direction = ParameterDirection.Output;

			command.ExecuteNonQuery();

			//没有得到指针
			if(PointerOutParam.Value == null) 
			{
				strError = "没有得到image文本指针值\r\n";
				return -1;
			}

			timestamp = (byte[])timestampParam.Value;


			//请求的范围超过最大尺寸
			int nTotalLength = (int)LengthOutParam.Value;

			if (nStart > nTotalLength )
			{
				strError = "范围有误:起始大于总长度\r\n";
				return -1;
			}
			
			if (nStart + nLength > nTotalLength)
				nLength = nTotalLength - nStart;

			if (nLength == -1)  // 从开始到全部
			{
				nLength = nTotalLength - nStart;
			}


			// READTEXT命令:
			// text_ptr: 有效文本指针。text_ptr 必须是 binary(16)。
			// offset:   开始读取image数据之前跳过的字节数（使用 text 或 image 数据类型时）或字符数（使用 ntext 数据类型时）。
			//			 使用 ntext 数据类型时，offset 是在开始读取数据前跳过的字符数。
			//			 使用 text 或 image 数据类型时，offset 是在开始读取数据前跳过的字节数。
			// size:     是要读取数据的字节数（使用 text 或 image 数据类型时）或字符数（使用 ntext 数据类型时）。如果 size 是 0，则表示读取了 4 KB 字节的数据。
			// HOLDLOCK: 使文本值一直锁定到事务结束。其他用户可以读取该值，但是不能对其进行修改。

			strCommand = "use northwind"
				+ " READTEXT records.data"
				+ " @text_ptr"
				+ " @offset"
				+ " @size"
				+ " HOLDLOCK";

			command = new SqlCommand(strCommand,
				connection);

			SqlParameter text_ptrParam  =
				command.Parameters.Add("@text_ptr",
				SqlDbType.Binary,
				16);
			text_ptrParam.Value = PointerOutParam.Value; 

			SqlParameter offsetParam  =
				command.Parameters.Add("@offset",
				SqlDbType.Int);
			offsetParam.Value = nStart;

			SqlParameter sizeParam  =
				command.Parameters.Add("@size",
				SqlDbType.Int);
			sizeParam.Value = nLength;
				
			destBuffer = new Byte[nLength];

			SqlDataReader dr; 
			dr = command.ExecuteReader(CommandBehavior.SingleResult);
			dr.Read();

			dr.GetBytes(0,
				0,
				destBuffer,
				0,
				System.Convert.ToInt32(sizeParam.Value));
			dr.Close();

			connection.Close ();
			return nTotalLength;

			return 0;
		}




		public override long GetImageLength(string strID)
		{
			//创建连接对象-----------------
			SqlConnection oConnection =	new SqlConnection(GetLocation());
			oConnection.Open();

			string strCmd = "use master \n";
			strCmd += "use " + GetSqlName() +
				" SET NOCOUNT ON; SELECT id FROM records WHERE id=@id ";
			//改为Parameter
			SqlParameter parameter = new SqlParameter ("@id",SqlDbType.NVarChar);
			parameter.Value = strID;

			SqlCommand myseletecmd = new SqlCommand(strCmd,
				oConnection);
			myseletecmd.Parameters.Add (parameter);
			
			//查找是否找到记录，如果没找到，返回-1
			SqlDataReader myReader;
			myReader = myseletecmd.ExecuteReader();
			if (myReader.Read() == false)
			{
				myReader.Close();
				return -1;
			}
			myReader.Close();


			string strCommand = "use " + GetSqlName() +
				" SET NOCOUNT ON ;SELECT @Length=DataLength(data) FROM records WHERE id=N'"+strID+"'" ;
			
			SqlCommand cmd = new SqlCommand(strCommand,
				oConnection);

			SqlParameter LengthOutParam  =
				cmd.Parameters.Add("@Length",
				SqlDbType.Int);

			LengthOutParam.Direction = ParameterDirection.Output;
			cmd.ExecuteNonQuery();
			oConnection.Close ();

			int nLength = (int)LengthOutParam.Value;
			return (long)nLength;
		}




		// 从数据库得到记录
		// parameter:
		//		strID:          记录ID
		//		DestFileStream: 目标stream
		/// <param name="strContentType">文件类型</param>
		/// <param name="oConnection">传入的连接对象</param>
		/// <param name="bCheckAccount">是否内存帐户对象检查</param>
		/// <returns>
		/// 0:成功执行
		/// -1:出错
		/// </returns>
		/// <summary>
		/// 线:安全的
		/// </summary>		
		public override int GetRecord(string strID,
			Stream DestFileStream,
			out string strContentType,
			DpConnection oConnection,
			bool bCheckAccount)
		{
			strContentType = "";
			int ret = 0;

			//对帐户库开的后门，用于更新帐户
			if (bCheckAccount == true && 
				StringUtil.isInList("account",GetDbType()) == true)
			{
				ret = m_Container.m_userColl.RefreshUser(GetID()+":"+strID,true);  //将GetLogicName改GetID

				//ret==-1表示没有找到帐户对象
			}


			//********给库加读锁**************
			m_lock.AcquireReaderLock(m_nTimeOut); 

			try
			{
				//*******************给记录加读锁************************
				m_recordLockColl.Lock(strID,"reader",m_nTimeOut);

				//Thread.Sleep(10000);
				bool bExist = false;   //连接对象是否已经存在

				DpSqlConnection thisConnection = null;
				try
				{
					if (oConnection == null)
					{
						thisConnection =
							new DpSqlConnection(GetLocation());

						thisConnection.Open();
					}
					else 
					{
						thisConnection = (DpSqlConnection)oConnection;

						if (thisConnection.m_sqlConnection.State.ToString() == "Closed")
							thisConnection.Open();

						bExist=true;
					}

					string strCmd = "use master \n";
					strCmd += "use " + GetSqlName() +
						" SET NOCOUNT ON; SELECT id FROM records WHERE id=@id ";

					//改为Parameter
					SqlParameter parameter = new SqlParameter ("@id",SqlDbType.NVarChar);
					parameter.Value = strID;

					SqlCommand myseletecmd = new SqlCommand(strCmd,
								   thisConnection.m_sqlConnection);
					myseletecmd.Parameters.Add (parameter);
			
					//查找是否找到记录，如果没找到，返回-1
					SqlDataReader myReader;
					myReader = myseletecmd.ExecuteReader();
					if (myReader.Read() == false)
					{
						myReader.Close();
						return -1;
					}
					myReader.Close();


					//当目标不等于null时，把记录内容放到stream里，
					//注意有时不需要得到记录内容，只是查看一下记录是否存在，可以将DestFileStream参数设为null
					if (DestFileStream != null)
					{
						string strCommand = "use master \n";
						strCommand += "use " + GetSqlName() +
							" SET NOCOUNT ON ;SELECT @Pointer=TEXTPTR(data), @Length=DataLength(data), @strContentType=contentType FROM records WHERE id=@id";

						//待改parameter

						//调getImage()函数，将数据库image字段的内容写到stream;
						ret = getImage(DestFileStream,
							strCommand,
							thisConnection,
							strID,
							out strContentType);

						//将stream的指针拨到0
						DestFileStream.Seek(0,SeekOrigin.Begin);
					}
				}
				finally
				{
					//如果是本函数新建的连接对象，则关闭
					if (bExist == false)
					{
						if (thisConnection != null)
						{
							thisConnection.Close();
							thisConnection = null;
						}
					}

					m_recordLockColl.UnLock(strID,"reader");      //*********解记录读锁******
				}
			}
			finally
			{
				m_lock.ReleaseReaderLock();  //**************解库读锁
			}

			return ret;	
		}


		/// <summary>
		/// 重写WriteRes函数，向库中写对象资源
		/// </summary>
		/// <param name="strID">记录ID</param>
		/// <param name="SourceFileStream">源stream</param>
		/// <param name="strContentType">文件类型</param>
		/// 
		/// <summary>
		/// 线: 安全的
		/// 
		/// 调用下列函数:
		/// 1.GetLocation()--------------      -----------Dp.DatabaseLib.Database
		/// 2.GetRecord()------------           ----------Dp.DatabaseLib.SqlDatabase
		/// 2.writeImage()------------           ----------Dp.DatabaseLib.SqlDatabase
		/// 
		/// </summary>
		public override int WriteRes(string strID,
			Stream SourceFileStream,
			string strContentType)
		{
			m_lock.AcquireReaderLock(m_nTimeOut); //加库读锁	
			try
			{
				//*******************给记录加写锁************************
				m_recordLockColl.Lock(strID,"writer",m_nTimeOut);
				DpSqlConnection tempConnection = null;
				try
				{
					int ret ;
					//创建并打开连接对象DpSqlConnection--------
					tempConnection = new DpSqlConnection(GetLocation());
					tempConnection.Open();

					string strCommand = "use master \n";
					strCommand += "use " + GetSqlName() + "\n"
						+ " SET NOCOUNT ON;"
						+ " INSERT INTO records(id,data,contentType)"
						+ " VALUES(@id,0x0,@contentType);" 
						+ " SELECT @Pointer=TEXTPTR(data) FROM records WHERE id=@id ";

					// 只检查记录是否存在
					string strContentType1;
					ret = GetRecord(strID,
						null,
						out strContentType1,
						tempConnection,
						false);

					//找到记录则修改命令为Update
					if (ret == 0)
					{
						strCommand = "use " + GetSqlName() + "\n"
							+ " SET NOCOUNT ON;"
							+ " UPDATE records SET id=@id,data=0x0,contentType=@contentType"
							+ " WHERE id=@id;"
							+ " SELECT @Pointer=TEXTPTR(data) FROM records WHERE id=@id";  //改为Parameter
					}
					ret = writeImage(SourceFileStream,
						strCommand,
						tempConnection,
						strID,
						strContentType);  //id为了设@id参数的值
				}
				finally
				{
					//关闭连接对象
					if (tempConnection != null)
					{
						tempConnection.Close();
						tempConnection = null;
					}
					m_recordLockColl.UnLock(strID,"writer");  //*************解记录的写锁
				}
			}
			finally
			{
				m_lock.ReleaseReaderLock();  //**********************解库读锁
			}
			return 0;
		}




		//重写Write函数，将元数据XML文件写到数据库
		//myID: 记录ID
		//SourceFileStream: 源stream
		//strContentType: 文件类型
		//bCheckAccount: 是否进行内存对象的检查
		//返回记录号(字符串类型)
		//线: 不安全
		public override string Write(string myID,
			Stream SourceFileStream,
			string strContentType,
			bool bCheckAccount,
			out string strRecordID)
		{
			string strID;
			
			if (myID == "-1") //-1代表追加记录
			{
				//调getNewSeed()得到记录号种子
				strID = Convert.ToString(getNewSeed());
			}
			else
			{
				strID = myID; //按指定的记录号保存
			}

			//加库读锁**********************
			m_lock.AcquireReaderLock(m_nTimeOut); 
   
			try
			{
				//1.先把记录号处理好////////////////////////

				//不足10位时，换成10位表示法
				if (strID.Length < 10)  
				{
					string strTemp = new string('0',10-strID.Length);
					strID = strTemp + strID;
				}
				//用正则表达式校验，记录号是否合法,
				//注意如果多处使用同一个正则表达式，要换成一个全局变量
				if (StringUtil.RegexCompare(@"\B[0123456789]+",strID) == false)
				{
					throw(new Exception ("记录号:'" + strID + "'不合法！"));
				}
				//调SetIfGreaten()函数，如果本记录号大于尾号，将库读锁上升到写锁，修改尾号
				//这种情况发生在我们给的记录号超过尾号时
				SetIfGreaten(Convert.ToInt32(strID),true);

	
				//返回的记录号
				strRecordID = strID;

				//2.连接数据库

				int ret = 0;
				DpSqlConnection tempConnection = null;

				//**********给加记录加写锁***************
				m_recordLockColl.Lock(strID,"writer",m_nTimeOut);
				try
				{
					//把Xml流移到开始位置
					SourceFileStream.Seek(0,SeekOrigin.Begin);

					//新建连接对象--------------
					tempConnection = new DpSqlConnection(GetLocation());
					tempConnection.Open();

					//新加记录的命令
					string strCommand = "use master \n";
					strCommand += "use " + GetSqlName() +
						" SET NOCOUNT ON;INSERT INTO records(id,data,contentType) VALUES(@id,0x0,@contentType) ;" +
						"SELECT @Pointer=TEXTPTR(data) FROM records WHERE id=@id";

					DpKeys oldKeys = new DpKeys();
					DpKeys newKeys = new DpKeys();

					//加载配置文件
					XmlDocument m_cfgDom = new XmlDocument();
					m_cfgDom.Load(m_Container.CfgDir + GetKeys());

					//加载新Xml
					XmlDocument newDataDom = new XmlDocument();
					newDataDom.Load(SourceFileStream);
					SourceFileStream.Close ();

					XmlNode nodeID = newDataDom.SelectSingleNode ("//__id");
					DomUtil.SetNodeText (nodeID,strID);

					newKeys.Create(newDataDom,
						m_cfgDom,
						strID,
						m_Container.KeySize,
						this);   //改stopword

					newKeys.Sort();
					newKeys.RemoveDup();


					//从数据库中提旧Xml，创新旧检查点
					MemoryStream fs = new MemoryStream();
					string 	myContentType;	
					ret = GetRecord(strID,
						fs,
						out myContentType,
						tempConnection,
						false);

					if (ret == 0)   //记录找到
					{
						fs.Seek(0,SeekOrigin.Begin);

						XmlDocument oldDataDom = new XmlDocument();
						oldDataDom.Load(fs);

						oldKeys.Create(oldDataDom,
							m_cfgDom,
							strID,
							m_Container.KeySize,
							this);
						oldKeys.Sort();
						oldKeys.RemoveDup();

						//更新原记录的命令
						strCommand = "use " + GetSqlName() +
							" SET NOCOUNT ON;UPDATE records SET id=@id,data=0x0,contentType=@contentType WHERE id=@id " +
							";SELECT @Pointer=TEXTPTR(data) FROM records WHERE id=@id";
					}

					fs.Close();

					//把新Xml写到库里,会覆盖原来的旧Xml
					MemoryStream mfs = new MemoryStream ();
					newDataDom.Save (mfs);
					mfs.Seek (0,SeekOrigin.Begin);
					ret = writeImage(mfs,
						strCommand,
						tempConnection,
						strID,
						strContentType);
					mfs.Close ();

					//新旧检索点碰
					DpKeys dupKeys = new DpKeys();
					string myInfo = "";
					dupKeys = DpKeys.Merge(newKeys,oldKeys,out myInfo);

					//m_strDebugInfo += "新Keys<br/>" + newKeys.Dump() + "<br/>";
					//m_strDebugInfo += "旧Keys<br/>" + oldKeys.Dump() + "<br/>";
					//m_strDebugInfo += "重新Keys<br/>" + dupKeys.Dump() + "<br/>";

					foreach(DpKey oneKey in newKeys)
					{
						//加keynum
						string strTempCommand = "use " + GetSqlName() +
							" INSERT INTO keys_" + oneKey.Table +
							"(keystring,fromstring,idstring,keystringnum) ";

						//暂时不用，看看是否会报错
						//string strTemp = ExtendByPrecision(oneKey.Num,"0");
						//if (strTemp != null)
						//	strTemp = "";

						strTempCommand += "VALUES(@key,@from,@id,@keynum)";

						SqlCommand cmdInsertKey = new SqlCommand(strTempCommand,tempConnection.m_sqlConnection);

						//改为parameter
						SqlParameter temp = null;
						temp = new SqlParameter ("@key",SqlDbType.NVarChar);
						temp.Value = oneKey.Key ;
						cmdInsertKey.Parameters.Add (temp);

						temp = new SqlParameter ("@from",SqlDbType.NVarChar);
						temp.Value = oneKey.From ;
						cmdInsertKey.Parameters.Add (temp);

						temp = new SqlParameter ("@id",SqlDbType.NVarChar);
						temp.Value = oneKey.ID ;
						//FileUtil.WriteText("L:\\debug.txt",temp.Value+"\r\n");
						cmdInsertKey.Parameters.Add (temp);

						temp = new SqlParameter ("@keynum",SqlDbType.NVarChar);
						//temp.Value = ExtendByPrecision(oneKey.Num,"0") ;
						temp.Value = oneKey.Num ;
						cmdInsertKey.Parameters.Add (temp);

						cmdInsertKey.ExecuteNonQuery();


						//m_strDebugInfo += newKeys.m_strDebugInfo;
					}

					foreach(DpKey oneKey in oldKeys)
					{
						SqlCommand cmdDeleteKey = new SqlCommand("use " + GetSqlName() +
							" DELETE FROM keys_" + oneKey.Table +
							" WHERE keystring = @key AND fromstring= @from AND idstring=@id", 
							tempConnection.m_sqlConnection);

						//改为parameter
						SqlParameter temp = null;
						temp = new SqlParameter ("@key",SqlDbType.NVarChar);
						temp.Value = oneKey.Key ;
						cmdDeleteKey.Parameters.Add (temp);

						temp = new SqlParameter ("@from",SqlDbType.NVarChar);
						temp.Value = oneKey.From ;
						cmdDeleteKey.Parameters.Add (temp);

						temp = new SqlParameter ("@id",SqlDbType.NVarChar);
						temp.Value = oneKey.ID ;
						cmdDeleteKey.Parameters.Add (temp);

						temp = new SqlParameter ("@keynum",SqlDbType.NVarChar);
						//temp.Value = ExtendByPrecision(oneKey.Num,"0") ;
						temp.Value = oneKey.Num;
						cmdDeleteKey.Parameters.Add (temp);


						cmdDeleteKey.ExecuteNonQuery();				
					}
					
				}

				finally
				{
					//---------关闭连接对象
					if (tempConnection != null)
					{
						tempConnection.Close();
						tempConnection = null;
					}

					//解记录写锁****************************
					m_recordLockColl.UnLock(strID,"writer");
				}
			}
			finally
			{
				//解库读锁************************
				m_lock.ReleaseReaderLock();  
			}

			//是否检查帐户，以便保持最新
			if (bCheckAccount == true && 
				StringUtil.isInList("account",GetDbType()) == true)
			{
				int ret;
				ret = m_Container.m_userColl.RefreshUser(GetID()+":"+strID,false);   //将GetLogicName改GetID  

			}
			return strID;
		}


		//写XML元数据及一组对象
		public override int Write(string myID,
			Stream SourceFileStream,
			string strContentType,
			bool bCheckAccount,
			StreamItem[] aStream,
			out string strRecordID)
		{
			//写XML元数据
			string strID = Write(myID,
				SourceFileStream,
				strContentType,
				false,
				out strRecordID);

			//写对象资源
			if (aStream != null)
			{
				for(int i=0 ;i<aStream.Length ;i++)
				{
					if (aStream[i] == null)
						continue;

					string strCompleteID = strID + "_" + aStream[i].m_strID;
					WriteRes(strCompleteID,aStream[i].m_stream,"oFile");
				}
			}
			return 0;
		}

		//重写DeleteForce函数，强制删除记录
		//strID: 记录ID
		//strInfo: 删除信息
		//返回值: 删除的记录数量
		//线: 不安全
		//这个地方没必要加锁，保证里面用加过锁的函数
		public override int DeleteForce(string strID,
			bool bFile,
			out string strInfo)
		{
			strInfo = "" ;
			int ret = 0;

			//******加库读锁***********
			m_lock.AcquireReaderLock(m_nTimeOut);
			try
			{
				//********加记录写锁********
				m_recordLockColl.Lock(strID,"writer",m_nTimeOut);
				SqlConnection tempConnection = null;
				try
				{
					//新建连接对象------------
					tempConnection = new SqlConnection(GetLocation());
					tempConnection.Open();

					string strCmd = "use master \n";
					strCmd += "use " + GetSqlName() +
						" DELETE FROM records WHERE id =@id";

					SqlCommand cmddel;
					cmddel = new SqlCommand(strCmd,tempConnection);

					//改为parameter
					SqlParameter temp = null;
					temp = new SqlParameter ("@id",SqlDbType.NVarChar);
					temp.Value = strID ;
					cmddel.Parameters.Add (temp);

					ret = cmddel.ExecuteNonQuery();
					if (bFile == true)   //删除文件
						return ret;


					int nTemp;
					foreach (tableItem oneTable in this.Tables )
					{
						strCmd = "use master \n";
						strCmd += "use " + GetSqlName() +
							" DELETE FROM " + oneTable.Name +
							" WHERE idstring=@id";

						cmddel = new SqlCommand(strCmd,tempConnection);

						temp = new SqlParameter ("@id",SqlDbType.NVarChar);
						temp.Value = strID ;
						cmddel.Parameters.Add (temp);

						nTemp = cmddel.ExecuteNonQuery();

						if (nTemp != 0)
							strInfo += "从" + oneTable.Name + "表中删除了" + Convert.ToString(nTemp) + "行<br/>";
					}
				}
				finally
				{
					//关闭连接对象-------------
					if (tempConnection != null)
					{
						tempConnection.Close();
						tempConnection = null;
					}
					m_recordLockColl.UnLock(strID,"writer"); 
					//************解记录写锁******
				}
			}
			finally
			{
				m_lock.ReleaseReaderLock();  
				//************解库读锁**************
			}
			return ret;
		}



		//重写Delete函数，普通删除记录
		//strID: 记录ID
		//strResult: 删除信息
		//返回值: 注意调一下
		//为什么要加写锁:其实这里可以不加记录写锁的，因为是对SQL操作
		public override int Delete(string strID,
			out string strResult)
		{
			//********加库读锁*********************
			m_lock.AcquireReaderLock(m_nTimeOut); 
			int ret = 0;
			try
			{
				DpSqlConnection tempConnection = null;
				strResult = "";

				//*********加记录写锁**********
				m_recordLockColl.Lock(strID,"writer",m_nTimeOut); 
				//加try是为了在抛出异常时解锁
				try
				{
					//新建连接对象-------------
					tempConnection = new DpSqlConnection(GetLocation());
					tempConnection.Open();

					//先提取记录
					string myContentType;
					MemoryStream fs = new MemoryStream();
					ret = GetRecord(strID,
						fs,
						out myContentType,
						tempConnection,
						false);  

					if (ret == 0)
					{
						SqlCommand cmdDel;
						XmlDocument oldDataDom = new XmlDocument();
						oldDataDom.Load(fs);

						//删除子文件
						XmlNodeList fileList = oldDataDom.SelectNodes ("//file");
						foreach(XmlNode fileNode in fileList)
						{
							string strFileID = strID + "_" + DomUtil.GetNodeText (fileNode);
							string strMessage;
							this.DeleteForce (strFileID,true,out strMessage);
						}

						XmlDocument m_cfgDom = new XmlDocument();
						m_cfgDom.Load(m_Container.CfgDir + GetKeys());
				
						DpKeys oldKeys = new DpKeys();
						oldKeys.Create(oldDataDom,
							m_cfgDom,
							strID,
							m_Container.KeySize,
							this);

						oldKeys.Sort();
						oldKeys.RemoveDup();

						string strCmd = "" ;

						SqlParameter temp = null;
						//删除检查点
						foreach(DpKey oneKey in oldKeys)
						{
							strCmd = "use master \n";
							strCmd += "use " + GetSqlName() +
								" DELETE FROM keys_" + oneKey.Table +
								" WHERE keystring = @key AND fromstring=@from AND idstring=@id";
							cmdDel = new SqlCommand(strCmd,tempConnection.m_sqlConnection);

							//改为parameter
							temp = new SqlParameter ("@key",SqlDbType.NVarChar);
							temp.Value = oneKey.Key ;
							cmdDel.Parameters.Add (temp);

							//改为parameter
							temp = new SqlParameter ("@from",SqlDbType.NVarChar);
							temp.Value = oneKey.From ;
							cmdDel.Parameters.Add (temp);

							//改为parameter
							temp = new SqlParameter ("@id",SqlDbType.NVarChar);
							temp.Value = oneKey.ID ;
							cmdDel.Parameters.Add (temp);

							cmdDel.ExecuteNonQuery();				
						}

						//删除自己
						strResult += oldKeys.Dump();
						strCmd = "use master \n";
						strCmd += "use " + GetSqlName() +
							" DELETE FROM records WHERE id = @id";
						cmdDel = new SqlCommand(strCmd,tempConnection.m_sqlConnection);


						//改为parameter
						temp = new SqlParameter ("@id",SqlDbType.NVarChar);
						temp.Value = strID ;
						cmdDel.Parameters.Add (temp);

						cmdDel.ExecuteNonQuery();
					}
					fs.Close();
				}
				finally
				{
					//关闭连接对象----------------
					if (tempConnection != null)
					{
						tempConnection.Close();
						tempConnection = null;
					}
					m_recordLockColl.UnLock(strID,"writer"); //解记录写锁
				}
			}
			finally
			{
				m_lock.ReleaseReaderLock();  //解库读锁
			}

			return ret;
		}

	}// end of class SqlDatabase


	//文件库派生类
	public class FileDatabase : Database
	{
		public FileDatabase(XmlNode nodeDb,
			DatabaseCollection container):base(nodeDb,container)
		{}


		//重写Initialize函数，初始化数据目录
		//返回值: 处理信息
		//线: 不安全
		//调用下列函数:
		//1.DeleteDir()---------       --------Dp.DatabaseLib.Database
		//2.SaveXml()---------       --------Dp.DatabaseLib.DatabaseCollection
		//为什么要做加锁:因为DeleteDir(),seed
		public override int Initialize(out string strInfo)
		{
			strInfo = "";

			//************加库写锁*********
			m_lock.AcquireWriterLock(m_nTimeOut); 
			try
			{
				DeleteDir();  //参数(m_strLocation);

				string strText = @"<?xml version='1.0' encoding='utf-8' ?><root></root>";
				foreach (tableItem oneTable in this.Tables )
				{
					string strKeyFileName = GetLocation() + id2FileName(oneTable.Name.Trim());//oneTable.Name.Trim() + ".xml";
					FileUtil.String2File(strText,strKeyFileName);

					strInfo += strKeyFileName+"<br/>";
				}
				SetSeed(0);
				m_Container.SaveXml();
			}
			finally
			{
				m_lock.ReleaseWriterLock(); 
				//**************解库写锁************
			}
			return 0;
		}

		//得到记录的长度
		public override long GetImageLength(string strID)
		{
			//处理不同的文件
			int nPosition = strID.IndexOf ('.');
			if (nPosition < 0)
				strID = id2FileName(strID);

			long lLength;
			string strObjPath = GetLocation() + strID;//id2FileName(strID);
			if (File.Exists (strObjPath) == false)
				return -1;
			
			FileStream fs = File.Open (strObjPath,FileMode.Open);
			lLength = fs.Length ;
			fs.Close ();
			return lLength;
		}

		//取指定部分的记录
		public override int GetPartRecord(string strID,
			long lStart,
			long lLength,
			Stream target,
			out string strInfo)
		{
			strInfo = "";

			//**********加库读锁***************
			m_lock.AcquireReaderLock(m_nTimeOut); 
			try
			{
				//********加记录读锁*************
				m_recordLockColl.Lock(strID,"reader",m_nTimeOut); 
				try
				{
					string strObjPath;
					if (strID.Length > 10)
						strObjPath = GetLocation() + strID;
					else
						strObjPath = GetLocation() + id2FileName(strID); //strID + ".xml";

					if (File.Exists(strObjPath))
					{
						Stream fs = new FileStream(strObjPath,FileMode.Open,FileAccess.Read);
						
						if (lStart+lLength>fs.Length )
						{
							strInfo += "范围有误:起始与长度相加大于总长度\r\n";
							return -1;
						}
						if (lStart>=fs.Length )
						{
							strInfo += "范围有误:起始大于总长度\r\n";
							return -1;
						}
						if (lLength > fs.Length )
						{
							strInfo += "范围有误:所给长度"+Convert.ToString (lLength)+",大于总长度"+Convert.ToString (fs.Length )+"\r\n";
							return -1;
						}
						fs.Seek (lStart,SeekOrigin.Begin );
						long lWrited = StreamUtil.DumpStream(fs,target,lLength);
						if (lLength != lWrited)
						{
							strInfo += "读到的长度与所要求的长度不等";
							return -1;
						}
						//target.Seek(0,SeekOrigin.Begin);
						fs.Close();
						return 0;
					}
				}
				finally
				{
					m_recordLockColl.UnLock(strID,"reader"); 
					//*********解记录读锁************
				}
			}
			finally
			{		
				m_lock.ReleaseReaderLock();  
				//***********解库读锁************
			}
			return -1;
		}
		
		//重写GetRecord函数，从数据目录里得到指定记录
		//strID: 记录ID
		//DestFileStream: 源stream
		//strContentType: 文件类型,注意
		//myConnection: 连接对象
		//bCheckAccount: 连接对象是否进行内存帐户对象检查
		//0:正常 -1:出错
		public override int GetRecord(string strID,
			Stream DestFileStream,
			out string strContentType,
			DpConnection myConnection,
			bool bCheckAccount)
		{
			if (bCheckAccount == true && 
				StringUtil.isInList("account",GetDbType()) == true)
			{
				int ret;
				ret = m_Container.m_userColl.RefreshUser(GetID()+":"+strID,true);  //将GetLogicName改GetID
				//if (ret == -1)表示没有找到帐户对象
			}
			//*********加库读锁***************
			m_lock.AcquireReaderLock(m_nTimeOut); 
			try
			{
				//************加记录读锁************
				m_recordLockColl.Lock(strID,"reader",m_nTimeOut);
				try
				{
					strContentType = "";
					string strObjPath;

					if (strID.Length > 10)
						strObjPath = GetLocation() + strID;
					else
						strObjPath = GetLocation() + id2FileName(strID); //strID + ".xml";

					if (File.Exists(strObjPath))
					{
						Stream fs = new FileStream(strObjPath,FileMode.Open,FileAccess.Read);
						StreamUtil.DumpStream(fs,DestFileStream);
						DestFileStream.Seek(0,SeekOrigin.Begin);
						fs.Close();
						return 0;
					}
				}
				finally
				{
					m_recordLockColl.UnLock(strID,"reader"); 
					//********解记录读锁**************
				}
			}
			finally
			{		
				m_lock.ReleaseReaderLock();  
				//***********解库读锁****************
			}
			return -1;
		}


		//重写WriteRes函数，将对象资源保存到数据目录里
		//strID: 记录ID
		//SourceFileStream: 源stream(对象)
		//strContentType: 文件类型
		//线: 安全的
		//调用下列函数:
		//1.GetLocation()---------       --------Dp.DatabaseLib.Database
		public override int WriteRes(string strID,
			Stream SourceFileStream,
			string strContentType)
		{
			//***********加库读锁*************
			m_lock.AcquireReaderLock(m_nTimeOut); 
			try
			{
				//*************加记录写锁**************
				m_recordLockColl.Lock(strID,"writer",m_nTimeOut); 
				try
				{
					string strObjPath;
					strObjPath = GetLocation() + strID;
					Stream fs = new FileStream(strObjPath,FileMode.Create,FileAccess.Write);
					SourceFileStream.Seek(0,SeekOrigin.Begin);
					StreamUtil.DumpStream(SourceFileStream,fs);
					SourceFileStream.Close();
					fs.Close();
				}
				finally
				{
					m_recordLockColl.UnLock(strID,"writer"); 
					//*********加记录写锁************
				}
			}
			finally
			{
				m_lock.ReleaseReaderLock();  
				//**************解库读锁**************
			}
			return 0;
		}


		//重写Write函数，将元数据XML文件保存到数据目录里
		//myID: 记录ID
		//SourceFileStream: 源stream(Xml)
		//strContentType: 文件类型
		//bCheckAccount: 是否进行内存对象检查
		//返回值:处理信息
		public override string Write(string myID,
			Stream SourceFileStream,
			string strContentType,
			bool bCheckAccount,
			out string strRecordID)
		{
			string strID;
			//追加情况
			if (myID == "-1")
				strID = Convert.ToString(getNewSeed());
			else
				strID = myID;
			//如果长度小于10，转换成10位，应改为调静态函数
			if (strID.Length < 10)
			{
				string strTemp = new string('0',10-strID.Length);
				strID = strTemp + strID;
			}

			int ret = 0;

			//*********加库读锁****************
			m_lock.AcquireReaderLock(m_nTimeOut); 
			try
			{
				//注意如果不是数字应抛出异常
				if (StringUtil.RegexCompare(@"\B[0123456789]+",strID) == false)
				{	
					throw(new Exception ("记录号:'" + strID + "'不合法!"));
				} 
				
				//记录号超过尾号，尾号上升
				SetIfGreaten(Convert.ToInt32(strID),true);

				//返回的记录号
				strRecordID = strID;

				//*********加记录写锁*****************
				//把加锁移到这里是因为，统一的ID
				m_recordLockColl.Lock(strID,"writer",m_nTimeOut); 
				try
				{
					SourceFileStream.Seek(0,SeekOrigin.Begin);

					DpKeys oldKeys = new DpKeys();
					DpKeys newKeys = new DpKeys();

					XmlDocument m_cfgDom = new XmlDocument();
					m_cfgDom.Load(m_Container.CfgDir + GetKeys());

					XmlDocument newDataDom = new XmlDocument();
					newDataDom.Load(SourceFileStream);
					SourceFileStream.Close();


					XmlNode nodeID = newDataDom.SelectSingleNode ("//__id");
					DomUtil.SetNodeText (nodeID,strID);

					newKeys.Create(newDataDom,
						m_cfgDom,
						strID,
						m_Container.KeySize,
						this);

					newKeys.Sort();
					newKeys.RemoveDup();

					string strObjPath;
					strObjPath = GetLocation() + id2FileName(strID); //strID + ".xml";

					DpFileConnection myConnection = new DpFileConnection("test"); //这个地方实际用不到

					MemoryStream oldStream = new MemoryStream();
					string strContentType1;

					ret = GetRecord(strID,
						oldStream,
						out strContentType1,
						myConnection,
						false);

					if (ret == 0)
					{
						XmlDocument oldDataDom = new XmlDocument();
						oldDataDom.Load(strObjPath);

						oldKeys.Create(oldDataDom,
							m_cfgDom,
							strID,
							m_Container.KeySize,
							this);

						oldKeys.Sort();
						oldKeys.RemoveDup();
					}

					newDataDom.Save(strObjPath);

					DpKeys dupKeys = new DpKeys();
					string myInfo = "";
					dupKeys= DpKeys.Merge(newKeys,oldKeys,out myInfo);
					//m_strDebugInfo += "新:"+newKeys.Dump();
					//m_strDebugInfo += newKeys.m_strDebugInfo +"<br/>" ;

					//m_strDebugInfo += "旧："+oldKeys.Dump();
					//m_strDebugInfo += oldKeys.m_strDebugInfo +"<br/>" ;

					//m_strDebugInfo += "重复"+dupKeys.Dump();
					//m_strDebugInfo += dupKeys.m_strDebugInfo +"<br/>" ;

					foreach(DpKey oneKey in newKeys)
					{

						//m_strDebugInfo += newKeys.m_strDebugInfo;

						string strTablePath;
						strTablePath = GetLocation() + "keys_" + id2FileName(oneKey.Table) ;//oneKey.Table + ".xml";
						XmlDocument domTable = new XmlDocument();
						domTable.Load(strTablePath);


						//新建key节点
						XmlNode nodeKey = domTable.CreateElement("key");

						XmlNode nodeKeystring = domTable.CreateElement("keystring");
						DomUtil.SetNodeText(nodeKeystring,oneKey.Key.Trim().Replace("\n",""));
						nodeKey.AppendChild(nodeKeystring);

						XmlNode nodeFromstring = domTable.CreateElement("fromstring");
						DomUtil.SetNodeText(nodeFromstring,oneKey.From.Trim());
						nodeKey.AppendChild(nodeFromstring);

						XmlNode nodeIdstring = domTable.CreateElement("idstring");
						DomUtil.SetNodeText(nodeIdstring,oneKey.ID.Trim());
						nodeKey.AppendChild(nodeIdstring);

						XmlNode nodeKeystringnum = domTable.CreateElement("keystringnum");
						//string strTemp = ExtendByPrecision(oneKey.Num,"0") ;
						DomUtil.SetNodeText(nodeKeystringnum,oneKey.Num);
						nodeKey.AppendChild(nodeKeystringnum);

						domTable.DocumentElement.AppendChild(nodeKey);
						domTable.Save(strTablePath);
					}

					foreach(DpKey oneKey in oldKeys)
					{
						string strTablePath;
						strTablePath = GetLocation() + "keys_" + id2FileName(oneKey.Table); //oneKey.Table + ".xml";
						XmlDocument domTable = new XmlDocument();
						domTable.Load(strTablePath);
				
						XmlNode nodeKey = domTable.SelectSingleNode("/root/key[keystring='" + oneKey.Key + "' and fromstring='" + oneKey.From + "' and idstring='" + oneKey.ID + "']");

						if (nodeKey != null)
						{
							domTable.DocumentElement.RemoveChild(nodeKey);
						}
						domTable.Save(strTablePath);
					}
				}
				finally
				{
					m_recordLockColl.UnLock(strID,"writer"); 
					//***********解记录写锁*******
				}
			}
			finally
			{
				m_lock.ReleaseReaderLock();  
				//************解库读锁***********
			}


			//是否检索帐户，以便保存最新
			if (bCheckAccount == true && 
				StringUtil.isInList("account",GetDbType()) == true)
			{
				ret = m_Container.m_userColl.RefreshUser(GetID()+":"+strID,false);   //将GetLogicName改GetID
			}
			return strID;
		}

		//将Xml和一组附件保存到库里
		public override int Write(string myID,
			Stream SourceFileStream,
			string strContentType,
			bool bCheckAccount,
			StreamItem[] aStream,
			out string strRecordID)
		{
			//保存xml
			string strID = Write(myID,
				SourceFileStream,
				strContentType,
				false,
				out strRecordID);

			//保存附件
			if (aStream != null)
			{
				for(int i=0 ;i<aStream.Length ;i++)
				{
					if (aStream[i] == null)
						continue;
					string strCompleteID =
						strID + "_" + aStream[i].m_strID;
					WriteRes(strCompleteID,aStream[i].m_stream,"oFile");
				}
			}
			return 0;
		}


		//重写DeleteForce函数，强制删除记录
		//strID: 记录ID
		//strInfo: 删除信息
		//0: 成功 
		//线: 不安全
		//调用下列函数:
		//1.GetLocation()---------       --------Dp.DatabaseLib.Database
		//为什么要加写锁？因为这时要修改检索表 和 删除记录
		public override int DeleteForce(string strID,
			bool bFile,
			out string strInfo)
		{
			//*************加库读锁************
			m_lock.AcquireReaderLock(m_nTimeOut); 
			try
			{
				//*************加记录写锁*************
				m_recordLockColl.Lock(strID,"writer",m_nTimeOut); 
				try
				{
					strInfo = "";
					string strObjPath;
					//删除文件
					if (bFile == true)
					{
						strObjPath = GetLocation() +strID;
						File.Delete(strObjPath);
						return 0;
					}


					//从该记录所有的Keys表中查找,删除相关记录
					foreach (tableItem oneTable in this.Tables )
					{
						strObjPath = GetLocation() + id2FileName(oneTable.Name.Trim());//oneTable.Name.Trim() + ".xml";
						XmlDocument domTable = new XmlDocument();
						domTable.Load(strObjPath);

						XmlNodeList listKey = domTable.SelectNodes("/root/key[idstring='" + strID + "']");
				
						//修改检索表是加写锁的原因之一
						foreach(XmlNode nodeKey in listKey)
						{
							domTable.DocumentElement.RemoveChild(nodeKey);
						}
						domTable.Save(strObjPath);

						if (listKey != null)
						{
							strInfo += "从"+oneTable.Name.Trim() + "表中删除了" + Convert.ToString(listKey.Count) + "行<br/>";
						}
					}

					//删除记录
					strObjPath = GetLocation() + id2FileName(strID);//strID + ".xml";
					File.Delete(strObjPath);
				}
				finally
				{
					m_recordLockColl.UnLock(strID,"writer"); //解记录写锁
				}
			}
			finally
			{
				m_lock.ReleaseReaderLock();  //解库读锁
			}
			return 0;
		}

		//重写Delete函数，普通删除记录
		//strID: 记录ID
		//strResult: 处理结果字符串
		//返回值需重考虑
		//线: 安全的
		//为什么要加写锁：因为是删除记录以及相应的检索点，在这个时期，该记录即不能读也不写，所以加写锁
		public override int Delete(string strID,
			out string strResult)
		{
			int ret;

			//*********加库读锁**************
			m_lock.AcquireReaderLock(m_nTimeOut); 
			try
			{
				//***********加记录写锁**********
				m_recordLockColl.Lock(strID,"writer",m_nTimeOut); 
				try
				{
					strResult = "";
					string myContentType;
					DpFileConnection tempConnection = new DpFileConnection("test_connection");
					MemoryStream fs = new MemoryStream();

					//从库中得到这条记录,GetRecord加读锁
					ret = GetRecord(strID,
						fs,
						out myContentType,
						tempConnection,
						false);  //改

					if (ret == 0)
					{
						XmlDocument oldDataDom = new XmlDocument();
						oldDataDom.Load(fs);

						XmlDocument m_cfgDom = new XmlDocument();
						m_cfgDom.Load(m_Container.CfgDir + GetKeys());
				
						//删除子文件
						XmlNodeList fileList = oldDataDom.SelectNodes ("//file");
						foreach(XmlNode fileNode in fileList)
						{
							string strFileID = strID + "_" + DomUtil.GetNodeText (fileNode);
							string strMessage;
							this.DeleteForce (strFileID,true,out strMessage);
						}


						//生成检索点集合
						DpKeys oldKeys = new DpKeys();
						oldKeys.Create(oldDataDom,
							m_cfgDom,
							strID,
							m_Container.KeySize,
							this);
						oldKeys.Sort();
						oldKeys.RemoveDup();

						//删除检索点
						foreach(DpKey oneKey in oldKeys)
						{
							string strTablePath;
							strTablePath = GetLocation() + "keys_" + id2FileName(oneKey.Table ); //oneKey.Table + ".xml";
							XmlDocument domTable = new XmlDocument();
							domTable.Load(strTablePath);
				
							XmlNode nodeKey = domTable.SelectSingleNode("/root/key[keystring='"+oneKey.Key+"' and fromstring='"+oneKey.From+"' and idstring='"+oneKey.ID+"']");

							if (nodeKey != null)
							{
								domTable.DocumentElement.RemoveChild(nodeKey);
							}
							domTable.Save(strTablePath);
						}

						strResult += oldKeys.Dump();
					}
					fs.Close();

					string strObjPath;
					strObjPath = GetLocation() + id2FileName(strID);//strID + ".xml";

					//删除本记录
					if (File.Exists(strObjPath))
						File.Delete(strObjPath);
				}
				finally
				{
					m_recordLockColl.UnLock(strID,"writer"); 
					//***********解记录写锁**************
				}
			}
			finally
			{
				m_lock.ReleaseReaderLock();  
				//**************解库读锁*************
			}
			return ret;
		}

		//按ID检索
		//strText: 检索文本
		//strMode: 检索方式
		//strRelation: 检索方式
		//myDataSet: 结果集
		//返回值要修改
		//线: 安全的
		protected override int SearchByID(string strText, 
			string strMode,
			string strRelation,
			string strMaxCount,
			string strOrder,
			IsConnected isConnected,
			DpResultSet myDataSet)
		{
			if (strOrder == "")
				strOrder = "ASC"; //默认按升级

			int nCount = 0;
			DpResultSet tempResultSet = new DpResultSet ();

			//前方一致
			if (strMode == "left" || strMode == "")
			{
				//从目录中得到所有xml文件
				string [] files = Directory.GetFiles(GetLocation(),"*.xml");
				foreach(string fileName in files)
				{
					FileInfo myfile = new FileInfo(fileName);
					string strName = myfile.Name;

					if (strName.Length != 14)
						continue;

					int nLength = strText.Length;
					string strTemp = strName.Substring(0,nLength);

					if (StringUtil.RegexCompare(@"\d[10]",strName.Substring(0,10)) == true
						&& strName.Substring(10) == ".xml" 
						&& strTemp == strText.Trim()) 
					{
						//m_strDebugInfo += "<br/>符合条件的文件名:" + strName + "-------" + strTemp + "-----" + Convert.ToString(DpPublicLib.RegexCompare(@"\d*",strTemp)) + "<br/>";
						if (fileName2ID(strName,true) != "")
						{
							string strId = GetID() + ":" + fileName2ID(strName,true);   //将GetLogicName改GetID 
							tempResultSet.Add (new DpRecord(strId));
							//myDataSet.Add(new DpRecord(strId));
							//nCount++;
						}
					}
				}
			}
			else if (strMode == "exact")
			{
				if (strRelation == "draw")
				{
					string [] files = Directory.GetFiles(GetLocation(),"*.xml");
					foreach(string fileName in files)
					{
						FileInfo myfile = new FileInfo(fileName);
						string strName = myfile.Name;

						if (strName.Length != 14)
							continue;

						string strTemp = "";
						strTemp = strName.Substring(0,10);

						int nPosition = strText.IndexOf("-");
						if (nPosition>=0)
						{
							string strID1 ;
							string strID2 ;
							SplitRangeID(strText,out strID1,out strID2);

							strID1 = DbPath.GetID10(strID1);
							strID2 = DbPath.GetID10(strID2);

							if (String.Compare(strTemp,strID1,true)>=0 && String.Compare(strTemp,strID2,true)<=0 )
							{
								string strId = GetID() + ":" + fileName2ID(strName,true);   //将GetLogicName改GetID 
								tempResultSet.Add (new DpRecord(strId));
								
								//myDataSet.Add(new DpRecord(strId));
								//nCount++;
								continue;
							}
						}
						else
						{
							string strOperator;
							string strRealText;
							GetPartCondition(strText,out strOperator,out strRealText);

							strRealText = DbPath.GetID10(strRealText);

							if (isRange(strTemp,strOperator,strRealText) == true)
							{
								//m_strDebugInfo += "<br/>在此范围的记录号:[" + strTemp + "]--------[" + strText + "]<br/>";
								string strId = GetID() + ":" + fileName2ID(strName,true);   //将GetLogicName改GetID 
								tempResultSet.Add (new DpRecord(strId));
								
								
								//myDataSet.Add(new DpRecord(strId));	
								//nCount++;
								continue;
							}
						}
					}
				}
				else
				{
					string [] files = Directory.GetFiles(GetLocation(),"*.xml");
					foreach(string fileName in files)
					{
						FileInfo myfile = new FileInfo(fileName);
						string strName = myfile.Name;

						if (strName.Length != 14)
							continue;

						string strTemp = "";
						strTemp = strName.Substring(0,10);

						strText = DbPath.GetID10(strText);
						if (isRange(strTemp,strRelation,strText) == true)
						{
							//m_strDebugInfo += "<br/>在此范围的记录号:[" + strTemp + "]--------[" + strText + "]<br/>";
							
							string strId = GetID() + ":" + fileName2ID(strName,true);   //将GetLogicName改GetID 
							tempResultSet.Add (new DpRecord(strId));
							//myDataSet.Add(new DpRecord(strId));	
							//nCount++;
							continue;
						}
					}
				}
			}
			tempResultSet.Sort ();
			tempResultSet.RemoveDup();
			int nMaxCount = -1;
			if (strMaxCount != "")
				nMaxCount = Convert.ToInt32 (strMaxCount);
			if (strOrder == "")
				strOrder = "ASC";
			if (strOrder == "ASC")
			{
				for(int i=0;i<tempResultSet.Count ;i++)
				{
					if (nMaxCount != -1)
					{
						if (i>=nMaxCount)
							break;
					}
					myDataSet.Add((DpRecord)tempResultSet[i]);
					nCount ++;
				}
			}
			else if (strOrder == "DESC")
			{
				int k=0;

				for(long i=(tempResultSet.Count -1);i>=0;i--)
				{
					if (nMaxCount != -1)
					{
						if (k>=nMaxCount)
							break;
					}
					myDataSet.Add((DpRecord)tempResultSet[i]);
					nCount ++;
					k++;
				}
			}
			return nCount;
		}


		//可能会抛出的异常:NoMatchException(检索方式与数据类型)
		private string GetKeyCondition(string strText,
			string strMatch,
			string strRelation,
			string strDataType,
			XmlNode nodeConvertquery)
		{
			string strKeyCondition = "";
			//1.
			try
			{
				processRelation(ref strMatch,
					ref strRelation,
					ref strDataType);
			}
			catch(NoMatchException ex)
			{
				throw(ex);
			}

			//2.
			//分别得到keystring与keystringnum的加工方式节点
			XmlNode nodeString = null;
			XmlNode nodeNumber = null;
			if (nodeConvertquery != null)
			{
				nodeString = nodeConvertquery.SelectSingleNode("string");
				nodeNumber = nodeConvertquery.SelectSingleNode("number");
			}

			//3.
			string strKeyValue = "";
			strKeyValue = strText;
			if (strDataType == "string")
			{
				if (nodeString != null)
					strKeyValue = ConvertKey(nodeString,strText);
			}
			else if(strDataType == "number")
			{
				if (nodeNumber != null)
					strKeyValue = ConvertKey(nodeNumber,strText);
			}
			strKeyValue = strKeyValue.Trim();


			//如果strMatch为空，则按"左方一致"
			if (strMatch == "left" || strMatch == "")
			{
				//判断选择的数据类型
				if (strDataType != "string")
				{
					NoMatchException ex = new NoMatchException("在匹配方式为left时或为空时，数据类型不匹配，应该为string");
					throw(ex);
				}
				//这句是保险的，因为上面已抛出异常
				int nLength = strText.Trim().Length;
				strKeyCondition = " (substring(keystring,1," + Convert.ToString(nLength) + ")='" + strKeyValue + "') ";
			}


			//右方一致
			if (strMatch == "right")
			{
				if (strDataType != "string")
				{
					NoMatchException ex = new NoMatchException("在匹配方式为right时，数据类型不匹配，应该为string");
					throw(ex);
				}
				//注意这里要改成右方一致
				int nLength = strText.Trim().Length;
				strKeyCondition = " (substring(keystring,1," + Convert.ToString(nLength) + ")='" + strKeyValue + "') ";
			}
			//精确一致
			if (strMatch == "exact")
			{
				//从词中汲取,较复杂，注意
				if (strRelation == "draw")
				{
					int nPosition;
					nPosition = strText.IndexOf("-");

					//先按"-"算
					if (nPosition >= 0)
					{
						string strText1;
						string strText2;
						SplitRangeID(strText,out strText1, out strText2);


						if (strDataType == "string")
						{
							if (nodeString != null)
							{
								strText1 = ConvertKey(nodeString,strText1);
								strText2 = ConvertKey(nodeString,strText2);
							}
							strKeyCondition = " keystring >= '" +
								strText1 +
								"' and keystring<= '" +
								strText2 + "'";

						}
						else if(strDataType == "number")
						{
							if (nodeNumber != null)
							{
								strText1 = ConvertKey(nodeNumber,strText1);
								strText2 = ConvertKey(nodeNumber,strText2);
							}
							strKeyCondition = " keystringnum >= " +
								strText1 +
								" and keystringnum<= " +
								strText2 +"";
						}
					}
					else
					{
						string strOperator;
						string strRealText;
						GetPartCondition(strText, out strOperator,out strRealText);
						//SQL与Xpath比较运算符的差别
						if (strOperator == "<>")
							strOperator = "!=";
						if (strDataType == "string")
						{
							if (nodeString != null)
								strRealText = ConvertKey(nodeString,strRealText);

							strKeyCondition = "keystring" +
								strOperator +
								"'" + strRealText + "'";
						}
						else if(strDataType == "number")
						{
							if (nodeNumber != null)
								strRealText = ConvertKey(nodeNumber,strRealText);
							strKeyCondition = "keystringnum" +
								strOperator +
								strRealText + " and keystringnum!=-1";
						}
					}
				}
				else
				{

					//当关系操作符为空为，按等于算
					if (strRelation == "")
						strRelation = "=";

					if(strRelation == "<>")
						strRelation = "!=";

					if (strDataType == "string")
					{
						strKeyCondition = " keystring " +
							strRelation +
							"'" + strKeyValue + "'";
					}
					else if (strDataType == "number")
					{
						strKeyCondition = "keystringnum" +
							strRelation +
							"" + strKeyValue + "";
					}
				}
			}
			return strKeyCondition;
		}


		//检索
		public override int SearchByUnion(string strTableList,
			string strText,
			string strMatch,
			string strRelation,
			string strDataType,
			string strMaxCount,
			string strOrder,
			int nWarningLevel,
			string strLanguage,
			IsConnected isConnected,
			DpResultSet oResultSet,
			out int nResultCount,
			ref string strErrorInfo,
			ref string strWarningInfo)
		{
			if (strOrder == "")
				strOrder = "ASC";

			m_lock.AcquireReaderLock(m_nTimeOut); //加读锁
			try
			{
				DpResultSet tempResultSet = new DpResultSet ();
				nResultCount = 0;
				bool isHaveID;
				ArrayList aTable = tableCaptions2aTableName(strTableList,strLanguage,out isHaveID);
				if (isHaveID == true)
				{
					nResultCount += SearchByID(strText,
						strMatch,
						strRelation,
						strMaxCount,
						strOrder,
						isConnected,
						oResultSet);  //注意一个这个函数
				}
				if (aTable == null || aTable.Count == 0)
				{
					if (isHaveID == false)
					{
						strWarningInfo += "检索途径为null，或为空";
					}
					return 0;
				}
				bool bWarning = false;
				string strCommand = "";
				//关于key的条件
				string strKeyCondition = "";
				//总条件
				string strWhere = "";
				foreach(string strTable in aTable)
				{
					tableItem oTable;
					oTable= this.Tables .GetTableItem(strTable);

					if (oTable == null)
						continue;
				
					try
					{
						strKeyCondition = GetKeyCondition(strText,
							strMatch,
							strRelation,
							strDataType,
							oTable.m_nodeConvertQuery);
					}
					catch(NoMatchException ex)
					{
						strWarningInfo += ex.Message;
						bWarning = true;

						if (nWarningLevel == 0)
							return -1;
					}

					strWhere = strKeyCondition;
					XmlDocument dom = new XmlDocument();
					string strTablePath = GetLocation() + id2FileName(strTable.Trim());
					dom.Load(strTablePath);
					strCommand = "/root/key[" + strWhere + "]/idstring";
					XmlNodeList listIdstring;

					try
					{
						listIdstring = dom.SelectNodes(strCommand);
					}
					catch(System.Xml.XPath.XPathException ex)
					{
						strErrorInfo += "Xpath出错:"+ strCommand + "-------"+ex.Message+"<br/>";
						return -1;
					}

					for(int i=0;i<listIdstring.Count ;i++)
					{
						//if (maxCount != -1)
						//{
						//	if (i>=maxCount)
						//	{
						//		break;
						//	}
						//}
						string strIdstring = DomUtil.GetNodeText(listIdstring[i]);
						string strId = GetID() + ":" + strIdstring;  
						tempResultSet.Add(new DpRecord(strId));
						//nResultCount++;
					}

					/*
					foreach(XmlNode nodeIdstring in listIdstring)
					{
						string strIdstring = DomUtil.GetNodeText(nodeIdstring);
						string strId = GetID() + ":" + strIdstring;  

						oResultSet.Add(new DpRecord(strId));
						nResultCount++;
					}
					*/
				}	

				/*
				//测试
				if (DpPublicLib.isInList("account",GetDbType()) != 1)
				{
					string strFileName = oResultSet.Detach ();
					//FileUtil.WriteText("L:\\debug.txt","Detach()得到的文件名:["+strFileName+"]\r\n");
					File.Copy (strFileName,"L:\\resultSet.txt");
					return -1;

				}
				*/


				if (strOrder == "")
					strOrder = "ASC";

				int nMaxCount = -1;
				if (strMaxCount != "")
					nMaxCount = Convert.ToInt32 (strMaxCount);

				if (strOrder == "ASC")
				{
					for(int i=0;i<tempResultSet.Count ;i++)
					{
						if (nMaxCount != -1)
						{
							if (i>=nMaxCount)
								break;
						}
						oResultSet.Add((DpRecord)tempResultSet[i]);
						nResultCount ++;
					}
				}
				else if (strOrder == "DESC")
				{
					for(long i=(tempResultSet.Count -1);i>=0;i--)
					{
						if (nMaxCount != -1)
						{
							if (i>=nMaxCount)
								break;
						}
						oResultSet.Add(((DpRecord)tempResultSet[i]));
						nResultCount ++;
					}
				}
				//排序
				oResultSet.Sort ();
				//最后去重
				oResultSet.RemoveDup();

				if (bWarning == true)
					return -2;
			}
			finally
			{
				m_lock.ReleaseReaderLock();  //解读锁
			}

			return 0;
		}

		//是否在范围里
		private bool isRange(string strID,
			string strOperator, 
			string strRealText)
		{
			if (StringUtil.RegexCompare(@"\d[10]",strID) == false)
				return false;
			if(strOperator == "=")
			{
				if (String.Compare(strID,strRealText) == 0)
				{
					return true;
				}
			}
			if(strOperator == ">=")
			{
				if (String.Compare(strID,strRealText) >= 0)
				{
					return true;
				}
			}
			if(strOperator == "<=")
			{
				if (String.Compare(strID,strRealText) <= 0)
				{
					return true;
				}
			}
			if(strOperator == "<>" || strOperator == "><" || strOperator == "!=")
			{
				if (String.Compare(strID,strRealText) != 0)
				{
					return true;
				}
			}
			if(strOperator == ">")
			{
				if (String.Compare(strID,strRealText) > 0)
				{
					return true;
				}
			}
			if(strOperator == "<")
			{
				if (String.Compare(strID,strRealText) < 0)
				{
					return true;
				}
			}
			return false;
		}

		//私有fileName2ID()函数，从文件名到记录ID
		//strFileName: 文件名
		//isOnlyNumID: 是否仅返回记录ID
		//返回值: string类型，返回去掉扩展名的ID
		private string fileName2ID(string strFileName , bool isOnlyNumID)
		{
			int nPosition;
			nPosition = strFileName.LastIndexOf(".");
			string strExt = "";
			string strNumber = "";

			if (nPosition >=0)
			{
				strNumber = strFileName.Substring(0,nPosition);
				strExt = strFileName.Substring(nPosition+1);
				strExt = strExt.ToUpper(); 
			}
			if (strExt == "XML" && isOnlyNumID == true)
				return strNumber;

			if (strExt != "XML" && isOnlyNumID == false)
				return strFileName;

			return "";
		}

		//从记录ID返回文件名
		//strID: 记录ID
		//返回值: string类型，返回对应的XML文件名
		private string id2FileName(string strID)
		{
			string strResult;
			strResult = strID.Trim()+".xml";
			return strResult;
		}

	}// end of class FileDatabase


	// 设计意图:设计keys表集合类，用于处理表的相关信息
	public class TableCollection:ArrayList
	{
		//构造函数
		//strKeysFile: keys物理文件名
		public TableCollection(string strKeysFile)
		{
			CreateBy(strKeysFile);
		}

		//根keys表创建TableCollection
		//strKeysFile: keys表文件
		public void CreateBy(string strKeysFile)
		{
			XmlDocument domKeys = new XmlDocument();
			domKeys.Load(strKeysFile);

			//包含在key里面的table列表
			XmlNodeList listTable = domKeys.SelectNodes("/root/key/table");
			if (listTable.Count == 0)
				return ;

			//外面的table列表
			XmlNodeList listTableOut = domKeys.SelectNodes("/root/table");
			if (listTable.Count == 0)
				return;

			foreach(XmlNode nodeTable in listTable)
			{
				//找到convertquery节点
				//XmlNode nodeConvertQuery = nodeTable.SelectSingleNode("convertquery");

				//这里根据是否存在caption，来判断是不是完整的table配置节点，应该改一下，改成唯一确定的元素
				//XmlNode nodeCaption;
				//nodeCaption= nodeTable.SelectSingleNode("caption");

				string strRef = DomUtil.GetAttr (nodeTable,"ref"); //name
				if (strRef == "")
					continue;
/*
				if (nodeCaption != null)
				{
					Add(new tableItem(nodeTable,nodeConvertQuery));
					continue;
				}
*/
				foreach(XmlNode nodeTableOut in listTableOut)
				{
					//得到convertquery节点
					XmlNode nodeConvertQuery = nodeTableOut.SelectSingleNode("convertquery");

					//外面的key用name标识
					string strNameOut = DomUtil.GetAttr(nodeTableOut,"name");
					XmlNode nodeCaption = nodeTableOut.SelectSingleNode("caption");

					if ((strRef == strNameOut) && nodeCaption != null)
					{
						Add(new tableItem(nodeTableOut,nodeConvertQuery));
						break;
					}
				}
			}

			this.RemoveDup();
		}
		

		//功能:得到物理表名
		//strIdAttr: id属性
		//返回值: 返回物理表名字符串
		//线: 不安全
		public string GetPhysicalName(string strIdAttr)
		{
			foreach(tableItem oneTable in this)
			{
				if (oneTable.ID == strIdAttr)
					return oneTable.Name;
			}
			return "";
		}

		//得到表物理名称
		public string GetPhysicalName(string strIdAttr,
			string strLanguage)
		{
			foreach(tableItem oneTable in this)
			{
				//if (oneTable.GetCaption(strLanguage) == strIdAttr)
				string strCaptions = oneTable.GetCaption (strLanguage);
				if (StringUtil.isInList(strIdAttr,strCaptions) == true)
					return oneTable.Name;
			}
			return "";
		}
		
		//根据表名得到对象
		public tableItem GetTableItem(string strTableName)
		{
			foreach(tableItem oneTable in this)
			{
				if (oneTable.Name == strTableName)
					return oneTable;
			}
			return null;
		}

		//功能:对本集合的成员进行去重
		public void RemoveDup()   //
		{
			for(int i = 0; i < this.Count;i++)
			{
				for(int j = i+1 ; j < this.Count;j++)
				{
					tableItem ItemI = (tableItem)this[i];
					tableItem Itemj = (tableItem)this[j];

					if(ItemI.compare(Itemj) == 1 )  //因为没排序，所以不能break
					{
						this.RemoveAt(j);
						//throw(new Exception ("去掉第"+Convert.ToString (j)));
					}
				}
			}
		}

		public string Dump()
		{
			string strInfo = "";
			foreach(tableItem oneTable in this)
			{
				strInfo += oneTable.Name + "\r\n";
			}
			return strInfo;
		}

	}  //end of class tableCollection


	// tableItem类，作为tableCollection的成员
	public class tableItem
	{
		XmlNode m_node; //XmlNode节点
		string m_strName; //表名，name属性
		string m_strID; //表ID,id属性
		public XmlNode m_nodeConvertQuery;  //处理配置节点

		//构造函数，给m_strname,m_strID,m_strCaptinChi,m_strCaptionEng赋值
		//nodeTable: 表节点
		//nodeConvertQuery: 表节点
		public tableItem(XmlNode nodeTable,XmlNode nodeConvertQuery)
		{
			m_node = nodeTable;
			m_strName = "keys_" + DomUtil.GetAttr(nodeTable,"name");  //name
			m_strID = DomUtil.GetAttr(nodeTable,"id");

			m_nodeConvertQuery = nodeConvertQuery;
		}

		public string Name
		{
			get
			{
				return m_strName;
			}
		}
		public string ID
		{
			get
			{
				return m_strID;
			}
		}
		public string GetCaption(string strLang)
		{
			string strResult = "";
			if (strLang == "")
			{
				XmlNodeList nodeList = m_node.SelectNodes ("caption");
				foreach(XmlNode node in nodeList)
				{
					if (strResult != "")
					{
						strResult += ",";
					}
					strResult += DomUtil.GetNodeText (node);
				}
			}
			else
			{
				string strXpath;
				strXpath = "caption[@lang='" + strLang.Trim() + "']";

				XmlNode nodeCaption = m_node.SelectSingleNode(strXpath);
				strResult = DomUtil.GetNodeText(nodeCaption);
			}
			return strResult;
		}

		//比较本实例是否与objTableItem相等。
		//objTableItem: 表对象
		//相等返回1，不等返回0  //注意所有比较的函数，应统一返回值
		public int compare(tableItem objTableItem)
		{
			if (this.m_strName == objTableItem.m_strName)
				return 1;

			if (this.m_strID == objTableItem.m_strID)
				return 1;

			return 0;
		}

	} //end of class tableItem


	//设计意图:连接基类，库的连接分为两种，SQL server系统和文件系统，从该类派生
	//例用类的多态性
	public class DpConnection
	{
		//虚构造函数
		//strConnection: 连接字符串
		public DpConnection(string strConnection)
		{}
		//虚打开函数
		public virtual void Open()
		{}
		//虚关闭函数
		public virtual void Close()
		{}
	} //end of class DpConnection



	//派生于DpConnection，DpSqlConnection:对应SQLserver数据库
	public class DpSqlConnection:DpConnection
	{
		//m_sqlConnection:存放sql连接
		public SqlConnection m_sqlConnection;

		//构造函数
		//strConnection: 连接字符串
		public DpSqlConnection(string strConnection):base(strConnection)
		{
			m_sqlConnection = new SqlConnection(strConnection);
		}

		//重写open()
		public override void Open()
		{
			m_sqlConnection.Open();
		}
		//重写Close()
		public override void Close()
		{
			m_sqlConnection.Close();
		}

	} //end of class DpSqlConnection


	//DpFileConnection:对应文件系统
	public class DpFileConnection:DpConnection
	{
		//构造函数
		//strConnection: 连接字符串
		public DpFileConnection(string strConnection):base(strConnection)
		{}

	} //end of class DpFileConnection


	//设计意图：
	//为了通过关键字检索记录，需要将一条记录的所有关键字提取出来存放到数据库keys表中.
	//记录与关键字是拥有的关系，即存记录时同时存关键字，删记录时同时删关键字
	//数据库中每个关键字包含三项内容：
	//keystring: 具体的文本
	//fromstring: 现在还没有用到
	//idstring: 对应的数据记录ID
	//根据数据记录和keys配置文件创建DpKeys集合
	//关键字配置文件包括四项:
	// <key>
	//   <xpath>/description/title</xpath>    :通过xpath从数据dom中找到具体内容存放到keystring
	//   <from>title</from>                   :直接提取内容存入fromstring
	//   <table name="title"/>                :属于哪个表
	// </key>
	// DpKeys从ArrayList继承，成员为DpKeys对象。用于处理关键字部分。
	public class DpKeys:ArrayList 
	{
		//存放调试信息
		public string m_strDebugInfo = "";
		
		//给DpKeys集合加成员
		//通过元数据dom和keys配置文件dom以及数据ID生成DpKeys集合,无返回值
		//domData: 元数据dom
		//domCfg: keys配置文件dom
		//strDataID: 数据ID
		//nKeySize: key的长度
		//db: 数据库
		public void Create(XmlDocument domData,
			XmlDocument domCfg,
			string strDataID,
			int nKeySize,
			Database db)
		{
			if(domData == null)
				return;
			if(domCfg == null)
				return;
			if (nKeySize < 0)
				return;
			if (db == null)
				return;

			XmlNodeList keyList = domCfg.SelectNodes("/root/key");  
			string strKey;
			string strKeyNoProcess;
			string strFrom;
			string strTable;
			string strNum;
			for (int i = 0 ; i < keyList.Count ; i++)  
			{
				XmlNode nodeFrom = keyList[i].SelectSingleNode("from");
				strFrom = DomUtil.GetNodeText(nodeFrom);

				XmlNode nodeTable = keyList[i].SelectSingleNode("table");
				strTable = DomUtil.GetAttr(nodeTable,"ref"); //name

				XmlNode nodeXpath = keyList[i].SelectSingleNode("xpath");
				string strXpath = DomUtil.GetNodeText(nodeXpath);

				string strNstable = DomUtil.GetAttr (nodeXpath,"nstable");

				XmlNode nodeNumber = keyList[i].SelectSingleNode("convert/number");
				XmlNode nodeString = keyList[i].SelectSingleNode("convert/string");

				XmlNode nodeTableReal = domCfg.SelectSingleNode("/root/table[@name='" + strTable + "']");
				XmlNode nodeNumberFromTable = null;
				XmlNode nodeStringFromTable = null;

				if (nodeTableReal != null)
				{
					nodeStringFromTable = nodeTableReal.SelectSingleNode("convert/string");
					nodeNumberFromTable = nodeTableReal.SelectSingleNode("convert/number");
				}

				//从domData里找到xpath对应的所有节点	
				XmlNodeList nodeDataList = null;

				if (strNstable == "all")  //该检索点使用命名空间
				{
					XmlNamespaceManager nsmgr = db.GetKeyNsmgr(domData) ;
					//if (nsmgr != null) //有命令空间时
					nodeDataList = domData.DocumentElement.SelectNodes(strXpath,nsmgr);
				}
				else
				{
					nodeDataList = domData.DocumentElement.SelectNodes(strXpath);
				}

				foreach (XmlNode nodeData in nodeDataList)
				{
					//注意，如果key内容为空，是否也应该算作一个key呢?
					//考虑后应该算作，因为确实存在这条记录，加到keys表里，才能通过空内容检索到
					strKey = DomUtil.GetNodeAllText (nodeData).Trim ();//GetNodeText(nodeData).Trim();

					if (strKey == "")
						continue;
					
					//如果keys的长度大小规定长度，进行截取
					if (strKey.Length > nKeySize)
						strKey = strKey.Substring(0,nKeySize);

					strKeyNoProcess = strKey;

					strNum = "-1";//strKey;   //注意这里可能导致keystring和keystringnum是同样的非数字字符串


						//根据自身的配置进行处理,得到num
					if (nodeNumber != null)
					{
						//FileUtil.WriteText ("L:\\debug.txt",strTable+"表的nodeNumber不为空\r\n");
						strNum = db.ConvertKey(nodeNumber,strKey);
					}

					if (nodeString != null)
					{
						//FileUtil.WriteText ("L:\\debug.txt",strTable+"表的nodeString不为空\r\n");
						strKey = db.ConvertKey(nodeString,strKey);
					}

					//FileUtil.WriteText ("L:\\debug.txt",strNum+"\r\n");

					DpKey oKey = new DpKey(strKey,
						strKeyNoProcess,
						strFrom,strTable,
						strDataID,
						strNum);


						//再次根据table的配置处理num
					if (nodeNumberFromTable != null)
					{
						//FileUtil.WriteText ("L:\\debug.txt",strTable+"表的nodeNumberFromTable不为空\r\n");
						//m_strDebugInfo += "oKey.Num前:" + oKey.Num + "<br/>";
						oKey.Num = db.ConvertKey(nodeNumberFromTable,oKey.Key ); //okey.Num
						//m_strDebugInfo += "oKey.Num后:" + oKey.Num + "<br/>";
					}
					else
					{
						//m_strDebugInfo += "nodeNumberFromTable等于null<br/>";
					}

					if (nodeStringFromTable != null)
					{
						//FileUtil.WriteText ("L:\\debug.txt",strTable+"表的nodeStringFromTable不为空\r\n");
						//m_strDebugInfo += "oKey.Key前:" + oKey.Key + "<br/>";
						oKey.Key = db.ConvertKey(nodeStringFromTable,oKey.Key);
						//m_strDebugInfo += "oKey.Key后:" + oKey.Key + "<br/>";
					}
					else
					{
						//m_strDebugInfo += "nodeStringFromTable等于mull<br/>";
					}

					this.Add(oKey);
				}
			}			
		}

		//设计意图:
		//覆盖记录时，根据新记录得到一些新的key，但原旧记录也存在一些旧的key，
		//可以用笨办法删除原旧记录所有的key，再增加新记录所有的key。
		// 
		//但新旧记录可能有一些重复key，更好的方法是让新旧记录的两组key进行比较，
		//结果分成三部分：
		//1.只在新记录出现的key
		//2.只在旧记录出现的key
		//3.重复的key。
		// 
		//这样在执行覆盖时，增加第一部分，删除第二部分，重复的保持不变，所以就节省了时间
		// 
		//注意调这个函数前，确保集合是排过序的
		// 
		//原来newKeys和oldKeys参数类型都是ref,但因为用户类都是引用类型，所以没必须用ref参数
		//原来还有一个out string strInfo参数用于返回信息，现在统一用m_strDebugInfo，去年这个参数
		//本来打算不用strInfo,统一用m_strDebugInfo,结果不行，因为Merge是静态方法，里面都必须用静态成员，不能使用m_strDebugInfo
		//newKeys: 新记录的key集合
		//oldKeys: 旧记录的key集合
		//strInfo: out参数，返回处理信息
		//返回值: 重复的key集合
		public static DpKeys Merge(DpKeys newKeys,
			DpKeys oldKeys,
			out string strInfo)
		{
			strInfo = "";
			DpKeys dupKeys = new DpKeys();
			if (newKeys.Count == 0)
				return dupKeys;
			if (oldKeys.Count == 0)
				return dupKeys;
			DpKey newOneKey;
			DpKey oldOneKey;
			int i = 0;    //i,j等于-1时表示对应的集合结束
			int j = 0;
			int ret;
			//无条件循环，当有一个集合结束（下标变为-1）跳出循环
			while (true)
			{
				if (i >= newKeys.Count)
				{
					i = -1;
					strInfo += "左结束<br/>";
				}

				if (j >= oldKeys.Count)
				{
					j = -1;
					strInfo += "右结束<br/>";
				}

				//两个集合都没有结束时，执行比较，否则跳出循环（至少一个集合结束）
				if (i != -1 && j != -1)
				{
					newOneKey = (DpKey)newKeys[i];
					oldOneKey = (DpKey)oldKeys[j];

					ret = newOneKey.CompareTo(oldOneKey);  //MyCompareTo(oldOneKey); //改CompareTO

					strInfo += "左-右,返回"+Convert.ToString(ret)+"<br/>";

					if (ret == 0)  //当等于0时,i,j不改变
					{
						newKeys.Remove(newOneKey);          //改为RemoveAt()
						oldKeys.Remove(oldOneKey);
						dupKeys.Add(oldOneKey);
					}


					//哪一个小，哪一个向下移动

					if (ret<0)  
						i++;

					if (ret>0)
						j++;

					strInfo += "i=" + Convert.ToString(i) + "j=" + Convert.ToString(j) + "<br/>";
				}
				else
				{
					break;
				}
			}
			return dupKeys;
		}

		//列出集合中的所有项,调试使用
		//返回表格字符串
		public string Dump()
		{
			string strTable;
			strTable = "<table border='1'><tr><td>table</td><td>key</td><td>from</td><td>id</td></tr>";

			foreach(DpKey eachKey in this)
			{
				strTable += "<tr><td>" + eachKey.Table + "</td><td>[" + eachKey.Key + "]</td><td>[" + eachKey.From + "]</td><td>[" + eachKey.ID + "]</td></tr>";
			}
			strTable += "</table>";

			return strTable;
		}

		//对集合进行去重，去重之前先用DpKeys.Sort()进行排序。
		public void RemoveDup()
		{
			for(int i=0;i<this.Count;i++)
			{
				for(int j=i+1;j<this.Count;j++)
				{
					DpKey Itemi = (DpKey)this[i];
					DpKey Itemj = (DpKey)this[j];

					if(Itemi.CompareTo(Itemj) == 0)  //MyCompareTo(Itemj) == 0)  //改CompareTo
					{
						this.RemoveAt(j);
					}
					else
					{
						break;
					}
				}
			}
		}

	} //end of class DpKeys


	//设计意图:表示单个key
	//继承IComparable接口
	public class DpKey:IComparable
	{
		string m_strKey; //存放key
		string m_strKeyNoProcess;
		string m_strFrom; //存放from
		string m_strID; //存放ID
		string m_strTable;//存放table

		//将key转换成int类型，将存放一个专门的字段里，解决11>2的问题
		string m_strNum;


		//构造函数,对每一个去掉前后空白
		//strKey: keystring字符串
		//strFrom: fromstring字符串
		//strTable: table字符串
		//strDataID: idstring字符串
		//strNum: keyNum
		//<example>
		// <c>
		// DpKey("aa","bb","cc","10");
		// </c>
		//</example>
		public DpKey(string strKey,
			string strKeyNoProcess,
			string strFrom,
			string strTable, 
			string strDataID, 
			string strNum)
		{
			m_strKey = strKey.Trim();
			m_strKeyNoProcess = strKeyNoProcess;
			m_strFrom = strFrom.Trim();
			m_strID = strDataID.Trim();
			m_strTable = strTable.Trim();
			m_strNum = strNum;
		}

		public string Key
		{
			get
			{
				return m_strKey;
			}
			set
			{
				m_strKey = value;
			}
		}
		public string KeyNoProcess
		{
			get
			{
				return this.m_strKeyNoProcess ;
			}
			set
			{
				this.m_strKeyNoProcess = value;
			}
		}
		public string Num
		{
			get
			{
				return m_strNum;
			}
			set
			{
				m_strNum = value;
			}
		
		}
		public string From
		{
			get
			{
				return m_strFrom;
			}
		}
		public string Table
		{
			get
			{
				return m_strTable;
			}
		}
		public string ID
		{
			get
			{
				return m_strID;
			}
		}

		//隐式执行，可能直接通过DpKey的对象实例来访问
		//obj: 比较的对象
		//0表示相等，其它表示不等
		public int CompareTo(object obj)
		{
			DpKey mykey = (DpKey)obj;
			int ret;

			ret = String.Compare(this.Key,mykey.Key);
			if (ret != 0)
				return ret;

			ret = String.Compare(this.From,mykey.From);
			if (ret != 0)
				return ret;

			ret = String.Compare(this.ID,mykey.ID);
			return ret;
		}
	} //end of class DpKey


	//设计意图:
	//从FileNameHolder继承，集合类型，
	//为了处理跟数据库有关的操作，增加了提取和保存一条元数据对应的对象资源的方法
	public class DpResHolder:FileNameHolder
	{
		//调试信息
		public string m_strDebugInfo = "";

		//公共GetFileObj()方法，从数据库中提取某一个元数据对应的所有对象资源，放到临时目录里，
		//并创建FileNameItem对象，加到集合里
		//db: 数据库
		//strDataID: 元数据记录ID
		//data: 元数据dom
		//myConnection: 连接信息
		//成功返回0，出错返回-1
		public int GetFileObj(Database db,
			string strDataID,
			XmlDocument data,
			DpSqlConnection myConnection)
		{
			if (db == null)
				return -1;

			if (data == null)
				return -1;

			XmlNodeList fileList = data.SelectNodes(@"//file");

			string strFilePath;
			string strFileName;
			foreach(XmlNode oneFile in fileList)
			{
				strFileName = DomUtil.GetNodeText(oneFile);

				//如果文件为空，继续下一个
				if (strFileName == "")
					continue;

				//如果m_strDir和m_strPrefix,从基类中继承的成员，其中有一个为空，则不会拼出临时目录，抛出异常，或者返回-1
				if (m_strDir == "" || m_strPrefix == "")
				{
					Exception ex = new Exception("Dir或Prefix至少有一个为空");
					throw(ex);

					//m_strDebugInfo += "Dir或Prefix至少有一个为空";
					//return -1;
				}

				string strID = strDataID + "_" + strFileName;  //在数据库中的记录号
				//m_strDebugInfo += "拼出的记录号:[" + strID + "]<br/>";


				strFilePath = m_strDir + "~" + m_strPrefix + "_" + strFileName;  //保存到磁盘上
				//m_strDebugInfo += "拼出的文件名:[" + strFilePath + "]<br/>";

				//将元数据XML保存到临时目录里
				Stream fs = new FileStream(strFilePath,FileMode.Create,FileAccess.Write);
				string strContentType;
				int ret = 0;
				ret = db.GetRecord(strID,
					fs,
					out strContentType,
					myConnection,
					false);

				if (ret != 0)
					return -1;  //没找到记录属于出错

				fs.Close();

				//创建FileNameItem实例，加到集合里
				Add(new FileNameItem(strFileName));
			}
			return 0;
		}

		//将集合里所有成员指定的文件保存到数据库里
		//db: 数据库
		//strDataID: 元数据记录ID
		//oldData: 旧元数据dom
		//myConnection: 连接信息
		//成功返回0，出错返回-1
		public int SaveFileObj(Database db,
			string strDataID,
			XmlDocument oldData,
			SqlConnection myConnection)
		{
			if (db == null)
			{
				//m_strDebugInfo += "数据库为null<br/>";
				return -1;
			}

			//如果旧dom为空，跳过删除旧记录
			if (oldData == null)
				goto skipDelFile; 

			XmlNodeList listFile = oldData.SelectNodes(@"//file");
			foreach(XmlNode nodeFile in listFile)
			{
				string strName = DomUtil.GetNodeText(nodeFile);
				//内容为空，继续下一个
				if (strName == "")
					continue;

				string strFileID;  //文件存到数据库的ID
				strFileID = strDataID + "_" + strName;

				string strTemp;
				db.DeleteForce(strFileID,
					false,
					out strTemp);  //注意这里使用强制删除方法  //DeleteForce

				//m_strDebugInfo += "从库中删除了对象资源" + strFileID + "<br/>";
			}

			skipDelFile:
			string strFileName;
			foreach(FileNameItem objFileName in this)
			{
				strFileName = objFileName.FileName;

				if (strFileName == "")
					continue;

				//如果目录或前缀没有，抛出异常
				if (m_strDir == "" || m_strPrefix == "")
				{
					Exception ex = new Exception("Dir或Prefix至少有一个为空");
					throw(ex);
				}

				string strID = strDataID + "_" + strFileName; 

				//调用DpPublicLib的makeFilePath()方法，拼出完整的路径。替换文件名的"?"
				strFileName = rmsUtil.makeFilePath(m_strDir,m_strPrefix,strFileName); 

				//m_strDebugInfo += "数据库名" + db.GetSqlName() + "-----拼出的资源记录号:[" + strID + "]<br/>";
				//m_strDebugInfo += "拼出的资源路径名:[" + strFileName + "]<br/>";

				Stream fs = new FileStream(strFileName,FileMode.Open,FileAccess.Read);
				db.WriteRes(strID,fs,"ofile");
				fs.Close();
			}
			return 0;
		}
	}//end of class DpResHolder


	//设计意图:
	//为了在浏览格式时确定最大列数，
	//设计了BrowseColumnMax类，派生于DictionaryBase类，
	//是关键字/值类型，存放库名/最大列数
	public class BrowseColumnMax:DictionaryBase
	{
		//实现IDictionary接口的Add()方法，给集合中增加一项
		//strDbName: 库名字符串
		//nValue: 最大列数
		public void Add(string strDbName, int nValue)  
		{
			Dictionary.Add(strDbName, nValue );
		}

		//定义索引器，以名称进行访问
		public int this[String strDbName]
		{
			get  
			{
				return( (int) Dictionary[strDbName] );
			}
			set  
			{
				Dictionary[strDbName] = value;
			}
		}

		//实现IDictionary接口的Contains()方法，
		//检测集合中是否包含指定项
		//strDbName: 关键字库名
		//如果集合中包含，返回true,否则返回false</returns>
		public bool Contains(string strDbName)
		{
			return Dictionary.Contains(strDbName);
		}
	}//end of class BrowseColumnMax
}
